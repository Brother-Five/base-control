; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\motor.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\motor.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -I..\..\RTX\inc -I..\..\RTX\portable -I..\..\MySrc -I..\..\Libraries -I..\..\MySrc\ostask -I..\..\MySrc\MPU6050 -D__MICROLIB -D__UVISION_VERSION=514 -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DARM_MATH_CM4 -DSTM32F40_41xxx --omf_browse=.\flash\obj\motor.crf ..\..\MySrc\motor.cpp]
                          THUMB

                          AREA ||i.MOTOR_Init||, CODE, READONLY, ALIGN=2

                  MOTOR_Init PROC
;;;138    }
;;;139    void MOTOR_Init( short id, short mode)
000000  b530              PUSH     {r4,r5,lr}
;;;140    {
000002  b085              SUB      sp,sp,#0x14
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;141        CanTxMsg msg_send = { 0, 0, CAN_Id_Standard, CAN_RTR_Data, 0x08,{0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55}};
000008  2214              MOVS     r2,#0x14
00000a  4911              LDR      r1,|L1.80|
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       __aeabi_memcpy4
;;;142    
;;;143    	msg_send.StdId = id<<4|0;
000012  2000              MOVS     r0,#0
000014  ea401004          ORR      r0,r0,r4,LSL #4
000018  9000              STR      r0,[sp,#0]
;;;144    	CAN_send(CAN1,&msg_send);
00001a  4669              MOV      r1,sp
00001c  480d              LDR      r0,|L1.84|
00001e  f7fffffe          BL       PUSH_CAN_FIFO
;;;145    	delay_ms(1000);
000022  f44f707a          MOV      r0,#0x3e8
000026  f8dfc030          LDR      r12,|L1.88|
00002a  df00              SVC      #0x0
;;;146    	msg_send.StdId = id <<4|1;
00002c  2001              MOVS     r0,#1
00002e  eb001004          ADD      r0,r0,r4,LSL #4
000032  9000              STR      r0,[sp,#0]
;;;147        msg_send.Data[0]=mode;
000034  b2e8              UXTB     r0,r5
000036  f88d000b          STRB     r0,[sp,#0xb]
;;;148    	CAN_send(CAN1,&msg_send);
00003a  4669              MOV      r1,sp
00003c  4805              LDR      r0,|L1.84|
00003e  f7fffffe          BL       PUSH_CAN_FIFO
;;;149    	 delay_ms(1000);
000042  f44f707a          MOV      r0,#0x3e8
000046  f8dfc010          LDR      r12,|L1.88|
00004a  df00              SVC      #0x0
;;;150    //	tsk_unlock ();
;;;151    }
00004c  b005              ADD      sp,sp,#0x14
00004e  bd30              POP      {r4,r5,pc}
;;;152    
                          ENDP

                  |L1.80|
                          DCD      ||.constdata||+0x3c
                  |L1.84|
                          DCD      0x40006400
                  |L1.88|
                          DCD      rt_dly_wait

                          AREA ||i.MOTOR_SetPWM||, CODE, READONLY, ALIGN=2

                  MOTOR_SetPWM PROC
;;;152    
;;;153    void MOTOR_SetPWM(short pwm,short id)
000000  b530              PUSH     {r4,r5,lr}
;;;154    {
000002  b085              SUB      sp,sp,#0x14
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;155    
;;;156        CanTxMsg msg_send = { 0, 0, CAN_Id_Standard, CAN_RTR_Data, 0x08,
000008  2214              MOVS     r2,#0x14
00000a  4910              LDR      r1,|L2.76|
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       __aeabi_memcpy4
;;;157                             {0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55}};
;;;158    	if(pwm < -5000) pwm = -5000;
000012  480f              LDR      r0,|L2.80|
000014  4284              CMP      r4,r0
000016  da00              BGE      |L2.26|
000018  4604              MOV      r4,r0
                  |L2.26|
;;;159    	if(pwm > 5000) pwm = 5000;
00001a  f2413088          MOV      r0,#0x1388
00001e  4284              CMP      r4,r0
000020  dd00              BLE      |L2.36|
000022  4604              MOV      r4,r0
                  |L2.36|
;;;160        // msg_send.StdId = id<<4 | 4;
;;;161        // msg_send.Data[0] = (unsigned char)((5000>>8)&0xff);
;;;162        // msg_send.Data[1] = (unsigned char)(5000&0xff);
;;;163        // msg_send.Data[2] = (unsigned char)((pwm/10>>8)&0xff);
;;;164        // msg_send.Data[3] = (unsigned char)(pwm/10&0xff);
;;;165        // CAN_send(CAN1,&msg_send);
;;;166    	msg_send.StdId = id<<4 | 2;
000024  2002              MOVS     r0,#2
000026  eb001005          ADD      r0,r0,r5,LSL #4
00002a  9000              STR      r0,[sp,#0]
;;;167        msg_send.Data[0] = (pwm>>8)&0xff;
00002c  0a20              LSRS     r0,r4,#8
00002e  f88d000b          STRB     r0,[sp,#0xb]
;;;168        msg_send.Data[1] = (unsigned char)(pwm&0xff);
000032  b2e1              UXTB     r1,r4
000034  f88d100c          STRB     r1,[sp,#0xc]
;;;169    	while(CAN_Transmit(CAN1,&msg_send) == CAN_TxStatus_NoMailBox);
000038  bf00              NOP      
                  |L2.58|
00003a  4669              MOV      r1,sp
00003c  4805              LDR      r0,|L2.84|
00003e  f7fffffe          BL       CAN_Transmit
000042  2804              CMP      r0,#4
000044  d0f9              BEQ      |L2.58|
;;;170    //	CAN_send(CAN1,&msg_send);
;;;171    }
000046  b005              ADD      sp,sp,#0x14
000048  bd30              POP      {r4,r5,pc}
;;;172    
                          ENDP

00004a  0000              DCW      0x0000
                  |L2.76|
                          DCD      ||.constdata||+0x50
                  |L2.80|
                          DCD      0xffffec78
                  |L2.84|
                          DCD      0x40006400

                          AREA ||i.Motor||, CODE, READONLY, ALIGN=1

                  Motor PROC
;;;80     }
;;;81     void Motor(int *MotorData,u8 motorx,int power)
000000  f8503021          LDR      r3,[r0,r1,LSL #2]
;;;82     {
;;;83         MotorData[motorx] += power;
000004  4413              ADD      r3,r3,r2
000006  f8403021          STR      r3,[r0,r1,LSL #2]
;;;84     }
00000a  4770              BX       lr
;;;85     
                          ENDP


                          AREA ||i.Motor_Aguest||, CODE, READONLY, ALIGN=2

                  Motor_Aguest PROC
;;;9       */
;;;10     void Motor_Aguest(u16 Ax,u16 Ay,float Az,float _mAngle)
000000  b570              PUSH     {r4-r6,lr}
;;;11     {
000002  ed2d8b08          VPUSH    {d8-d11}
000006  b084              SUB      sp,sp,#0x10
000008  4604              MOV      r4,r0
00000a  460d              MOV      r5,r1
00000c  eef08a40          VMOV.F32 s17,s0
000010  eeb08a60          VMOV.F32 s16,s1
;;;12     //	static u8 count;
;;;13         int MotorData[4]={0};
000014  2000              MOVS     r0,#0
000016  9000              STR      r0,[sp,#0]
000018  9001              STR      r0,[sp,#4]
00001a  9002              STR      r0,[sp,#8]
00001c  9003              STR      r0,[sp,#0xc]
;;;14     	float xpower,ypower,zpower;
;;;15     	float AxChange,AyChange;
;;;16         AxChange = ((float)Ax - 1024.0f)*No1;
00001e  ee004a10          VMOV     s0,r4
000022  eeb80a40          VCVT.F32.U32 s0,s0
000026  eddf0a37          VLDR     s1,|L4.260|
00002a  ee300a60          VSUB.F32 s0,s0,s1
00002e  eef10a0c          VMOV.F32 s1,#7.00000000
000032  ee200a20          VMUL.F32 s0,s0,s1
000036  eeb09a40          VMOV.F32 s18,s0
;;;17         AyChange = ((float)Ay - 1024.0f)*No1;
00003a  ee005a10          VMOV     s0,r5
00003e  eeb80a40          VCVT.F32.U32 s0,s0
000042  eddf0a30          VLDR     s1,|L4.260|
000046  ee300a60          VSUB.F32 s0,s0,s1
00004a  eef10a0c          VMOV.F32 s1,#7.00000000
00004e  ee200a20          VMUL.F32 s0,s0,s1
000052  eef09a40          VMOV.F32 s19,s0
;;;18     
;;;19         xpower = ((float)AyChange*arm_sin_f32(_mAngle*0.0174532f)+(float)AxChange*arm_cos_f32(_mAngle*0.0174532f));
000056  eddf0a2c          VLDR     s1,|L4.264|
00005a  ee680a20          VMUL.F32 s1,s16,s1
00005e  eeb00a60          VMOV.F32 s0,s1
000062  f7fffffe          BL       arm_sin_f32
000066  ee60ba29          VMUL.F32 s23,s0,s19
00006a  eddf0a27          VLDR     s1,|L4.264|
00006e  ee680a20          VMUL.F32 s1,s16,s1
000072  eeb00a60          VMOV.F32 s0,s1
000076  f7fffffe          BL       arm_cos_f32
00007a  ee49ba00          VMLA.F32 s23,s18,s0
00007e  eeb0aa6b          VMOV.F32 s20,s23
;;;20         ypower = ((float)AyChange*arm_cos_f32(_mAngle*0.0174532f)-(float)AxChange*arm_sin_f32(_mAngle*0.0174532f));
000082  eddf0a21          VLDR     s1,|L4.264|
000086  ee680a20          VMUL.F32 s1,s16,s1
00008a  eeb00a60          VMOV.F32 s0,s1
00008e  f7fffffe          BL       arm_cos_f32
000092  ee60ba29          VMUL.F32 s23,s0,s19
000096  eddf0a1c          VLDR     s1,|L4.264|
00009a  ee680a20          VMUL.F32 s1,s16,s1
00009e  eeb00a60          VMOV.F32 s0,s1
0000a2  f7fffffe          BL       arm_sin_f32
0000a6  ee49ba40          VMLS.F32 s23,s18,s0
0000aa  eef0aa6b          VMOV.F32 s21,s23
;;;21     	zpower = Az;
0000ae  eeb0ba68          VMOV.F32 s22,s17
;;;22     //	zpower  = (int)(((float)Az - 1024.0f)*No1);//(Az - 1024)*No1;
;;;23     
;;;24         X_Axic(MotorData,xpower);
0000b2  eebd0aca          VCVT.S32.F32 s0,s20
0000b6  ee101a10          VMOV     r1,s0
0000ba  4668              MOV      r0,sp
0000bc  f7fffffe          BL       X_Axic
;;;25         Y_Axic(MotorData,ypower);
0000c0  eebd0aea          VCVT.S32.F32 s0,s21
0000c4  ee101a10          VMOV     r1,s0
0000c8  4668              MOV      r0,sp
0000ca  f7fffffe          BL       Y_Axic
;;;26         Z_Axic(MotorData,zpower);
0000ce  eebd0acb          VCVT.S32.F32 s0,s22
0000d2  ee101a10          VMOV     r1,s0
0000d6  4668              MOV      r0,sp
0000d8  f7fffffe          BL       Z_Axic
;;;27     	Motor_DataScale(MotorData,5000);
0000dc  f2413188          MOV      r1,#0x1388
0000e0  4668              MOV      r0,sp
0000e2  f7fffffe          BL       Motor_DataScale
;;;28     //	u1_printf("%d\t%d\t%d\t%d\r\n\r\n",MotorData[Motor1],MotorData[Motor2],MotorData[Motor3],MotorData[Motor4]);
;;;29         Motor_CarFrame(MotorData[Motor1],MotorData[Motor2],MotorData[Motor3],MotorData[Motor4]);//经过Can给底盘4个电机发送的向量相加后的值
0000e6  9e03              LDR      r6,[sp,#0xc]
0000e8  b233              SXTH     r3,r6
0000ea  9e02              LDR      r6,[sp,#8]
0000ec  b232              SXTH     r2,r6
0000ee  9e01              LDR      r6,[sp,#4]
0000f0  b231              SXTH     r1,r6
0000f2  9e00              LDR      r6,[sp,#0]
0000f4  b230              SXTH     r0,r6
0000f6  f7fffffe          BL       Motor_CarFrame
;;;30     
;;;31     
;;;32     
;;;33     }
0000fa  b004              ADD      sp,sp,#0x10
0000fc  ecbd8b08          VPOP     {d8-d11}
000100  bd70              POP      {r4-r6,pc}
;;;34     
                          ENDP

000102  0000              DCW      0x0000
                  |L4.260|
000104  44800000          DCFS     0x44800000 ; 1024
                  |L4.264|
000108  3c8efa03          DCFS     0x3c8efa03 ; 0.017453199252486229

                          AREA ||i.Motor_CarFrame||, CODE, READONLY, ALIGN=2

                  Motor_CarFrame PROC
;;;86     
;;;87     void Motor_CarFrame(int16_t current_201,int16_t current_202,int16_t current_203,int16_t current_204)
000000  b5f0              PUSH     {r4-r7,lr}
;;;88     {
000002  b085              SUB      sp,sp,#0x14
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;89         CanTxMsg msg_send = { 0x110, 0x110, CAN_Id_Standard, CAN_RTR_Data, 0x08, {0, 0, 0, 0, 0, 0, 0, 0}};
00000c  2214              MOVS     r2,#0x14
00000e  4914              LDR      r1,|L5.96|
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       __aeabi_memcpy4
;;;90         current_202=-current_202;
000016  4260              RSBS     r0,r4,#0
000018  b204              SXTH     r4,r0
;;;91     		current_204=-current_204;
00001a  4268              RSBS     r0,r5,#0
00001c  b205              SXTH     r5,r0
;;;92     	// msg_send.StdId = 0x110 + 0;
;;;93         msg_send.Data[0] = (unsigned char)(current_201 >> 8);
00001e  0a30              LSRS     r0,r6,#8
000020  f88d000b          STRB     r0,[sp,#0xb]
;;;94         msg_send.Data[1] = (unsigned char)current_201;
000024  b2f1              UXTB     r1,r6
000026  f88d100c          STRB     r1,[sp,#0xc]
;;;95         msg_send.Data[2] = (unsigned char)(current_202 >> 8);
00002a  0a21              LSRS     r1,r4,#8
00002c  f88d100d          STRB     r1,[sp,#0xd]
;;;96         msg_send.Data[3] = (unsigned char)current_202;
000030  b2e1              UXTB     r1,r4
000032  f88d100e          STRB     r1,[sp,#0xe]
;;;97         msg_send.Data[4] = (unsigned char)(current_203 >> 8);
000036  0a39              LSRS     r1,r7,#8
000038  f88d100f          STRB     r1,[sp,#0xf]
;;;98         msg_send.Data[5] = (unsigned char)current_203;
00003c  b2f9              UXTB     r1,r7
00003e  f88d1010          STRB     r1,[sp,#0x10]
;;;99         msg_send.Data[6] = (unsigned char)(current_204 >> 8);
000042  0a29              LSRS     r1,r5,#8
000044  f88d1011          STRB     r1,[sp,#0x11]
;;;100        msg_send.Data[7] = (unsigned char)current_204;
000048  b2e9              UXTB     r1,r5
00004a  f88d1012          STRB     r1,[sp,#0x12]
;;;101    	while(CAN_Transmit(CAN1,&msg_send) == CAN_TxStatus_NoMailBox);
00004e  bf00              NOP      
                  |L5.80|
000050  4669              MOV      r1,sp
000052  4804              LDR      r0,|L5.100|
000054  f7fffffe          BL       CAN_Transmit
000058  2804              CMP      r0,#4
00005a  d0f9              BEQ      |L5.80|
;;;102    //    CAN_send(CAN1, &msg_send);
;;;103    }
00005c  b005              ADD      sp,sp,#0x14
00005e  bdf0              POP      {r4-r7,pc}
;;;104    
                          ENDP

                  |L5.96|
                          DCD      ||.constdata||
                  |L5.100|
                          DCD      0x40006400

                          AREA ||i.Motor_DataScale||, CODE, READONLY, ALIGN=1

                  Motor_DataScale PROC
;;;58     }
;;;59     void Motor_DataScale(int *MotorData,int max)
000000  b570              PUSH     {r4-r6,lr}
;;;60     {
000002  ed2d8b02          VPUSH    {d8}
000006  b084              SUB      sp,sp,#0x10
000008  4604              MOV      r4,r0
00000a  460e              MOV      r6,r1
;;;61         int TempBuf[4]={0};
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
000010  9001              STR      r0,[sp,#4]
000012  9002              STR      r0,[sp,#8]
000014  9003              STR      r0,[sp,#0xc]
;;;62         u8 k;
;;;63         float scale;
;;;64         for ( k = 0; k < 4; k++)
000016  2500              MOVS     r5,#0
000018  e00d              B        |L6.54|
                  |L6.26|
;;;65         {
;;;66             TempBuf[k] = myabs(MotorData[k]);
00001a  f8540025          LDR      r0,[r4,r5,LSL #2]
00001e  2800              CMP      r0,#0
000020  dd02              BLE      |L6.40|
000022  f8540025          LDR      r0,[r4,r5,LSL #2]
000026  e002              B        |L6.46|
                  |L6.40|
000028  f8540025          LDR      r0,[r4,r5,LSL #2]
00002c  4240              RSBS     r0,r0,#0
                  |L6.46|
00002e  f84d0025          STR      r0,[sp,r5,LSL #2]
000032  1c68              ADDS     r0,r5,#1              ;64
000034  b2c5              UXTB     r5,r0                 ;64
                  |L6.54|
000036  2d04              CMP      r5,#4                 ;64
000038  dbef              BLT      |L6.26|
;;;67         }
;;;68     //	u1_printf("%d\t%d\t%d\t%d\r\n",TempBuf[0],TempBuf[1],TempBuf[2],TempBuf[3]);
;;;69     	bubble_sort(TempBuf,4);
00003a  2104              MOVS     r1,#4
00003c  4668              MOV      r0,sp
00003e  f7fffffe          BL       _Z11bubble_sortIiEvPT_i ; void bubble_sort<int>(T1*, int)
;;;70     //    u1_printf("%d\t%d\t%d\t%d\r\n",TempBuf[0],TempBuf[1],TempBuf[2],TempBuf[3]);
;;;71         if(TempBuf[3] >= max)
000042  9803              LDR      r0,[sp,#0xc]
000044  42b0              CMP      r0,r6
000046  db0a              BLT      |L6.94|
;;;72             scale = ((float)max)/((float)TempBuf[3]);
000048  ed9d0a03          VLDR     s0,[sp,#0xc]
00004c  eef80ac0          VCVT.F32.S32 s1,s0
000050  ee006a10          VMOV     s0,r6
000054  eeb80ac0          VCVT.F32.S32 s0,s0
000058  ee808a20          VDIV.F32 s16,s0,s1
00005c  e001              B        |L6.98|
                  |L6.94|
;;;73         else
;;;74             scale = 1.0f;
00005e  eeb78a00          VMOV.F32 s16,#1.00000000
                  |L6.98|
;;;75     //	u1_printf("%d\t%d\t%d\t%d\r\n",(int)(((float)TempBuf[0])*scale),(int)(((float)TempBuf[1])*scale),(int)(((float)TempBuf[2])*scale),(int)(((float)TempBuf[3])*scale));
;;;76         MotorData[Motor1] =  (int)(((float)MotorData[Motor1]) * scale);
000062  ed940a00          VLDR     s0,[r4,#0]
000066  eeb80ac0          VCVT.F32.S32 s0,s0
00006a  ee200a08          VMUL.F32 s0,s0,s16
00006e  eebd0ac0          VCVT.S32.F32 s0,s0
000072  ed840a00          VSTR     s0,[r4,#0]
;;;77         MotorData[Motor2] =  (int)(((float)MotorData[Motor2]) * scale);
000076  ed940a01          VLDR     s0,[r4,#4]
00007a  eeb80ac0          VCVT.F32.S32 s0,s0
00007e  ee200a08          VMUL.F32 s0,s0,s16
000082  eebd0ac0          VCVT.S32.F32 s0,s0
000086  ed840a01          VSTR     s0,[r4,#4]
;;;78         MotorData[Motor3] =  (int)(((float)MotorData[Motor3]) * scale);
00008a  ed940a02          VLDR     s0,[r4,#8]
00008e  eeb80ac0          VCVT.F32.S32 s0,s0
000092  ee200a08          VMUL.F32 s0,s0,s16
000096  eebd0ac0          VCVT.S32.F32 s0,s0
00009a  ed840a02          VSTR     s0,[r4,#8]
;;;79         MotorData[Motor4] =  (int)(((float)MotorData[Motor4]) * scale);
00009e  ed940a03          VLDR     s0,[r4,#0xc]
0000a2  eeb80ac0          VCVT.F32.S32 s0,s0
0000a6  ee200a08          VMUL.F32 s0,s0,s16
0000aa  eebd0ac0          VCVT.S32.F32 s0,s0
0000ae  ed840a03          VSTR     s0,[r4,#0xc]
;;;80     }
0000b2  b004              ADD      sp,sp,#0x10
0000b4  ecbd8b02          VPOP     {d8}
0000b8  bd70              POP      {r4-r6,pc}
;;;81     void Motor(int *MotorData,u8 motorx,int power)
                          ENDP


                          AREA ||i.Motor_Init||, CODE, READONLY, ALIGN=2

                  Motor_Init PROC
;;;105    
;;;106    void Motor_Init(int8_t mode,int8_t ret)
000000  b530              PUSH     {r4,r5,lr}
;;;107    {
000002  b085              SUB      sp,sp,#0x14
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;108        CanTxMsg msg_send = { 0x02, 0x02, CAN_Id_Standard, CAN_RTR_Data, 0x08, {0, 0, 0, 0, 0, 0, 0, 0}};
000008  2214              MOVS     r2,#0x14
00000a  4911              LDR      r1,|L7.80|
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       __aeabi_memcpy4
;;;109    
;;;110        msg_send.Data[0] = (unsigned char)mode;
000012  b2e0              UXTB     r0,r4
000014  f88d000b          STRB     r0,[sp,#0xb]
;;;111        msg_send.Data[1] = (unsigned char)mode;
000018  b2e1              UXTB     r1,r4
00001a  f88d100c          STRB     r1,[sp,#0xc]
;;;112        msg_send.Data[2] = (unsigned char)mode;
00001e  b2e1              UXTB     r1,r4
000020  f88d100d          STRB     r1,[sp,#0xd]
;;;113        msg_send.Data[3] = (unsigned char)mode;
000024  b2e1              UXTB     r1,r4
000026  f88d100e          STRB     r1,[sp,#0xe]
;;;114        msg_send.Data[4] = (unsigned char)mode;
00002a  b2e1              UXTB     r1,r4
00002c  f88d100f          STRB     r1,[sp,#0xf]
;;;115        msg_send.Data[5] = (unsigned char)mode;
000030  b2e1              UXTB     r1,r4
000032  f88d1010          STRB     r1,[sp,#0x10]
;;;116        msg_send.Data[6] = (unsigned char)ret;
000036  b2e9              UXTB     r1,r5
000038  f88d1011          STRB     r1,[sp,#0x11]
;;;117        msg_send.Data[7] = (unsigned char)mode;
00003c  b2e1              UXTB     r1,r4
00003e  f88d1012          STRB     r1,[sp,#0x12]
;;;118        CAN_send(CAN1, &msg_send);
000042  4669              MOV      r1,sp
000044  4803              LDR      r0,|L7.84|
000046  f7fffffe          BL       PUSH_CAN_FIFO
;;;119    
;;;120    }
00004a  b005              ADD      sp,sp,#0x14
00004c  bd30              POP      {r4,r5,pc}
;;;121    
                          ENDP

00004e  0000              DCW      0x0000
                  |L7.80|
                          DCD      ||.constdata||+0x14
                  |L7.84|
                          DCD      0x40006400

                          AREA ||i.Motor_Power||, CODE, READONLY, ALIGN=2

                  Motor_Power PROC
;;;121    
;;;122    void Motor_Power(u16 id,u16 current)
000000  b530              PUSH     {r4,r5,lr}
;;;123    {
000002  b085              SUB      sp,sp,#0x14
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;124        CanTxMsg msg_send = { 0, 0, CAN_Id_Standard, CAN_RTR_Data, 0x08, {0, 0, 0, 0, 0, 0, 0, 0}};
000008  2214              MOVS     r2,#0x14
00000a  490f              LDR      r1,|L8.72|
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       __aeabi_memcpy4
;;;125    	
;;;126    	  msg_send.StdId = 0x131;
000012  f2401031          MOV      r0,#0x131
000016  9000              STR      r0,[sp,#0]
;;;127        msg_send.Data[0] = 0x55;
000018  2055              MOVS     r0,#0x55
00001a  f88d000b          STRB     r0,[sp,#0xb]
;;;128        msg_send.Data[1] = 0xaa;
00001e  21aa              MOVS     r1,#0xaa
000020  f88d100c          STRB     r1,[sp,#0xc]
;;;129        msg_send.Data[2] = (u8)((id>>8)&0xff);
000024  0a21              LSRS     r1,r4,#8
000026  f88d100d          STRB     r1,[sp,#0xd]
;;;130        msg_send.Data[3] = (u8)(id&0xff);
00002a  b2e1              UXTB     r1,r4
00002c  f88d100e          STRB     r1,[sp,#0xe]
;;;131    //    msg_send.Data[4] = (u8)((power>>8)&0xff);
;;;132        msg_send.Data[5] = (u8)((current>>8)&0xff);
000030  0a29              LSRS     r1,r5,#8
000032  f88d1010          STRB     r1,[sp,#0x10]
;;;133        msg_send.Data[6] = (u8)(current&0xff);
000036  b2e9              UXTB     r1,r5
000038  f88d1011          STRB     r1,[sp,#0x11]
;;;134    //    msg_send.Data[7] = (u8)(_w&0xff);
;;;135    	CAN_Transmit(CAN1,&msg_send);
00003c  4669              MOV      r1,sp
00003e  4803              LDR      r0,|L8.76|
000040  f7fffffe          BL       CAN_Transmit
;;;136    //    while(CAN_Transmit(CAN1,&msg_send) == CAN_TxStatus_NoMailBox);
;;;137    
;;;138    }
000044  b005              ADD      sp,sp,#0x14
000046  bd30              POP      {r4,r5,pc}
;;;139    void MOTOR_Init( short id, short mode)
                          ENDP

                  |L8.72|
                          DCD      ||.constdata||+0x28
                  |L8.76|
                          DCD      0x40006400

                          AREA ||i.Motor_YawPitch||, CODE, READONLY, ALIGN=2

                  Motor_YawPitch PROC
;;;175    
;;;176    void Motor_YawPitch(int16_t current_205,int16_t current_206)
000000  b530              PUSH     {r4,r5,lr}
;;;177    {
000002  b085              SUB      sp,sp,#0x14
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;178        CanTxMsg msg_send = { 0x1ff, 0x1ff, CAN_Id_Standard, CAN_RTR_Data, 0x08,{0, 0, 0, 0, 0, 0, 0, 0}};
000008  2214              MOVS     r2,#0x14
00000a  490b              LDR      r1,|L9.56|
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       __aeabi_memcpy4
;;;179    
;;;180        msg_send.Data[0] = (unsigned char)(current_205 >> 8);
000012  0a20              LSRS     r0,r4,#8
000014  f88d000b          STRB     r0,[sp,#0xb]
;;;181        msg_send.Data[1] = (unsigned char)current_205;
000018  b2e1              UXTB     r1,r4
00001a  f88d100c          STRB     r1,[sp,#0xc]
;;;182        msg_send.Data[2] = (unsigned char)(current_206 >> 8);
00001e  0a29              LSRS     r1,r5,#8
000020  f88d100d          STRB     r1,[sp,#0xd]
;;;183        msg_send.Data[3] = (unsigned char)current_206;
000024  b2e9              UXTB     r1,r5
000026  f88d100e          STRB     r1,[sp,#0xe]
;;;184        CAN_send(CAN2, &msg_send);
00002a  4669              MOV      r1,sp
00002c  4803              LDR      r0,|L9.60|
00002e  f7fffffe          BL       PUSH_CAN_FIFO
;;;185    }
000032  b005              ADD      sp,sp,#0x14
000034  bd30              POP      {r4,r5,pc}
;;;186    
                          ENDP

000036  0000              DCW      0x0000
                  |L9.56|
                          DCD      ||.constdata||+0x64
                  |L9.60|
                          DCD      0x40006800

                          AREA ||i.X_Axic||, CODE, READONLY, ALIGN=1

                  X_Axic PROC
;;;34     
;;;35     void X_Axic(int *MotorData,int power)
000000  b530              PUSH     {r4,r5,lr}
;;;36     {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;37         Motor(MotorData,Motor1,-power);
000006  4262              RSBS     r2,r4,#0
000008  2100              MOVS     r1,#0
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       Motor
;;;38         Motor(MotorData,Motor2,-power);
000010  4262              RSBS     r2,r4,#0
000012  2101              MOVS     r1,#1
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       Motor
;;;39         Motor(MotorData,Motor3,power);
00001a  4622              MOV      r2,r4
00001c  2102              MOVS     r1,#2
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       Motor
;;;40         Motor(MotorData,Motor4,power);
000024  4622              MOV      r2,r4
000026  2103              MOVS     r1,#3
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       Motor
;;;41     }
00002e  bd30              POP      {r4,r5,pc}
;;;42     
                          ENDP


                          AREA ||i.Y_Axic||, CODE, READONLY, ALIGN=1

                  Y_Axic PROC
;;;42     
;;;43     void Y_Axic(int *MotorData,int power)
000000  b530              PUSH     {r4,r5,lr}
;;;44     {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;45         Motor(MotorData,Motor1,-power);
000006  4262              RSBS     r2,r4,#0
000008  2100              MOVS     r1,#0
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       Motor
;;;46         Motor(MotorData,Motor2,power);
000010  4622              MOV      r2,r4
000012  2101              MOVS     r1,#1
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       Motor
;;;47         Motor(MotorData,Motor3,power);
00001a  4622              MOV      r2,r4
00001c  2102              MOVS     r1,#2
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       Motor
;;;48         Motor(MotorData,Motor4,-power);
000024  4262              RSBS     r2,r4,#0
000026  2103              MOVS     r1,#3
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       Motor
;;;49     }
00002e  bd30              POP      {r4,r5,pc}
;;;50     
                          ENDP


                          AREA ||i.Z_Axic||, CODE, READONLY, ALIGN=1

                  Z_Axic PROC
;;;50     
;;;51     void  Z_Axic(int *MotorData,int power)
000000  b530              PUSH     {r4,r5,lr}
;;;52     {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;53     
;;;54     	Motor(MotorData,Motor1,-power);
000006  4262              RSBS     r2,r4,#0
000008  2100              MOVS     r1,#0
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       Motor
;;;55         Motor(MotorData,Motor2,-power);
000010  4262              RSBS     r2,r4,#0
000012  2101              MOVS     r1,#1
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       Motor
;;;56         Motor(MotorData,Motor3,-power);
00001a  4262              RSBS     r2,r4,#0
00001c  2102              MOVS     r1,#2
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       Motor
;;;57         Motor(MotorData,Motor4,-power);
000024  4262              RSBS     r2,r4,#0
000026  2103              MOVS     r1,#3
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       Motor
;;;58     }
00002e  bd30              POP      {r4,r5,pc}
;;;59     void Motor_DataScale(int *MotorData,int max)
                          ENDP


                          AREA ||i._Z8GYRO_RSTv||, CODE, READONLY, ALIGN=2

                  _Z8GYRO_RSTv PROC ; GYRO_RST()
;;;186    
;;;187    void GYRO_RST(void)
000000  b500              PUSH     {lr}
;;;188    {
000002  b085              SUB      sp,sp,#0x14
;;;189        CanTxMsg tx_message;
;;;190    
;;;191        tx_message.StdId = 0x404;
000004  f2404004          MOV      r0,#0x404
000008  9000              STR      r0,[sp,#0]
;;;192        tx_message.IDE = CAN_Id_Standard;
00000a  2000              MOVS     r0,#0
00000c  f88d0008          STRB     r0,[sp,#8]
;;;193        tx_message.RTR = CAN_RTR_Data;
000010  f88d0009          STRB     r0,[sp,#9]
;;;194        tx_message.DLC = 0x08;
000014  2008              MOVS     r0,#8
000016  f88d000a          STRB     r0,[sp,#0xa]
;;;195    
;;;196        tx_message.Data[0] = 0x00;
00001a  2000              MOVS     r0,#0
00001c  f88d000b          STRB     r0,[sp,#0xb]
;;;197        tx_message.Data[1] = 0x01;
000020  2101              MOVS     r1,#1
000022  f88d100c          STRB     r1,[sp,#0xc]
;;;198        tx_message.Data[2] = 0x02;
000026  2102              MOVS     r1,#2
000028  f88d100d          STRB     r1,[sp,#0xd]
;;;199        tx_message.Data[3] = 0x03;
00002c  2103              MOVS     r1,#3
00002e  f88d100e          STRB     r1,[sp,#0xe]
;;;200        tx_message.Data[4] = 0x04;
000032  2104              MOVS     r1,#4
000034  f88d100f          STRB     r1,[sp,#0xf]
;;;201        tx_message.Data[5] = 0x05;
000038  2105              MOVS     r1,#5
00003a  f88d1010          STRB     r1,[sp,#0x10]
;;;202        tx_message.Data[6] = 0x06;
00003e  2106              MOVS     r1,#6
000040  f88d1011          STRB     r1,[sp,#0x11]
;;;203        tx_message.Data[7] = 0x07;
000044  2107              MOVS     r1,#7
000046  f88d1012          STRB     r1,[sp,#0x12]
;;;204    
;;;205    //     CAN_Transmit(CAN1,&tx_message);
;;;206        while( CAN_Transmit(CAN1,&tx_message)==CAN_TxStatus_NoMailBox );
00004a  bf00              NOP      
                  |L13.76|
00004c  4669              MOV      r1,sp
00004e  4803              LDR      r0,|L13.92|
000050  f7fffffe          BL       CAN_Transmit
000054  2804              CMP      r0,#4
000056  d0f9              BEQ      |L13.76|
;;;207    }
000058  b005              ADD      sp,sp,#0x14
00005a  bd00              POP      {pc}
;;;208    
                          ENDP

                  |L13.92|
                          DCD      0x40006400

                          AREA ||.ARM.exidx||, LINKORDER=||i.Motor_CarFrame||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i.Motor_CarFrame||
                          DCD      0x00000001

                          AREA ||area_number.15||, LINKORDER=||i.Motor_DataScale||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.15||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.Motor_DataScale||
                          DCD      0x00000001

                          AREA ||area_number.16||, LINKORDER=||i.Motor||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.16||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.Motor||
                          DCD      0x00000001

                          AREA ||area_number.17||, LINKORDER=||i.Z_Axic||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.17||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.Z_Axic||
                          DCD      0x00000001

                          AREA ||area_number.18||, LINKORDER=||i.Y_Axic||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.18||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.Y_Axic||
                          DCD      0x00000001

                          AREA ||area_number.19||, LINKORDER=||i.X_Axic||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.19||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.X_Axic||
                          DCD      0x00000001

                          AREA ||area_number.20||, LINKORDER=||i.Motor_Aguest||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.20||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.Motor_Aguest||
                          DCD      0x00000001

                          AREA ||area_number.21||, LINKORDER=||i.Motor_Init||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.21||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.Motor_Init||
                          DCD      0x00000001

                          AREA ||area_number.22||, LINKORDER=||i.Motor_Power||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.22||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.Motor_Power||
                          DCD      0x00000001

                          AREA ||area_number.23||, LINKORDER=||i.MOTOR_Init||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.23||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.MOTOR_Init||
                          DCD      0x00000001

                          AREA ||area_number.24||, LINKORDER=||i.MOTOR_SetPWM||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.24||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.MOTOR_SetPWM||
                          DCD      0x00000001

                          AREA ||area_number.25||, LINKORDER=||i.Motor_YawPitch||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.25||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.Motor_YawPitch||
                          DCD      0x00000001

                          AREA ||area_number.26||, LINKORDER=||i._Z8GYRO_RSTv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.26||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z8GYRO_RSTv||
                          DCD      0x00000001

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00000110
                          DCD      0x00000110
000008  00000800          DCB      0x00,0x00,0x08,0x00
00000c  00000000          DCB      0x00,0x00,0x00,0x00
000010  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000002
                          DCD      0x00000002
00001c  00000800          DCB      0x00,0x00,0x08,0x00
000020  00000000          DCB      0x00,0x00,0x00,0x00
000024  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
                          DCD      0x00000000
000030  00000800          DCB      0x00,0x00,0x08,0x00
000034  00000000          DCB      0x00,0x00,0x00,0x00
000038  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
                          DCD      0x00000000
000044  00000855          DCB      0x00,0x00,0x08,0x55
000048  55555555          DCB      0x55,0x55,0x55,0x55
00004c  55555500          DCB      0x55,0x55,0x55,0x00
                          DCD      0x00000000
                          DCD      0x00000000
000058  00000855          DCB      0x00,0x00,0x08,0x55
00005c  55555555          DCB      0x55,0x55,0x55,0x55
000060  55555500          DCB      0x55,0x55,0x55,0x00
                          DCD      0x000001ff
                          DCD      0x000001ff
00006c  00000800          DCB      0x00,0x00,0x08,0x00
000070  00000000          DCB      0x00,0x00,0x00,0x00
000074  00000000          DCB      0x00,0x00,0x00,0x00

                          AREA ||t._Z11bubble_sortIiEvPT_i||, COMGROUP=_Z11bubble_sortIiEvPT_i, CODE, READONLY, ALIGN=1

                  _Z11bubble_sortIiEvPT_i PROC ; void bubble_sort<int>(T1*, int)
;;;30     template<class T>
;;;31     void bubble_sort(T a[], int n)
000000  b570              PUSH     {r4-r6,lr}
;;;32     {
000002  4602              MOV      r2,r0
;;;33         int i,j;
;;;34     //	char flag;
;;;35     	T temp;
;;;36         for (j = 0; j < n - 1; j++)
000004  2300              MOVS     r3,#0
000006  e018              B        |L99.58|
                  |L99.8|
;;;37     	{
;;;38     //		if(flag)
;;;39     //			break;
;;;40     //		flag = 1;
;;;41             for (i = 0; i < n - 1 - j; i++)
000008  2000              MOVS     r0,#0
00000a  e011              B        |L99.48|
                  |L99.12|
;;;42             {
;;;43                 if(a[i] > a[i + 1])
00000c  f8526020          LDR      r6,[r2,r0,LSL #2]
000010  1c45              ADDS     r5,r0,#1
000012  f8525025          LDR      r5,[r2,r5,LSL #2]
000016  42ae              CMP      r6,r5
000018  dd09              BLE      |L99.46|
;;;44                 {
;;;45                     temp = a[i];
00001a  f8524020          LDR      r4,[r2,r0,LSL #2]
;;;46                     a[i] = a[i + 1];
00001e  1c45              ADDS     r5,r0,#1
000020  f8525025          LDR      r5,[r2,r5,LSL #2]
000024  f8425020          STR      r5,[r2,r0,LSL #2]
;;;47                     a[i + 1] = temp;
000028  1c45              ADDS     r5,r0,#1
00002a  f8424025          STR      r4,[r2,r5,LSL #2]
                  |L99.46|
00002e  1c40              ADDS     r0,r0,#1              ;41
                  |L99.48|
000030  1e4d              SUBS     r5,r1,#1              ;41
000032  1aed              SUBS     r5,r5,r3              ;41
000034  4285              CMP      r5,r0                 ;41
000036  dce9              BGT      |L99.12|
000038  1c5b              ADDS     r3,r3,#1              ;36
                  |L99.58|
00003a  1e4d              SUBS     r5,r1,#1              ;36
00003c  429d              CMP      r5,r3                 ;36
00003e  dce3              BGT      |L99.8|
;;;48     //				flag = 0;
;;;49                 }
;;;50             }
;;;51     	}
;;;52     }
000040  bd70              POP      {r4-r6,pc}
;;;53     //#ifdef __cplusplus
                          ENDP


                          AREA ||area_number.100||, COMGROUP=_Z11bubble_sortIiEvPT_i, LINKORDER=||t._Z11bubble_sortIiEvPT_i||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.100||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._Z11bubble_sortIiEvPT_i||
                          DCD      0x00000001

;*** Start embedded assembler ***

#line 1 "..\\..\\MySrc\\motor.cpp"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_motor_cpp_ff34c24a___Z7__REV16j|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_motor_cpp_ff34c24a___Z7__REV16j| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_motor_cpp_ff34c24a___Z7__REVSHi|
#line 144
|__asm___9_motor_cpp_ff34c24a___Z7__REVSHi| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_motor_cpp_ff34c24a___Z5__RRXj|
#line 300
|__asm___9_motor_cpp_ff34c24a___Z5__RRXj| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
