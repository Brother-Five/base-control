; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--cpp --list --split_sections --debug -c --asm --interleave -o.\flash\obj\usartframe_stm32.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\usartframe_stm32.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -I..\..\RTX\inc -I..\..\RTX\portable -I..\..\MySrc -I..\..\Libraries -I..\..\MySrc\ostask -I..\..\MySrc\MPU6050 -D__MICROLIB -D__UVISION_VERSION=514 -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DARM_MATH_CM4 -DSTM32F40_41xxx --omf_browse=.\flash\obj\usartframe_stm32.crf ..\..\MySrc\UsartFrame_STM32.cpp]
                          THUMB

                          AREA ||i.CRC_STM32Check||, CODE, READONLY, ALIGN=2

                  CRC_STM32Check PROC
;;;55      */
;;;56     uint32_t CRC_STM32Check(uint8_t* pBuffer, uint32_t BufferLength , uint32_t CRC32Rec)
000000  b5f0              PUSH     {r4-r7,lr}
;;;57     {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;58       uint32_t i;
;;;59     //  uint32_t temp = ((BufferLength-1)>>2) + 1;//除与4
;;;60       uint32_t temp = BufferLength>>2;
000008  08a6              LSRS     r6,r4,#2
;;;61       uint32_t tempcount;
;;;62       CRC->CR = CRC_CR_RESET;
00000a  2001              MOVS     r0,#1
00000c  4f0d              LDR      r7,|L1.68|
00000e  60b8              STR      r0,[r7,#8]
;;;63       for(i = 0; i < temp; i++)
000010  2200              MOVS     r2,#0
000012  e010              B        |L1.54|
                  |L1.20|
;;;64       {
;;;65     	tempcount = i<<2;//乘与4
000014  0091              LSLS     r1,r2,#2
;;;66         CRC->DR = pBuffer[tempcount]<<24 | pBuffer[tempcount+1]<<16 | pBuffer[tempcount+2]<<8 | pBuffer[tempcount+3];//1|2|3|4转化成小端格式
000016  5c58              LDRB     r0,[r3,r1]
000018  0607              LSLS     r7,r0,#24
00001a  1c48              ADDS     r0,r1,#1
00001c  5c18              LDRB     r0,[r3,r0]
00001e  ea474700          ORR      r7,r7,r0,LSL #16
000022  1c88              ADDS     r0,r1,#2
000024  5c18              LDRB     r0,[r3,r0]
000026  ea472000          ORR      r0,r7,r0,LSL #8
00002a  1ccf              ADDS     r7,r1,#3
00002c  5ddf              LDRB     r7,[r3,r7]
00002e  4338              ORRS     r0,r0,r7
000030  4f04              LDR      r7,|L1.68|
000032  6038              STR      r0,[r7,#0]
000034  1c52              ADDS     r2,r2,#1              ;63
                  |L1.54|
000036  42b2              CMP      r2,r6                 ;63
000038  d3ec              BCC      |L1.20|
;;;67       }
;;;68       CRC->DR = CRC32Rec;//最后是CRC32校验码
00003a  4802              LDR      r0,|L1.68|
00003c  6005              STR      r5,[r0,#0]
;;;69       return (CRC->DR);
00003e  6800              LDR      r0,[r0,#0]
;;;70     }
000040  bdf0              POP      {r4-r7,pc}
;;;71     
                          ENDP

000042  0000              DCW      0x0000
                  |L1.68|
                          DCD      0x40023000

                          AREA ||i.CRC_STM32Hard||, CODE, READONLY, ALIGN=2

                  CRC_STM32Hard PROC
;;;30      */
;;;31     uint32_t CRC_STM32Hard(uint8_t* pBuffer, uint32_t BufferLength)
000000  b570              PUSH     {r4-r6,lr}
;;;32     {
000002  4602              MOV      r2,r0
000004  460c              MOV      r4,r1
;;;33       uint32_t i;
;;;34     //  uint32_t temp = ((BufferLength-1)>>2) + 1;//除与4
;;;35       uint32_t temp = BufferLength>>2;
000006  08a5              LSRS     r5,r4,#2
;;;36       uint32_t tempcount;
;;;37       CRC->CR = CRC_CR_RESET;
000008  2001              MOVS     r0,#1
00000a  4e0d              LDR      r6,|L2.64|
00000c  60b0              STR      r0,[r6,#8]
;;;38     //  if(BufferLength%4)
;;;39       for(i = 0; i < temp; i++)
00000e  2300              MOVS     r3,#0
000010  e010              B        |L2.52|
                  |L2.18|
;;;40       {
;;;41     	tempcount = i<<2;
000012  0099              LSLS     r1,r3,#2
;;;42         CRC->DR = pBuffer[tempcount]<<24 | pBuffer[tempcount+1]<<16 | pBuffer[tempcount+2]<<8 | pBuffer[tempcount+3];
000014  5c50              LDRB     r0,[r2,r1]
000016  0606              LSLS     r6,r0,#24
000018  1c48              ADDS     r0,r1,#1
00001a  5c10              LDRB     r0,[r2,r0]
00001c  ea464600          ORR      r6,r6,r0,LSL #16
000020  1c88              ADDS     r0,r1,#2
000022  5c10              LDRB     r0,[r2,r0]
000024  ea462000          ORR      r0,r6,r0,LSL #8
000028  1cce              ADDS     r6,r1,#3
00002a  5d96              LDRB     r6,[r2,r6]
00002c  4330              ORRS     r0,r0,r6
00002e  4e04              LDR      r6,|L2.64|
000030  6030              STR      r0,[r6,#0]
000032  1c5b              ADDS     r3,r3,#1              ;39
                  |L2.52|
000034  42ab              CMP      r3,r5                 ;39
000036  d3ec              BCC      |L2.18|
;;;43       }
;;;44       return (CRC->DR);
000038  4801              LDR      r0,|L2.64|
00003a  6800              LDR      r0,[r0,#0]
;;;45     }
00003c  bd70              POP      {r4-r6,pc}
;;;46     
                          ENDP

00003e  0000              DCW      0x0000
                  |L2.64|
                          DCD      0x40023000

                          AREA ||i.DMA1_Stream3_IRQHandler||, CODE, READONLY, ALIGN=2

                  DMA1_Stream3_IRQHandler PROC
;;;434    
;;;435    void DMA_IRQHandler_Tx_UsartFrame(void)
000000  b510              PUSH     {r4,lr}
;;;436    {
;;;437    	if(DMA_GetITStatus(DMA_Stream_Tx_UsartFrame, DMA_StreamIT_Tx_TCIFx_UsartFrame))
000002  4906              LDR      r1,|L3.28|
000004  4806              LDR      r0,|L3.32|
000006  f7fffffe          BL       DMA_GetITStatus
00000a  b130              CBZ      r0,|L3.26|
;;;438    	{
;;;439    		TxFlag = 0;
00000c  2000              MOVS     r0,#0
00000e  4905              LDR      r1,|L3.36|
000010  7008              STRB     r0,[r1,#0]
;;;440    		// printf("ok\r\n");
;;;441    		DMA_ClearITPendingBit(DMA_Stream_Tx_UsartFrame, DMA_StreamIT_Tx_TCIFx_UsartFrame);
000012  4902              LDR      r1,|L3.28|
000014  4802              LDR      r0,|L3.32|
000016  f7fffffe          BL       DMA_ClearITPendingBit
                  |L3.26|
;;;442    	}
;;;443    }
00001a  bd10              POP      {r4,pc}
;;;444    
                          ENDP

                  |L3.28|
                          DCD      0x18008000
                  |L3.32|
                          DCD      0x40026058
                  |L3.36|
                          DCD      TxFlag

                          AREA ||i.USART3_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART3_IRQHandler PROC
;;;314    extern tGameInfo GameInfo;
;;;315    void DMA_IRQHandler_Rx_UsartFrame(void)
000000  b510              PUSH     {r4,lr}
;;;316    {
;;;317    //	static FRAME ptrmsg;
;;;318    	u8 clear = clear;
000002  bf00              NOP      
;;;319    
;;;320    //	static short flag[3];//	static uint32_t temp;
;;;321    //	static u8 count[2];
;;;322    	if (USART_GetITStatus(USART_UsartFrame, USART_IT_IDLE) != RESET)//空闲中断,
000004  f2404124          MOV      r1,#0x424
000008  480f              LDR      r0,|L4.72|
00000a  f7fffffe          BL       USART_GetITStatus
00000e  b1c8              CBZ      r0,|L4.68|
;;;323    	{
;;;324    		
;;;325    
;;;326    //		GameInfo = *(tGameInfo*)(frame_rx_buffer);
;;;327    //============================================================================================================
;;;328    //		if(CRC_STM32Check( ((FRAME *)frame_rx_buffer) ->DATA , ((FRAME *)frame_rx_buffer)->LEN + ((FRAME *)frame_rx_buffer)->MOD,((FRAME *)frame_rx_buffer)->CRC32)!= 0)
;;;329    //		{
;;;330    //			u1_printf("unmatch crc\r\n");
;;;331    //		}
;;;332    //		else
;;;333    //		{
;;;334    
;;;335    //			CVValue = (CVStuct *) (&((FRAME*)frame_rx_buffer)->DATA[0]);
;;;336    
;;;337    //			switch(CVValue->State.ID)
;;;338    //			{
;;;339    //				case 1:
;;;340    
;;;341    //						flag[0] = CVValue->State.Flag;
;;;342    //						// temp[0] = CVValue->CV_X;
;;;343    //						// temp[1] = CVValue->CV_Y;
;;;344    //						CVAllValue.Strike_Angle_X = CVValue->CV_X;// - 1.38782f
;;;345    //						CVAllValue.Strike_Angle_Y = CVValue->CV_Y;
;;;346    //					break;
;;;347    //				case 2:
;;;348    //						flag[1] = CVValue->State.Flag;
;;;349    //						// temp[2] = CVValue->CV_X;
;;;350    //						// temp[3] = CVValue->CV_Y;
;;;351    //						CVAllValue.Strike_Coordinate_X = CVValue->CV_X - 51;
;;;352    //						CVAllValue.Strike_Coordinate_Y = CVValue->CV_Y;
;;;353    //				case 3:
;;;354    //						flag[2] = CVValue->State.Flag;
;;;355    //						// temp[2] = CVValue->CV_X;
;;;356    //						// temp[3] = CVValue->CV_Y;
;;;357    //						CVAllValue.DaFu_Angle_X = CVValue->CV_X;
;;;358    //						CVAllValue.DaFu_Angle_Y = CVValue->CV_Y;
;;;359    //					break;
;;;360    //				default:break;
;;;361    //			}
;;;362    
;;;363    ////			(YawPID.Current -  CarFramePID.Current)/22.7556f//摄像头角度
;;;364    //			if(cv_flag == 1)
;;;365    //			{
;;;366    
;;;367    ////				YawPID.SetTarget( (YawPID.Current -  CarFramePID.Current ) - (CVAllValue.DaFu_Angle_X/100.0f)*22.7556f);
;;;368    ////				PitchPID.SetTarget(0.130883442399745*CVAllValue.DaFu_Angle_Y+2.377947784543123e+03 + 5);
;;;369    //				if(flag[1] == 1)
;;;370    //				{
;;;371    //					CVPID.SetCurrent(CVAllValue.Strike_Coordinate_X);
;;;372    //					CVPitchPID.SetCurrent(CVAllValue.Strike_Coordinate_Y);
;;;373    //					flag[1] = 0;
;;;374    //				}
;;;375    //				if(flag[0] == 1)
;;;376    //				{
;;;377    ////					CVPID.SetCurrent(CVAllValue.Strike_Coordinate_X);
;;;378    ////					CVPID.AdjustPID();
;;;379    ////					if(myabs(CVAllValue.Strike_Coordinate_X)<(30))
;;;380    ////					{
;;;381    ////						bsp_LedToggle(3);
;;;382    ////					}
;;;383    ////					else
;;;384    ////					{
;;;385    ////						bsp_LedOn(3);
;;;386    ////					}
;;;387    //					YawPID.SetTarget( (YawPID.Current -  CarFramePID.Current ) - (CVAllValue.Strike_Angle_X/100.0f)*22.7556f + CVPID.Out);
;;;388    ////					u1_printf("%x\t%x\t%d\t%d\t%d\t%d\r\n",CVValue->State.ID,CVValue->State.Flag,CVAllValue.Strike_Angle_X,CVAllValue.Strike_Angle_Y,\
;;;389    //			CVValue->CV_X,CVValue->CV_Y\
;;;390    //			);
;;;391    //// 					PitchPID.SetTarget(Parameter_Operater.data.PITCH_Encoder_Mid + (CVAllValue.Strike_Angle_Y/100.0f)*22.7556f);
;;;392    //					// PitchPID.SetTarget(0.130883442399745*CVAllValue.Strike_Angle_Y+2.377947784543123e+03 - CVPitchPID.Out);
;;;393    //					flag[0] = 0;
;;;394    //					count[0] = 0;
;;;395    //				}
;;;396    //				else count[0]++;
;;;397    //				if(count[0] == 30)
;;;398    //				{
;;;399    //					CVPID.ITerm = 0;
;;;400    //					CVPitchPID.ITerm = 0;
;;;401    //					YawPID.SetTarget( (YawPID.Current -  CarFramePID.Current));
;;;402    //					YawPID.SetTarget( Parameter_Operater.data.PITCH_Encoder_Mid);
;;;403    //					count[0] = 0;
;;;404    //				}
;;;405    ////				u1_printf("%x\t%x\t%d\t%d\t%d\t%d\r\n",CVValue->State.ID,CVValue->State.Flag,CVAllValue.Strike_Angle_X,CVAllValue.Strike_Angle_Y,\
;;;406    ////			CVValue->CV_X,CVValue->CV_Y\
;;;407    ////			);
;;;408    ////				if(myabs(CVAllValue.Strike_Coordinate_Y)<3)
;;;409    ////					u1_printf("%d\t%d\r\n",CVAllValue.Strike_Angle_Y,tmeee);
;;;410    ////				ANO_Data1_Send(0xf1,CVAllValue.Strike_Coordinate_X);
;;;411    ////				u1_printf("%x\t%x\t%d\t%d\t%d\t%d\r\n",CVValue->State.ID,CVValue->State.Flag,CVAllValue.Strike_Angle_X,CVAllValue.Strike_Angle_Y,\
;;;412    //			CVAllValue.Strike_Coordinate_X,CVAllValue.Strike_Coordinate_Y\
;;;413    //			);
;;;414    
;;;415    //			}
;;;416    ////			u1_printf("%x\t%x\t%d\t%d\r\n",CVValue->State.ID,CVValue->State.Flag,CVValue->CV_X,CVValue->CV_Y);
;;;417    ////			u1_printf("%d\t%d\r\n",YawPID.Current,CarFramePID.Current);
;;;418    ////			u1_printf("%d\t%d\r\n",Get_cv_x(),Get_cv_y());
;;;419    ////			if(CVValue->State.ID==2)
;;;420    ////			u1_printf("%x\t%d\t%d\r\n",CVValue->State.Flag,CVAllValue.Strike_Angle_X,CVAllValue.Strike_Angle_Y);
;;;421    ////			u1_printf("%x\t%x\t%d\t%d\t%d\t%d\r\n",CVValue->State.ID,CVValue->State.Flag,temp[0],temp[1],\
;;;422    ////			temp[2],temp[3]\
;;;423    ////			);
;;;424    //		}
;;;425    //============================================================================================================
;;;426    		DMA_Cmd(DMA_Stream_Rx_UsartFrame,DISABLE);//DMA失能
000010  2100              MOVS     r1,#0
000012  480e              LDR      r0,|L4.76|
000014  f7fffffe          BL       DMA_Cmd
;;;427    		while(DMA_GetCmdStatus(DMA_Stream_Rx_UsartFrame));//检测是否失能成功，DMA失能时需要等待少许时间才失能成功
000018  bf00              NOP      
                  |L4.26|
00001a  480c              LDR      r0,|L4.76|
00001c  f7fffffe          BL       DMA_GetCmdStatus
000020  2800              CMP      r0,#0
000022  d1fa              BNE      |L4.26|
;;;428    		DMA_SetCurrDataCounter(DMA_Stream_Rx_UsartFrame,1024);//数据传输量
000024  f44f6180          MOV      r1,#0x400
000028  4808              LDR      r0,|L4.76|
00002a  f7fffffe          BL       DMA_SetCurrDataCounter
;;;429    		DMA_Cmd(DMA_Stream_Rx_UsartFrame,ENABLE);//DMA重新使能
00002e  2101              MOVS     r1,#1
000030  4806              LDR      r0,|L4.76|
000032  f7fffffe          BL       DMA_Cmd
;;;430    		clear = USART_UsartFrame->SR;//这两步为清除空闲中断标志
000036  4804              LDR      r0,|L4.72|
000038  8800              LDRH     r0,[r0,#0]
00003a  b2c4              UXTB     r4,r0
;;;431    		clear = USART_UsartFrame->DR;//这两步为清除空闲中断标志
00003c  4802              LDR      r0,|L4.72|
00003e  1d00              ADDS     r0,r0,#4
000040  8800              LDRH     r0,[r0,#0]
000042  b2c4              UXTB     r4,r0
                  |L4.68|
;;;432    	}
;;;433    }
000044  bd10              POP      {r4,pc}
;;;434    
                          ENDP

000046  0000              DCW      0x0000
                  |L4.72|
                          DCD      0x40004800
                  |L4.76|
                          DCD      0x40026028

                          AREA ||i.USARTFrame_DMA_Send||, CODE, READONLY, ALIGN=2

                  USARTFrame_DMA_Send PROC
;;;258    u8 TxFlag;
;;;259    void USARTFrame_DMA_Send(uint8_t *pbuffer, uint32_t size)
000000  b570              PUSH     {r4-r6,lr}
;;;260    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;261    	if(TxFlag == 0)//发送数据完成后才能开始发送
000006  480f              LDR      r0,|L5.68|
000008  7800              LDRB     r0,[r0,#0]  ; TxFlag
00000a  b9c8              CBNZ     r0,|L5.64|
;;;262    	{
;;;263    		DMA_Cmd (DMA_Stream_Tx_UsartFrame,DISABLE);
00000c  2100              MOVS     r1,#0
00000e  480e              LDR      r0,|L5.72|
000010  f7fffffe          BL       DMA_Cmd
;;;264    		while (DMA_GetCmdStatus(DMA_Stream_Tx_UsartFrame) != DISABLE){}
000014  bf00              NOP      
                  |L5.22|
000016  480c              LDR      r0,|L5.72|
000018  f7fffffe          BL       DMA_GetCmdStatus
00001c  2800              CMP      r0,#0
00001e  d1fa              BNE      |L5.22|
;;;265    	//	DMA_Stream_Tx_UsartFrame->M0AR =  (u32)pbuffer;
;;;266    	//	DMA_Stream_Tx_UsartFrame->NDTR = size;
;;;267    		DMA_MemoryTargetConfig(DMA_Stream_Tx_UsartFrame,(u32)pbuffer,DMA_Memory_0);
000020  2200              MOVS     r2,#0
000022  4621              MOV      r1,r4
000024  4808              LDR      r0,|L5.72|
000026  f7fffffe          BL       DMA_MemoryTargetConfig
;;;268    		DMA_SetCurrDataCounter(DMA_Stream_Tx_UsartFrame,size);
00002a  b2a9              UXTH     r1,r5
00002c  4806              LDR      r0,|L5.72|
00002e  f7fffffe          BL       DMA_SetCurrDataCounter
;;;269    	 	DMA_Cmd (DMA_Stream_Tx_UsartFrame,ENABLE);//使能DMA,开始发送
000032  2101              MOVS     r1,#1
000034  4804              LDR      r0,|L5.72|
000036  f7fffffe          BL       DMA_Cmd
;;;270    	 	TxFlag=1; //数据发送中
00003a  2001              MOVS     r0,#1
00003c  4901              LDR      r1,|L5.68|
00003e  7008              STRB     r0,[r1,#0]
                  |L5.64|
;;;271    	}
;;;272    }
000040  bd70              POP      {r4-r6,pc}
;;;273    // __align(8) u8 USART2_TX_BUF[1024]; 	//发送缓冲,最大USART3_MAX_SEND_LEN字节
                          ENDP

000042  0000              DCW      0x0000
                  |L5.68|
                          DCD      TxFlag
                  |L5.72|
                          DCD      0x40026058

                          AREA ||i.UsartFrame_Init||, CODE, READONLY, ALIGN=2

                  UsartFrame_Init PROC
;;;150    
;;;151    void UsartFrame_Init(void)
000000  b500              PUSH     {lr}
;;;152    {
000002  b08f              SUB      sp,sp,#0x3c
;;;153    //	u8 ptrmsg;
;;;154    	/* -------------- Enable Module Clock Source ----------------------------*/
;;;155    	RCC_AHB1PeriphClockCmd(RCC_UsartFrame, ENABLE);
000004  2101              MOVS     r1,#1
000006  486b              LDR      r0,|L6.436|
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;156    	RCC_APB1PeriphClockCmd(RCC_Periph_UsartFrame, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0488              LSLS     r0,r1,#18
000010  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;157    	GPIO_PinAFConfig(GPIO_PORT_Rx_UsartFrame,GPIO_PinSource_Rx_UsartFrame, GPIO_AF_UsartFrame);
000014  2207              MOVS     r2,#7
000016  210b              MOVS     r1,#0xb
000018  4867              LDR      r0,|L6.440|
00001a  f7fffffe          BL       GPIO_PinAFConfig
;;;158    	GPIO_PinAFConfig(GPIO_PORT_Tx_UsartFrame,GPIO_PinSource_Tx_UsartFrame, GPIO_AF_UsartFrame);
00001e  2207              MOVS     r2,#7
000020  210a              MOVS     r1,#0xa
000022  4866              LDR      r0,|L6.444|
000024  f7fffffe          BL       GPIO_PinAFConfig
;;;159    	/* dr16_UsartFrame_mailbox 初始化*/
;;;160    //	ptrmsg = 1; //!< Channel 0
;;;161    
;;;162    //	os_mbx_send (UsartFrame_mailbox, &ptrmsg,200);
;;;163    	/* -------------- Configure GPIO ---------------------------------------*/
;;;164    	{
;;;165    		GPIO_InitTypeDef GPIO_InitStructure;
;;;166    		USART_InitTypeDef USART_InitStructure;
;;;167    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_Rx_UsartFrame ;
000028  f44f6000          MOV      r0,#0x800
00002c  900d              STR      r0,[sp,#0x34]
;;;168    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
00002e  2002              MOVS     r0,#2
000030  f88d0038          STRB     r0,[sp,#0x38]
;;;169    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000034  2000              MOVS     r0,#0
000036  f88d003a          STRB     r0,[sp,#0x3a]
;;;170    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00003a  2002              MOVS     r0,#2
00003c  f88d0039          STRB     r0,[sp,#0x39]
;;;171    		GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
000040  2001              MOVS     r0,#1
000042  f88d003b          STRB     r0,[sp,#0x3b]
;;;172    		GPIO_Init(GPIO_PORT_Rx_UsartFrame, &GPIO_InitStructure);
000046  a90d              ADD      r1,sp,#0x34
000048  485b              LDR      r0,|L6.440|
00004a  f7fffffe          BL       GPIO_Init
;;;173    
;;;174    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_Tx_UsartFrame ;
00004e  f44f6080          MOV      r0,#0x400
000052  900d              STR      r0,[sp,#0x34]
;;;175    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
000054  2002              MOVS     r0,#2
000056  f88d0038          STRB     r0,[sp,#0x38]
;;;176    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
00005a  2000              MOVS     r0,#0
00005c  f88d003a          STRB     r0,[sp,#0x3a]
;;;177    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000060  2002              MOVS     r0,#2
000062  f88d0039          STRB     r0,[sp,#0x39]
;;;178    		GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
000066  2001              MOVS     r0,#1
000068  f88d003b          STRB     r0,[sp,#0x3b]
;;;179    		GPIO_Init(GPIO_PORT_Tx_UsartFrame, &GPIO_InitStructure);
00006c  a90d              ADD      r1,sp,#0x34
00006e  4853              LDR      r0,|L6.444|
000070  f7fffffe          BL       GPIO_Init
;;;180    
;;;181    		USART_DeInit(USART_UsartFrame);
000074  4852              LDR      r0,|L6.448|
000076  f7fffffe          BL       USART_DeInit
;;;182    		USART_InitStructure.USART_BaudRate = 115200;
00007a  f44f30e1          MOV      r0,#0x1c200
00007e  9009              STR      r0,[sp,#0x24]
;;;183    		USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000080  2000              MOVS     r0,#0
000082  f8ad0028          STRH     r0,[sp,#0x28]
;;;184    		USART_InitStructure.USART_StopBits = USART_StopBits_1;
000086  f8ad002a          STRH     r0,[sp,#0x2a]
;;;185    		USART_InitStructure.USART_Parity = USART_Parity_No;
00008a  f8ad002c          STRH     r0,[sp,#0x2c]
;;;186    		USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00008e  200c              MOVS     r0,#0xc
000090  f8ad002e          STRH     r0,[sp,#0x2e]
;;;187    		USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000094  2000              MOVS     r0,#0
000096  f8ad0030          STRH     r0,[sp,#0x30]
;;;188    		USART_Init(USART_UsartFrame,&USART_InitStructure);
00009a  a909              ADD      r1,sp,#0x24
00009c  4848              LDR      r0,|L6.448|
00009e  f7fffffe          BL       USART_Init
;;;189    		USART_Cmd(USART_UsartFrame,ENABLE);
0000a2  2101              MOVS     r1,#1
0000a4  4846              LDR      r0,|L6.448|
0000a6  f7fffffe          BL       USART_Cmd
;;;190    		USART_DMACmd(USART_UsartFrame,USART_DMAReq_Rx,ENABLE);
0000aa  2201              MOVS     r2,#1
0000ac  2140              MOVS     r1,#0x40
0000ae  4844              LDR      r0,|L6.448|
0000b0  f7fffffe          BL       USART_DMACmd
;;;191    	}
;;;192    	/* -------------- Configure NVIC ---------------------------------------*/
;;;193    	{
;;;194    		NVIC_InitTypeDef NVIC_InitStructure;
;;;195    		NVIC_InitStructure.NVIC_IRQChannel = DMA_IRQn_Rx_UsartFrame;
0000b4  2027              MOVS     r0,#0x27
0000b6  f88d0038          STRB     r0,[sp,#0x38]
;;;196    		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
0000ba  2001              MOVS     r0,#1
0000bc  f88d0039          STRB     r0,[sp,#0x39]
;;;197    		NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
0000c0  f88d003a          STRB     r0,[sp,#0x3a]
;;;198    		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
0000c4  f88d003b          STRB     r0,[sp,#0x3b]
;;;199    		NVIC_Init(&NVIC_InitStructure);
0000c8  a80e              ADD      r0,sp,#0x38
0000ca  f7fffffe          BL       NVIC_Init
;;;200    
;;;201    		NVIC_InitStructure.NVIC_IRQChannel = DMA_IRQn_Tx_UsartFrame;
0000ce  200e              MOVS     r0,#0xe
0000d0  f88d0038          STRB     r0,[sp,#0x38]
;;;202    		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
0000d4  2002              MOVS     r0,#2
0000d6  f88d0039          STRB     r0,[sp,#0x39]
;;;203    		NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;
0000da  f88d003a          STRB     r0,[sp,#0x3a]
;;;204    		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
0000de  2001              MOVS     r0,#1
0000e0  f88d003b          STRB     r0,[sp,#0x3b]
;;;205    		NVIC_Init(&NVIC_InitStructure);
0000e4  a80e              ADD      r0,sp,#0x38
0000e6  f7fffffe          BL       NVIC_Init
;;;206    	}
;;;207    	/* -------------- Configure DMA Rx -----------------------------------------*/
;;;208    	{
;;;209    		DMA_InitTypeDef DMA_InitStructure;
;;;210    		DMA_DeInit(DMA_Stream_Rx_UsartFrame);
0000ea  4836              LDR      r0,|L6.452|
0000ec  f7fffffe          BL       DMA_DeInit
;;;211    		DMA_InitStructure.DMA_Channel = DMA_Channel_Rx_UsartFrame;
0000f0  f04f6000          MOV      r0,#0x8000000
0000f4  9000              STR      r0,[sp,#0]
;;;212    		DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&(USART_UsartFrame->DR);
0000f6  4832              LDR      r0,|L6.448|
0000f8  1d00              ADDS     r0,r0,#4
0000fa  9001              STR      r0,[sp,#4]
;;;213    		DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)frame_rx_buffer;
0000fc  4832              LDR      r0,|L6.456|
0000fe  9002              STR      r0,[sp,#8]
;;;214    		DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;
000100  2000              MOVS     r0,#0
000102  9003              STR      r0,[sp,#0xc]
;;;215    		DMA_InitStructure.DMA_BufferSize = 1024;
000104  f44f6080          MOV      r0,#0x400
000108  9004              STR      r0,[sp,#0x10]
;;;216    		DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
00010a  2000              MOVS     r0,#0
00010c  9005              STR      r0,[sp,#0x14]
;;;217    		DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
00010e  f44f6080          MOV      r0,#0x400
000112  9006              STR      r0,[sp,#0x18]
;;;218    		DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
000114  2000              MOVS     r0,#0
000116  9007              STR      r0,[sp,#0x1c]
;;;219    		DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
000118  9008              STR      r0,[sp,#0x20]
;;;220    		DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
00011a  f44f7080          MOV      r0,#0x100
00011e  9009              STR      r0,[sp,#0x24]
;;;221    		DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;
000120  f44f3040          MOV      r0,#0x30000
000124  900a              STR      r0,[sp,#0x28]
;;;222    		DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;
000126  2000              MOVS     r0,#0
000128  900b              STR      r0,[sp,#0x2c]
;;;223    		DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_1QuarterFull;
00012a  900c              STR      r0,[sp,#0x30]
;;;224    		DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
00012c  900d              STR      r0,[sp,#0x34]
;;;225    		DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
00012e  900e              STR      r0,[sp,#0x38]
;;;226    		DMA_Init(DMA_Stream_Rx_UsartFrame,&DMA_InitStructure);
000130  4669              MOV      r1,sp
000132  4824              LDR      r0,|L6.452|
000134  f7fffffe          BL       DMA_Init
;;;227    		// DMA_ITConfig(DMA_Stream_UsartFrame,DMA_IT_TC,ENABLE);
;;;228    		DMA_Cmd(DMA_Stream_Rx_UsartFrame,DISABLE);
000138  2100              MOVS     r1,#0
00013a  4822              LDR      r0,|L6.452|
00013c  f7fffffe          BL       DMA_Cmd
;;;229    		USART_ITConfig(USART_UsartFrame, USART_IT_IDLE, ENABLE);//空闲中断,用于不定长接收
000140  2201              MOVS     r2,#1
000142  f2404124          MOV      r1,#0x424
000146  481e              LDR      r0,|L6.448|
000148  f7fffffe          BL       USART_ITConfig
;;;230    	}
;;;231    
;;;232    	/* -------------- Configure DMA Tx -----------------------------------------*/
;;;233    	{
;;;234    		DMA_InitTypeDef DMA_InitStructure;
;;;235    		DMA_DeInit(DMA_Stream_Tx_UsartFrame);
00014c  481d              LDR      r0,|L6.452|
00014e  3030              ADDS     r0,r0,#0x30
000150  f7fffffe          BL       DMA_DeInit
;;;236    		DMA_InitStructure.DMA_Channel = DMA_Channel_Tx_UsartFrame;
000154  f04f6000          MOV      r0,#0x8000000
000158  9000              STR      r0,[sp,#0]
;;;237    		DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&(USART_UsartFrame->DR);
00015a  4819              LDR      r0,|L6.448|
00015c  1d00              ADDS     r0,r0,#4
00015e  9001              STR      r0,[sp,#4]
;;;238    //		DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)table;
;;;239    		DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;
000160  2040              MOVS     r0,#0x40
000162  9003              STR      r0,[sp,#0xc]
;;;240    //		DMA_InitStructure.DMA_BufferSize = 30;
;;;241    		DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
000164  2000              MOVS     r0,#0
000166  9005              STR      r0,[sp,#0x14]
;;;242    		DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
000168  f44f6080          MOV      r0,#0x400
00016c  9006              STR      r0,[sp,#0x18]
;;;243    		DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
00016e  2000              MOVS     r0,#0
000170  9007              STR      r0,[sp,#0x1c]
;;;244    		DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
000172  9008              STR      r0,[sp,#0x20]
;;;245    		DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
000174  9009              STR      r0,[sp,#0x24]
;;;246    		DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
000176  f44f3080          MOV      r0,#0x10000
00017a  900a              STR      r0,[sp,#0x28]
;;;247    		DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;
00017c  2000              MOVS     r0,#0
00017e  900b              STR      r0,[sp,#0x2c]
;;;248    		DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_1QuarterFull;
000180  900c              STR      r0,[sp,#0x30]
;;;249    		DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
000182  900d              STR      r0,[sp,#0x34]
;;;250    		DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
000184  900e              STR      r0,[sp,#0x38]
;;;251    		DMA_Init(DMA_Stream_Tx_UsartFrame,&DMA_InitStructure);
000186  4669              MOV      r1,sp
000188  480e              LDR      r0,|L6.452|
00018a  3030              ADDS     r0,r0,#0x30
00018c  f7fffffe          BL       DMA_Init
;;;252    		USART_DMACmd(USART_UsartFrame,USART_DMAReq_Tx,ENABLE);
000190  2201              MOVS     r2,#1
000192  2180              MOVS     r1,#0x80
000194  480a              LDR      r0,|L6.448|
000196  f7fffffe          BL       USART_DMACmd
;;;253    		DMA_ITConfig(DMA_Stream_Tx_UsartFrame,DMA_IT_TC,ENABLE);
00019a  2201              MOVS     r2,#1
00019c  2110              MOVS     r1,#0x10
00019e  4809              LDR      r0,|L6.452|
0001a0  3030              ADDS     r0,r0,#0x30
0001a2  f7fffffe          BL       DMA_ITConfig
;;;254    		DMA_Cmd(DMA_Stream_Tx_UsartFrame,DISABLE);//初始化时要失能。。。不能！！！
0001a6  2100              MOVS     r1,#0
0001a8  4806              LDR      r0,|L6.452|
0001aa  3030              ADDS     r0,r0,#0x30
0001ac  f7fffffe          BL       DMA_Cmd
;;;255    	}
;;;256    }
0001b0  b00f              ADD      sp,sp,#0x3c
0001b2  bd00              POP      {pc}
;;;257    
                          ENDP

                  |L6.436|
                          DCD      0x00200006
                  |L6.440|
                          DCD      0x40020800
                  |L6.444|
                          DCD      0x40020400
                  |L6.448|
                          DCD      0x40004800
                  |L6.452|
                          DCD      0x40026028
                  |L6.456|
                          DCD      frame_rx_buffer

                          AREA ||i.UsartFrame_mailbox_init||, CODE, READONLY, ALIGN=2

                  UsartFrame_mailbox_init PROC
;;;289    
;;;290    void UsartFrame_mailbox_init(void)
000000  f2410110          MOV      r1,#0x1010
;;;291    {
;;;292    	os_mbx_init (&UsartFrame_mailbox, sizeof(UsartFrame_mailbox));//UsartFrame邮箱初始化
000004  4802              LDR      r0,|L7.16|
000006  f8dfc00c          LDR      r12,|L7.20|
00000a  df00              SVC      #0x0
;;;293    }
00000c  4770              BX       lr
;;;294    
                          ENDP

00000e  0000              DCW      0x0000
                  |L7.16|
                          DCD      UsartFrame_mailbox
                  |L7.20|
                          DCD      rt_mbx_init

                          AREA ||i.UsartFrame_receive||, CODE, READONLY, ALIGN=2

                  UsartFrame_receive PROC
;;;294    
;;;295    uint8_t UsartFrame_receive(FRAME **ptrmsg, uint16_t timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;296    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;297    	return os_mbx_wait(UsartFrame_mailbox, (void **)ptrmsg,200);
000006  22c8              MOVS     r2,#0xc8
000008  4621              MOV      r1,r4
00000a  4803              LDR      r0,|L8.24|
00000c  f8dfc00c          LDR      r12,|L8.28|
000010  df00              SVC      #0x0
000012  b2c0              UXTB     r0,r0
;;;298    }
000014  bd70              POP      {r4-r6,pc}
;;;299    
                          ENDP

000016  0000              DCW      0x0000
                  |L8.24|
                          DCD      UsartFrame_mailbox
                  |L8.28|
                          DCD      rt_mbx_wait

                          AREA ||i.UsasrFrameInit||, CODE, READONLY, ALIGN=1

                  UsasrFrameInit PROC
;;;18      */
;;;19     void UsasrFrameInit(void)
000000  b510              PUSH     {r4,lr}
;;;20     {
;;;21     	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_CRC, ENABLE);
000002  2101              MOVS     r1,#1
000004  0308              LSLS     r0,r1,#12
000006  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;22     }
00000a  bd10              POP      {r4,pc}
;;;23     
                          ENDP


                          AREA ||i.UsasrFrameRec||, CODE, READONLY, ALIGN=1

                  UsasrFrameRec PROC
;;;132     */
;;;133    unsigned char UsasrFrameRec(unsigned char * str)
000000  b510              PUSH     {r4,lr}
;;;134    {
000002  4604              MOV      r4,r0
;;;135    	senddemo();
000004  f7fffffe          BL       _Z8senddemov ; senddemo()
;;;136    	return recdemo(str);
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       _Z7recdemoPh ; recdemo(unsigned char*)
;;;137    //	return 0;
;;;138    }
00000e  bd10              POP      {r4,pc}
;;;139    
                          ENDP


                          AREA ||i.UsasrFrameSend||, CODE, READONLY, ALIGN=1

                  UsasrFrameSend PROC
;;;76      */
;;;77     void UsasrFrameSend(FRAME * pBuffer)
000000  b570              PUSH     {r4-r6,lr}
;;;78     {
000002  4604              MOV      r4,r0
;;;79     	unsigned char i,temp;
;;;80     	pBuffer->SOF = 0xAA;
000004  20aa              MOVS     r0,#0xaa
000006  7020              STRB     r0,[r4,#0]
;;;81     	temp = (pBuffer->LEN)%4;
000008  8860              LDRH     r0,[r4,#2]
00000a  17c1              ASRS     r1,r0,#31
00000c  eb007191          ADD      r1,r0,r1,LSR #30
000010  1089              ASRS     r1,r1,#2
000012  eba00181          SUB      r1,r0,r1,LSL #2
000016  b2ce              UXTB     r6,r1
;;;82     	if(temp)
000018  b11e              CBZ      r6,|L11.34|
;;;83     		pBuffer->MOD = 4 - temp;
00001a  f1c60004          RSB      r0,r6,#4
00001e  7060              STRB     r0,[r4,#1]
000020  e001              B        |L11.38|
                  |L11.34|
;;;84     	else
;;;85     		pBuffer->MOD = 0;
000022  2000              MOVS     r0,#0
000024  7060              STRB     r0,[r4,#1]
                  |L11.38|
;;;86     	for (i = 0; i < pBuffer->MOD; ++i)
000026  2500              MOVS     r5,#0
000028  e007              B        |L11.58|
                  |L11.42|
;;;87     	{
;;;88     		pBuffer->DATA[pBuffer->LEN + i] = 0xff;
00002a  21ff              MOVS     r1,#0xff
00002c  8860              LDRH     r0,[r4,#2]
00002e  1942              ADDS     r2,r0,r5
000030  f1040008          ADD      r0,r4,#8
000034  5481              STRB     r1,[r0,r2]
000036  1c68              ADDS     r0,r5,#1              ;86
000038  b2c5              UXTB     r5,r0                 ;86
                  |L11.58|
00003a  7860              LDRB     r0,[r4,#1]            ;86
00003c  42a8              CMP      r0,r5                 ;86
00003e  dcf4              BGT      |L11.42|
;;;89     	}
;;;90     	pBuffer->CRC32 = CRC_STM32Hard(pBuffer->DATA,pBuffer->LEN + pBuffer->MOD);
000040  8860              LDRH     r0,[r4,#2]
000042  7862              LDRB     r2,[r4,#1]
000044  1881              ADDS     r1,r0,r2
000046  f1040008          ADD      r0,r4,#8
00004a  f7fffffe          BL       CRC_STM32Hard
00004e  6060              STR      r0,[r4,#4]
;;;91     	USART1_DMA_Send((uint8_t*)pBuffer,pBuffer->LEN + pBuffer->MOD + 8);
000050  8860              LDRH     r0,[r4,#2]
000052  7862              LDRB     r2,[r4,#1]
000054  4410              ADD      r0,r0,r2
000056  f1000108          ADD      r1,r0,#8
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       USART1_DMA_Send
;;;92     }
000060  bd70              POP      {r4-r6,pc}
;;;93     
                          ENDP


                          AREA ||i._Z7recdemoPh||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  _Z7recdemoPh PROC ; recdemo(unsigned char*)
;;;116     */
;;;117    unsigned char recdemo(unsigned char * str)
000000  b570              PUSH     {r4-r6,lr}
;;;118    {
000002  4604              MOV      r4,r0
;;;119    	if(CRC_STM32Check( ((FRAME *)str) ->DATA , ((FRAME *)str)->LEN + ((FRAME *)str)->MOD,((FRAME *)str)->CRC32)!= 0)
000004  8860              LDRH     r0,[r4,#2]
000006  7863              LDRB     r3,[r4,#1]
000008  18c1              ADDS     r1,r0,r3
00000a  f1040008          ADD      r0,r4,#8
00000e  6862              LDR      r2,[r4,#4]
000010  f7fffffe          BL       CRC_STM32Check
000014  b108              CBZ      r0,|L12.26|
;;;120    	{
;;;121    		return 1;
000016  2001              MOVS     r0,#1
                  |L12.24|
;;;122    	}
;;;123    	printf("value = %08X\r\n",CRC_STM32Hard (((FRAME *)str) ->DATA, ((FRAME *)str)->LEN + ((FRAME *)str)->MOD));
;;;124    	return 0;
;;;125    }
000018  bd70              POP      {r4-r6,pc}
                  |L12.26|
00001a  8860              LDRH     r0,[r4,#2]            ;123
00001c  7862              LDRB     r2,[r4,#1]            ;123
00001e  1881              ADDS     r1,r0,r2              ;123
000020  f1040008          ADD      r0,r4,#8              ;123
000024  f7fffffe          BL       CRC_STM32Hard
000028  4605              MOV      r5,r0                 ;123
00002a  4629              MOV      r1,r5                 ;123
00002c  a002              ADR      r0,|L12.56|
00002e  f7fffffe          BL       __2printf
000032  2000              MOVS     r0,#0                 ;124
000034  e7f0              B        |L12.24|
;;;126    
                          ENDP

000036  0000              DCW      0x0000
                  |L12.56|
000038  76616c75          DCB      "value = %08X\r\n",0
00003c  65203d20
000040  25303858
000044  0d0a00  
000047  00                DCB      0

                          AREA ||i._Z8senddemov||, CODE, READONLY, ALIGN=1

                  _Z8senddemov PROC ; senddemo()
;;;96      */
;;;97     void senddemo(void)
000000  b500              PUSH     {lr}
;;;98     {
000002  b087              SUB      sp,sp,#0x1c
;;;99     	FRAME Ftemp;
;;;100    	Ftemp.LEN = 0x07;
000004  2007              MOVS     r0,#7
000006  f8ad0006          STRH     r0,[sp,#6]
;;;101    	Ftemp.DATA[0] = 0x00;
00000a  2000              MOVS     r0,#0
00000c  f88d000c          STRB     r0,[sp,#0xc]
;;;102    	Ftemp.DATA[1] = 0x11;
000010  2111              MOVS     r1,#0x11
000012  f88d100d          STRB     r1,[sp,#0xd]
;;;103    	Ftemp.DATA[2] = 0x22;
000016  2122              MOVS     r1,#0x22
000018  f88d100e          STRB     r1,[sp,#0xe]
;;;104    	Ftemp.DATA[3] = 0x33;
00001c  2133              MOVS     r1,#0x33
00001e  f88d100f          STRB     r1,[sp,#0xf]
;;;105    	Ftemp.DATA[4] = 0x44;
000022  2144              MOVS     r1,#0x44
000024  f88d1010          STRB     r1,[sp,#0x10]
;;;106    	Ftemp.DATA[5] = 0x55;
000028  2155              MOVS     r1,#0x55
00002a  f88d1011          STRB     r1,[sp,#0x11]
;;;107    	Ftemp.DATA[6] = 0x66;
00002e  2166              MOVS     r1,#0x66
000030  f88d1012          STRB     r1,[sp,#0x12]
;;;108    	Ftemp.DATA[7] = 0x77;
000034  2177              MOVS     r1,#0x77
000036  f88d1013          STRB     r1,[sp,#0x13]
;;;109    	UsasrFrameSend(&Ftemp);
00003a  a801              ADD      r0,sp,#4
00003c  f7fffffe          BL       UsasrFrameSend
;;;110    }
000040  b007              ADD      sp,sp,#0x1c
000042  bd00              POP      {pc}
;;;111    
                          ENDP


                          AREA ||i.u3_printf||, CODE, READONLY, ALIGN=2

                  u3_printf PROC
;;;273    // __align(8) u8 USART2_TX_BUF[1024]; 	//发送缓冲,最大USART3_MAX_SEND_LEN字节
;;;274     void u3_printf(char* fmt,...)
000000  b40f              PUSH     {r0-r3}
;;;275     {
000002  b538              PUSH     {r3-r5,lr}
;;;276     	va_list ap;
;;;277     	va_start(ap,fmt);
000004  a805              ADD      r0,sp,#0x14
000006  9000              STR      r0,[sp,#0]
;;;278     	vsprintf((char*)USART3_TX_BUF,fmt,ap);
000008  4808              LDR      r0,|L14.44|
00000a  9a00              LDR      r2,[sp,#0]
00000c  9904              LDR      r1,[sp,#0x10]
00000e  f7fffffe          BL       __c89vsprintf
;;;279     	va_end(ap);
000012  2000              MOVS     r0,#0
000014  9000              STR      r0,[sp,#0]
;;;280     	USARTFrame_DMA_Send(USART3_TX_BUF, strlen((const char*)USART3_TX_BUF));
000016  4805              LDR      r0,|L14.44|
000018  f7fffffe          BL       strlen
00001c  4604              MOV      r4,r0
00001e  4621              MOV      r1,r4
000020  4802              LDR      r0,|L14.44|
000022  f7fffffe          BL       USARTFrame_DMA_Send
;;;281     //	for(j=0;j<i;j++)//循环发送数据
;;;282     //	{
;;;283     //	  while(USART_GetFlagStatus(USART1,USART_FLAG_TC)==RESET);  //等待上次传输完成
;;;284     //		USART_SendData(USART1,(uint8_t)USART1_TX_BUF[j]); 	 //发送数据到串口3
;;;285     //	}
;;;286     }
000026  bc38              POP      {r3-r5}
000028  f85dfb14          LDR      pc,[sp],#0x14
;;;287    
                          ENDP

                  |L14.44|
                          DCD      USART3_TX_BUF

                          AREA ||.ARM.exidx||, LINKORDER=||i.UsasrFrameInit||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i.UsasrFrameInit||
                          DCD      0x00000001

                          AREA ||area_number.16||, LINKORDER=||i.CRC_STM32Hard||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.16||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.CRC_STM32Hard||
                          DCD      0x00000001

                          AREA ||area_number.17||, LINKORDER=||i.CRC_STM32Check||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.17||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.CRC_STM32Check||
                          DCD      0x00000001

                          AREA ||area_number.18||, LINKORDER=||i.UsasrFrameSend||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.18||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.UsasrFrameSend||
                          DCD      0x00000001

                          AREA ||area_number.19||, LINKORDER=||i._Z8senddemov||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.19||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z8senddemov||
                          DCD      0x00000001

                          AREA ||area_number.20||, LINKORDER=||i._Z7recdemoPh||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.20||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z7recdemoPh||
                          DCD      0x00000001

                          AREA ||area_number.21||, LINKORDER=||i.UsasrFrameRec||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.21||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.UsasrFrameRec||
                          DCD      0x00000001

                          AREA ||area_number.22||, LINKORDER=||i.UsartFrame_Init||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.22||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.UsartFrame_Init||
                          DCD      0x00000001

                          AREA ||area_number.23||, LINKORDER=||i.USARTFrame_DMA_Send||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.23||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.USARTFrame_DMA_Send||
                          DCD      0x00000001

                          AREA ||area_number.24||, LINKORDER=||i.u3_printf||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.24||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.u3_printf||
                          DCD      0x00000001

                          AREA ||area_number.25||, LINKORDER=||i.UsartFrame_mailbox_init||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.25||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.UsartFrame_mailbox_init||
                          DCD      0x00000001

                          AREA ||area_number.26||, LINKORDER=||i.UsartFrame_receive||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.26||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.UsartFrame_receive||
                          DCD      0x00000001

                          AREA ||area_number.27||, LINKORDER=||i.USART3_IRQHandler||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.27||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.USART3_IRQHandler||
                          DCD      0x00000001

                          AREA ||area_number.28||, LINKORDER=||i.DMA1_Stream3_IRQHandler||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.28||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.DMA1_Stream3_IRQHandler||
                          DCD      0x00000001

                          AREA ||.bss||, DATA, NOINIT, ALIGN=3

                  UsartFrame_mailbox
                          %        4112
                  USART3_TX_BUF
                          %        1024
                  frame_rx_buffer
                          %        26
                  CVAllValue
                          %        12

                          AREA ||.data||, DATA, ALIGN=2

                  TxFlag
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  CVValue
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\MySrc\\UsartFrame_STM32.cpp"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_UsartFrame_STM32_cpp_9f205693___Z7__REV16j|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___20_UsartFrame_STM32_cpp_9f205693___Z7__REV16j| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_UsartFrame_STM32_cpp_9f205693___Z7__REVSHi|
#line 144
|__asm___20_UsartFrame_STM32_cpp_9f205693___Z7__REVSHi| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_UsartFrame_STM32_cpp_9f205693___Z5__RRXj|
#line 300
|__asm___20_UsartFrame_STM32_cpp_9f205693___Z5__RRXj| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
