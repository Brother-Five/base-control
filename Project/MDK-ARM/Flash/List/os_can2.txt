; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--cpp --list --split_sections --debug -c --asm --interleave -o.\flash\obj\os_can2.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\os_can2.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -I..\..\RTX\inc -I..\..\RTX\portable -I..\..\MySrc -I..\..\Libraries -I..\..\MySrc\ostask -I..\..\MySrc\MPU6050 -D__MICROLIB -D__UVISION_VERSION=514 -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DARM_MATH_CM4 -DSTM32F40_41xxx --omf_browse=.\flash\obj\os_can2.crf ..\..\MySrc\ostask\os_can2.cpp]
                          THUMB

                          AREA ||i.GetMotorEncoder||, CODE, READONLY, ALIGN=2

                  GetMotorEncoder PROC
;;;309    
;;;310    MotorEncoderStruct GetMotorEncoder(void)
000000  b508              PUSH     {r3,lr}
;;;311    {
;;;312    	return	MotorEncoder;
000002  4802              LDR      r0,|L1.12|
000004  6800              LDR      r0,[r0,#0]  ; MotorEncoder
000006  9000              STR      r0,[sp,#0]
;;;313    }
000008  bd08              POP      {r3,pc}
;;;314    
                          ENDP

00000a  0000              DCW      0x0000
                  |L1.12|
                          DCD      MotorEncoder

                          AREA ||i.Get_Speed6623||, CODE, READONLY, ALIGN=2

                  Get_Speed6623 PROC
;;;56     
;;;57     EncoderStuct Get_Speed6623(u8 id)
000000  4a03              LDR      r2,|L2.16|
;;;58     {
;;;59     	return Speed6623[id];
000002  eb0203c1          ADD      r3,r2,r1,LSL #3
000006  cb0c              LDM      r3,{r2,r3}
000008  e9c02300          STRD     r2,r3,[r0,#0]
;;;60     }
00000c  4770              BX       lr
;;;61     
                          ENDP

00000e  0000              DCW      0x0000
                  |L2.16|
                          DCD      Speed6623

                          AREA ||i.New_Board||, CODE, READONLY, ALIGN=2

                  New_Board PROC
;;;315    
;;;316    void New_Board(CanRxMsg *msg_rece)
000000  7ac1              LDRB     r1,[r0,#0xb]
;;;317    {
;;;318    //	 u1_printf("123");
;;;319       Infrared_Message=msg_rece->Data[0];
000002  4a14              LDR      r2,|L3.84|
000004  7011              STRB     r1,[r2,#0]
;;;320    	 if(Infrared_Message==0x01){ADDBULLET_BUTTON=!ADDBULLET_BUTTON;}
000006  4611              MOV      r1,r2
000008  7809              LDRB     r1,[r1,#0]  ; Infrared_Message
00000a  2901              CMP      r1,#1
00000c  d107              BNE      |L3.30|
00000e  4912              LDR      r1,|L3.88|
000010  7809              LDRB     r1,[r1,#0]  ; ADDBULLET_BUTTON
000012  b909              CBNZ     r1,|L3.24|
000014  2101              MOVS     r1,#1
000016  e000              B        |L3.26|
                  |L3.24|
000018  2100              MOVS     r1,#0
                  |L3.26|
00001a  4a0f              LDR      r2,|L3.88|
00001c  7011              STRB     r1,[r2,#0]
                  |L3.30|
;;;321    	 if(Infrared_Message==0x02){Infrared_Cnt=!Infrared_Cnt;}
00001e  490d              LDR      r1,|L3.84|
000020  7809              LDRB     r1,[r1,#0]  ; Infrared_Message
000022  2902              CMP      r1,#2
000024  d107              BNE      |L3.54|
000026  490d              LDR      r1,|L3.92|
000028  7809              LDRB     r1,[r1,#0]  ; Infrared_Cnt
00002a  b909              CBNZ     r1,|L3.48|
00002c  2101              MOVS     r1,#1
00002e  e000              B        |L3.50|
                  |L3.48|
000030  2100              MOVS     r1,#0
                  |L3.50|
000032  4a0a              LDR      r2,|L3.92|
000034  7011              STRB     r1,[r2,#0]
                  |L3.54|
;;;322    	 if(Infrared_Message==0x03){runstart_flag=0;} 
000036  4907              LDR      r1,|L3.84|
000038  7809              LDRB     r1,[r1,#0]  ; Infrared_Message
00003a  2903              CMP      r1,#3
00003c  d102              BNE      |L3.68|
00003e  2100              MOVS     r1,#0
000040  4a07              LDR      r2,|L3.96|
000042  7011              STRB     r1,[r2,#0]
                  |L3.68|
;;;323       if(Infrared_Message==0x04){runstart_flag=1;}
000044  4903              LDR      r1,|L3.84|
000046  7809              LDRB     r1,[r1,#0]  ; Infrared_Message
000048  2904              CMP      r1,#4
00004a  d102              BNE      |L3.82|
00004c  2101              MOVS     r1,#1
00004e  4a04              LDR      r2,|L3.96|
000050  7011              STRB     r1,[r2,#0]
                  |L3.82|
;;;324    }
000052  4770              BX       lr
                          ENDP

                  |L3.84|
                          DCD      Infrared_Message
                  |L3.88|
                          DCD      ADDBULLET_BUTTON
                  |L3.92|
                          DCD      Infrared_Cnt
                  |L3.96|
                          DCD      runstart_flag

                          AREA ||i.PitchMotor||, CODE, READONLY, ALIGN=2

                  PitchMotor PROC
;;;65      */
;;;66     void PitchMotor(CanRxMsg *msg_rece)
000000  b510              PUSH     {r4,lr}
;;;67     {
000002  4604              MOV      r4,r0
;;;68     	// short TempPitch[4];
;;;69     	static u16 flagPitch = 0, initcountPitch = 0;
;;;70     	static short filter_bufPitch[Num];
;;;71     	static unsigned char iPitch=0;
;;;72     
;;;73     //=====================================================================================
;;;74     	static short last_angle,this_angle;
;;;75     	static int turn_cnt,first_flag = 1;
;;;76     	last_angle = this_angle;
000004  483a              LDR      r0,|L4.240|
000006  f9b00000          LDRSH    r0,[r0,#0]  ; this_angle
00000a  493a              LDR      r1,|L4.244|
00000c  8008              STRH     r0,[r1,#0]
;;;77     	this_angle = (u16)msg_rece->Data[0] <<8 | (u16)msg_rece->Data[1];
00000e  7b20              LDRB     r0,[r4,#0xc]
000010  7ae1              LDRB     r1,[r4,#0xb]
000012  ea402001          ORR      r0,r0,r1,LSL #8
000016  b200              SXTH     r0,r0
000018  4935              LDR      r1,|L4.240|
00001a  8008              STRH     r0,[r1,#0]
;;;78     
;;;79     	if(first_flag)//第一次检测处理
00001c  4836              LDR      r0,|L4.248|
00001e  6800              LDR      r0,[r0,#0]  ; first_flag
000020  b138              CBZ      r0,|L4.50|
;;;80     	{
;;;81     		last_angle = this_angle;
000022  4608              MOV      r0,r1
000024  f9b00000          LDRSH    r0,[r0,#0]  ; this_angle
000028  4932              LDR      r1,|L4.244|
00002a  8008              STRH     r0,[r1,#0]
;;;82     		first_flag = 0;
00002c  2000              MOVS     r0,#0
00002e  4932              LDR      r1,|L4.248|
000030  6008              STR      r0,[r1,#0]  ; first_flag
                  |L4.50|
;;;83     	}
;;;84     	if(last_angle < 2048 && this_angle > 6144 )
000032  4830              LDR      r0,|L4.244|
000034  f9b00000          LDRSH    r0,[r0,#0]  ; last_angle
000038  f5b06f00          CMP      r0,#0x800
00003c  da0b              BGE      |L4.86|
00003e  482c              LDR      r0,|L4.240|
000040  f9b00000          LDRSH    r0,[r0,#0]  ; this_angle
000044  f5b05fc0          CMP      r0,#0x1800
000048  dd05              BLE      |L4.86|
;;;85     	{
;;;86     		turn_cnt--;
00004a  482c              LDR      r0,|L4.252|
00004c  6800              LDR      r0,[r0,#0]  ; turn_cnt
00004e  1e40              SUBS     r0,r0,#1
000050  492a              LDR      r1,|L4.252|
000052  6008              STR      r0,[r1,#0]  ; turn_cnt
000054  e010              B        |L4.120|
                  |L4.86|
;;;87     	}
;;;88     	else if(this_angle < 2048 && last_angle > 6144)
000056  4826              LDR      r0,|L4.240|
000058  f9b00000          LDRSH    r0,[r0,#0]  ; this_angle
00005c  f5b06f00          CMP      r0,#0x800
000060  da0a              BGE      |L4.120|
000062  4824              LDR      r0,|L4.244|
000064  f9b00000          LDRSH    r0,[r0,#0]  ; last_angle
000068  f5b05fc0          CMP      r0,#0x1800
00006c  dd04              BLE      |L4.120|
;;;89     	{
;;;90     		turn_cnt++;
00006e  4823              LDR      r0,|L4.252|
000070  6800              LDR      r0,[r0,#0]  ; turn_cnt
000072  1c40              ADDS     r0,r0,#1
000074  4921              LDR      r1,|L4.252|
000076  6008              STR      r0,[r1,#0]  ; turn_cnt
                  |L4.120|
;;;91     	}
;;;92     	MotorEncoder.PitchEncoder = this_angle + turn_cnt*8192;
000078  4820              LDR      r0,|L4.252|
00007a  7800              LDRB     r0,[r0,#0]  ; turn_cnt
00007c  491c              LDR      r1,|L4.240|
00007e  8809              LDRH     r1,[r1,#0]  ; this_angle
000080  eb013040          ADD      r0,r1,r0,LSL #13
000084  b200              SXTH     r0,r0
000086  491e              LDR      r1,|L4.256|
000088  8008              STRH     r0,[r1,#0]
;;;93     //=====================================================================================
;;;94     
;;;95     
;;;96     	MotorEncoder.PitchEncoder = Middle_filter(filter_bufPitch,&iPitch,Num,MotorEncoder.PitchEncoder);//中值滤波
00008a  4608              MOV      r0,r1
00008c  f9b03000          LDRSH    r3,[r0,#0]  ; MotorEncoder
000090  2205              MOVS     r2,#5
000092  491c              LDR      r1,|L4.260|
000094  481c              LDR      r0,|L4.264|
000096  f7fffffe          BL       _Z13Middle_filterPsPhhs ; Middle_filter(short*, unsigned char*, unsigned char, short)
00009a  4919              LDR      r1,|L4.256|
00009c  8008              STRH     r0,[r1,#0]
;;;97     //	Set_Speed6623(MotorEncoder.PitchEncoder,PITCHSPEEDCODER);
;;;98     //	u1_printf("%d\r\n",MotorEncoder.PitchEncoder);//调试用
;;;99     	if(flagPitch)
00009e  481b              LDR      r0,|L4.268|
0000a0  8800              LDRH     r0,[r0,#0]  ; flagPitch
0000a2  b160              CBZ      r0,|L4.190|
;;;100    	{
;;;101    		PitchPID.SetCurrent((float)MotorEncoder.PitchEncoder);//Pitch轴码盘输出给PID，进行控制
0000a4  4608              MOV      r0,r1
0000a6  f9b00000          LDRSH    r0,[r0,#0]  ; MotorEncoder
0000aa  ee000a90          VMOV     s1,r0
0000ae  eef80ae0          VCVT.F32.S32 s1,s1
0000b2  eeb00a60          VMOV.F32 s0,s1
0000b6  4816              LDR      r0,|L4.272|
0000b8  f7fffffe          BL       _ZN7PIDBase10SetCurrentEf ; PIDBase::SetCurrent(float)
0000bc  e017              B        |L4.238|
                  |L4.190|
;;;102    	}
;;;103    	else
;;;104    	{
;;;105    		initcountPitch ++;
0000be  4815              LDR      r0,|L4.276|
0000c0  8800              LDRH     r0,[r0,#0]  ; initcountPitch
0000c2  1c40              ADDS     r0,r0,#1
0000c4  4913              LDR      r1,|L4.276|
0000c6  8008              STRH     r0,[r1,#0]
;;;106    		PitchPID.SetCurrent((float)MotorEncoder.PitchEncoder);//Pitch轴码盘输出给PID,避免阶跃造成大幅度震动
0000c8  480d              LDR      r0,|L4.256|
0000ca  f9b00000          LDRSH    r0,[r0,#0]  ; MotorEncoder
0000ce  ee000a90          VMOV     s1,r0
0000d2  eef80ae0          VCVT.F32.S32 s1,s1
0000d6  eeb00a60          VMOV.F32 s0,s1
0000da  480d              LDR      r0,|L4.272|
0000dc  f7fffffe          BL       _ZN7PIDBase10SetCurrentEf ; PIDBase::SetCurrent(float)
;;;107    		if(initcountPitch == 50)//Pitch和Yaw轴50，底盘800代表着每个PID的启动顺序
0000e0  480c              LDR      r0,|L4.276|
0000e2  8800              LDRH     r0,[r0,#0]  ; initcountPitch
0000e4  2832              CMP      r0,#0x32
0000e6  d102              BNE      |L4.238|
;;;108    		{
;;;109    			flagPitch = 1;
0000e8  2001              MOVS     r0,#1
0000ea  4908              LDR      r1,|L4.268|
0000ec  8008              STRH     r0,[r1,#0]
                  |L4.238|
;;;110    		}
;;;111    	}
;;;112    }
0000ee  bd10              POP      {r4,pc}
;;;113    
                          ENDP

                  |L4.240|
                          DCD      this_angle
                  |L4.244|
                          DCD      last_angle
                  |L4.248|
                          DCD      first_flag
                  |L4.252|
                          DCD      |symbol_number.43|
                  |L4.256|
                          DCD      MotorEncoder
                  |L4.260|
                          DCD      iPitch
                  |L4.264|
                          DCD      filter_bufPitch
                  |L4.268|
                          DCD      flagPitch
                  |L4.272|
                          DCD      PitchPID
                  |L4.276|
                          DCD      initcountPitch

                          AREA ||i.YawAngle||, CODE, READONLY, ALIGN=2

                  YawAngle PROC
;;;187     */
;;;188    void YawAngle(CanRxMsg *msg_rece)
000000  b510              PUSH     {r4,lr}
;;;189    {
000002  ed2d8b02          VPUSH    {d8}
000006  4604              MOV      r4,r0
;;;190    	static float this_yaw_angle,last_yaw_angle;
;;;191        float temp_yaw_angle;
;;;192    	static int turn_cnt;
;;;193    
;;;194    	temp_yaw_angle = (int32_t)(msg_rece->Data[0]<<24)|(int32_t)(msg_rece->Data[1]<<16)
000008  7ae0              LDRB     r0,[r4,#0xb]
00000a  0601              LSLS     r1,r0,#24
00000c  7b20              LDRB     r0,[r4,#0xc]
00000e  ea414100          ORR      r1,r1,r0,LSL #16
000012  7b60              LDRB     r0,[r4,#0xd]
000014  ea412000          ORR      r0,r1,r0,LSL #8
000018  7ba1              LDRB     r1,[r4,#0xe]
00001a  4308              ORRS     r0,r0,r1
00001c  ee000a10          VMOV     s0,r0
000020  eeb80ac0          VCVT.F32.S32 s0,s0
000024  eeb08a40          VMOV.F32 s16,s0
;;;195    	| (int32_t)(msg_rece->Data[2]<<8) | (int32_t)(msg_rece->Data[3]);
;;;196    
;;;197    	last_yaw_angle = this_yaw_angle;
000028  4840              LDR      r0,|L5.300|
00002a  ed900a00          VLDR     s0,[r0,#0]
00002e  4840              LDR      r0,|L5.304|
000030  ed800a00          VSTR     s0,[r0,#0]
;;;198    	this_yaw_angle = -((float)temp_yaw_angle*0.01f);
000034  ed9f0a3f          VLDR     s0,|L5.308|
000038  ee280a40          VNMUL.F32 s0,s16,s0
00003c  483b              LDR      r0,|L5.300|
00003e  ed800a00          VSTR     s0,[r0,#0]
;;;199    	if(this_yaw_angle - last_yaw_angle > 180)
000042  ed900a00          VLDR     s0,[r0,#0]
000046  483a              LDR      r0,|L5.304|
000048  edd00a00          VLDR     s1,[r0,#0]
00004c  ee300a60          VSUB.F32 s0,s0,s1
000050  eddf0a39          VLDR     s1,|L5.312|
000054  eeb40ae0          VCMPE.F32 s0,s1
000058  eef1fa10          VMRS     APSR_nzcv,FPSCR
00005c  dd05              BLE      |L5.106|
;;;200    	{
;;;201    		turn_cnt++;
00005e  4837              LDR      r0,|L5.316|
000060  6800              LDR      r0,[r0,#0]  ; turn_cnt
000062  1c40              ADDS     r0,r0,#1
000064  4935              LDR      r1,|L5.316|
000066  6008              STR      r0,[r1,#0]  ; turn_cnt
000068  e013              B        |L5.146|
                  |L5.106|
;;;202    	}
;;;203    	else if(this_yaw_angle - last_yaw_angle < -180)//180
00006a  4830              LDR      r0,|L5.300|
00006c  ed900a00          VLDR     s0,[r0,#0]
000070  482f              LDR      r0,|L5.304|
000072  edd00a00          VLDR     s1,[r0,#0]
000076  ee300a60          VSUB.F32 s0,s0,s1
00007a  eddf0a31          VLDR     s1,|L5.320|
00007e  eeb40ae0          VCMPE.F32 s0,s1
000082  eef1fa10          VMRS     APSR_nzcv,FPSCR
000086  d204              BCS      |L5.146|
;;;204    	{
;;;205    		turn_cnt--;
000088  482c              LDR      r0,|L5.316|
00008a  6800              LDR      r0,[r0,#0]  ; turn_cnt
00008c  1e40              SUBS     r0,r0,#1
00008e  492b              LDR      r1,|L5.316|
000090  6008              STR      r0,[r1,#0]  ; turn_cnt
                  |L5.146|
;;;206    	}
;;;207    	YAW_Angle = -(this_yaw_angle + turn_cnt*360);
000092  482a              LDR      r0,|L5.316|
000094  6800              LDR      r0,[r0,#0]  ; turn_cnt
000096  f44f71b4          MOV      r1,#0x168
00009a  4348              MULS     r0,r1,r0
00009c  ee000a10          VMOV     s0,r0
0000a0  eeb80ac0          VCVT.F32.S32 s0,s0
0000a4  4821              LDR      r0,|L5.300|
0000a6  edd00a00          VLDR     s1,[r0,#0]
0000aa  ee300a20          VADD.F32 s0,s0,s1
0000ae  eeb10a40          VNEG.F32 s0,s0
0000b2  4824              LDR      r0,|L5.324|
0000b4  ed800a00          VSTR     s0,[r0,#0]
;;;208    //	u1_printf("%d.%d\t%d\r\n",(int)(YAW_Angle),myabs((int)((YAW_Angle - (int)(YAW_Angle))*1000)),CarFramePID.counter);
;;;209    
;;;210    //	u1_printf("%d\r\n",(short)(YAW_Angle*1000));
;;;211    //				printf("%f\r\n",YAW_Angle);
;;;212    	if(YawChangeFlag == 1)
0000b8  4823              LDR      r0,|L5.328|
0000ba  7800              LDRB     r0,[r0,#0]  ; YawChangeFlag
0000bc  2801              CMP      r0,#1
0000be  d131              BNE      |L5.292|
;;;213    	{
;;;214    		if(FollowMode == 0)
0000c0  4822              LDR      r0,|L5.332|
0000c2  ed900a00          VLDR     s0,[r0,#0]
0000c6  eeb50ac0          VCMPE.F32 s0,#0.0
0000ca  eef1fa10          VMRS     APSR_nzcv,FPSCR
0000ce  d111              BNE      |L5.244|
;;;215    		{
;;;216    			YawPID.SetCurrent(((YAW_Angle - YAW_Angle_Zero)*CodedDiscToAngle));
0000d0  481c              LDR      r0,|L5.324|
0000d2  edd00a00          VLDR     s1,[r0,#0]
0000d6  481e              LDR      r0,|L5.336|
0000d8  ed901a00          VLDR     s2,[r0,#0]
0000dc  ee700ac1          VSUB.F32 s1,s1,s2
0000e0  ed9f1a1c          VLDR     s2,|L5.340|
0000e4  ee600a81          VMUL.F32 s1,s1,s2
0000e8  eeb00a60          VMOV.F32 s0,s1
0000ec  4817              LDR      r0,|L5.332|
0000ee  f7fffffe          BL       _ZN7PIDBase10SetCurrentEf ; PIDBase::SetCurrent(float)
0000f2  e017              B        |L5.292|
                  |L5.244|
;;;217    //			camera_a = yaw_angle_6050 + Middle/CodedDiscToAngle;
;;;218    		}
;;;219    		else if(FollowMode == 1)
0000f4  4815              LDR      r0,|L5.332|
0000f6  ed900a00          VLDR     s0,[r0,#0]
0000fa  eef70a00          VMOV.F32 s1,#1.00000000
0000fe  eeb40a60          VCMP.F32 s0,s1
000102  eef1fa10          VMRS     APSR_nzcv,FPSCR
000106  d10d              BNE      |L5.292|
;;;220    			YAW_Angle_Zero = YAW_Angle - YawPID.Target/CodedDiscToAngle;
000108  ed900a01          VLDR     s0,[r0,#4]
00010c  eddf0a11          VLDR     s1,|L5.340|
000110  ee801a20          VDIV.F32 s2,s0,s1
000114  480b              LDR      r0,|L5.324|
000116  ed900a00          VLDR     s0,[r0,#0]
00011a  ee300a41          VSUB.F32 s0,s0,s2
00011e  480c              LDR      r0,|L5.336|
000120  ed800a00          VSTR     s0,[r0,#0]
                  |L5.292|
;;;221    //			temp_angle = yaw_angle_6050;
;;;222    //					printf("%f\r\n",-((YAW_Angle - YAW_Angle_Zero)*CodedDiscToAngle));
;;;223    	}
;;;224    
;;;225    }
000124  ecbd8b02          VPOP     {d8}
000128  bd10              POP      {r4,pc}
;;;226    
                          ENDP

00012a  0000              DCW      0x0000
                  |L5.300|
                          DCD      this_yaw_angle
                  |L5.304|
                          DCD      last_yaw_angle
                  |L5.308|
000134  3c23d70a          DCFS     0x3c23d70a ; 0.0099999997764825821
                  |L5.312|
000138  43340000          DCFS     0x43340000 ; 180
                  |L5.316|
                          DCD      |symbol_number.54|
                  |L5.320|
000140  c3340000          DCFS     0xc3340000 ; -180
                  |L5.324|
                          DCD      YAW_Angle
                  |L5.328|
                          DCD      YawChangeFlag
                  |L5.332|
                          DCD      YawPID
                  |L5.336|
                          DCD      YAW_Angle_Zero
                  |L5.340|
000154  41b60b78          DCFS     0x41b60b78 ; 22.755599975585938

                          AREA ||i.YawAngle_6050||, CODE, READONLY, ALIGN=2

                  YawAngle_6050 PROC
;;;234    float yaw_angle_6050;
;;;235    void YawAngle_6050(CanRxMsg *msg_rece)
000000  b510              PUSH     {r4,lr}
;;;236    {
000002  ed2d8b02          VPUSH    {d8}
000006  4604              MOV      r4,r0
;;;237    	static float this_yaw_angle,last_yaw_angle;
;;;238        float temp_yaw_angle;
;;;239    	static int turn_cnt;
;;;240    
;;;241    //	temp_yaw_angle = (float)(((u16)msg_rece->Data[1])<<8 | (u16)msg_rece->Data[0])/ 100.0f;
;;;242    //	printf("angle:%f\r\n",temp_yaw_angle);
;;;243    	temp_yaw_angle = (int16_t)(((u16)msg_rece->Data[1])<<8 | (u16)msg_rece->Data[0]);
000008  7ae1              LDRB     r1,[r4,#0xb]
00000a  7b20              LDRB     r0,[r4,#0xc]
00000c  ea412000          ORR      r0,r1,r0,LSL #8
000010  b200              SXTH     r0,r0
000012  ee000a10          VMOV     s0,r0
000016  eeb80ac0          VCVT.F32.S32 s0,s0
00001a  eeb08a40          VMOV.F32 s16,s0
;;;244    //	yaw_angle_6050 = temp_yaw_angle * 0.01f;
;;;245    	last_yaw_angle = this_yaw_angle;
00001e  4842              LDR      r0,|L6.296|
000020  ed900a00          VLDR     s0,[r0,#0]
000024  4841              LDR      r0,|L6.300|
000026  ed800a00          VSTR     s0,[r0,#0]
;;;246    	this_yaw_angle = ((float)temp_yaw_angle*0.01f);
00002a  ed9f0a41          VLDR     s0,|L6.304|
00002e  ee280a00          VMUL.F32 s0,s16,s0
000032  483d              LDR      r0,|L6.296|
000034  ed800a00          VSTR     s0,[r0,#0]
;;;247    	if(this_yaw_angle - last_yaw_angle > 180)
000038  ed900a00          VLDR     s0,[r0,#0]
00003c  483b              LDR      r0,|L6.300|
00003e  edd00a00          VLDR     s1,[r0,#0]
000042  ee300a60          VSUB.F32 s0,s0,s1
000046  eddf0a3b          VLDR     s1,|L6.308|
00004a  eeb40ae0          VCMPE.F32 s0,s1
00004e  eef1fa10          VMRS     APSR_nzcv,FPSCR
000052  dd05              BLE      |L6.96|
;;;248    	{
;;;249    		turn_cnt--;
000054  4838              LDR      r0,|L6.312|
000056  6800              LDR      r0,[r0,#0]  ; turn_cnt
000058  1e40              SUBS     r0,r0,#1
00005a  4937              LDR      r1,|L6.312|
00005c  6008              STR      r0,[r1,#0]  ; turn_cnt
00005e  e013              B        |L6.136|
                  |L6.96|
;;;250    	}
;;;251    	else if(this_yaw_angle - last_yaw_angle < -180)//180
000060  4831              LDR      r0,|L6.296|
000062  ed900a00          VLDR     s0,[r0,#0]
000066  4831              LDR      r0,|L6.300|
000068  edd00a00          VLDR     s1,[r0,#0]
00006c  ee300a60          VSUB.F32 s0,s0,s1
000070  eddf0a32          VLDR     s1,|L6.316|
000074  eeb40ae0          VCMPE.F32 s0,s1
000078  eef1fa10          VMRS     APSR_nzcv,FPSCR
00007c  d204              BCS      |L6.136|
;;;252    	{
;;;253    		turn_cnt++;
00007e  482e              LDR      r0,|L6.312|
000080  6800              LDR      r0,[r0,#0]  ; turn_cnt
000082  1c40              ADDS     r0,r0,#1
000084  492c              LDR      r1,|L6.312|
000086  6008              STR      r0,[r1,#0]  ; turn_cnt
                  |L6.136|
;;;254    	}
;;;255    	yaw_angle_6050 = this_yaw_angle + turn_cnt*360;
000088  482b              LDR      r0,|L6.312|
00008a  6800              LDR      r0,[r0,#0]  ; turn_cnt
00008c  f44f71b4          MOV      r1,#0x168
000090  4348              MULS     r0,r1,r0
000092  ee000a10          VMOV     s0,r0
000096  eeb80ac0          VCVT.F32.S32 s0,s0
00009a  4823              LDR      r0,|L6.296|
00009c  edd00a00          VLDR     s1,[r0,#0]
0000a0  ee300a20          VADD.F32 s0,s0,s1
0000a4  4826              LDR      r0,|L6.320|
0000a6  ed800a00          VSTR     s0,[r0,#0]
;;;256    	AngleCorrect.w2 = yaw_angle_6050;
0000aa  ed900a00          VLDR     s0,[r0,#0]
0000ae  4825              LDR      r0,|L6.324|
0000b0  ed800a01          VSTR     s0,[r0,#4]
;;;257    //	ANO_Data1_Send(0xf1,yaw_angle_6050*100);
;;;258    //	u1_printf("%d\r\n",(short)(yaw_angle_6050*100));
;;;259    	if(YawChangeFlag == 1)
0000b4  4824              LDR      r0,|L6.328|
0000b6  7800              LDRB     r0,[r0,#0]  ; YawChangeFlag
0000b8  2801              CMP      r0,#1
0000ba  d131              BNE      |L6.288|
;;;260    	{
;;;261    		if(FollowMode == 0)
0000bc  4823              LDR      r0,|L6.332|
0000be  ed900a00          VLDR     s0,[r0,#0]
0000c2  eeb50ac0          VCMPE.F32 s0,#0.0
0000c6  eef1fa10          VMRS     APSR_nzcv,FPSCR
0000ca  d111              BNE      |L6.240|
;;;262    		{
;;;263    			YawPID.SetCurrent(((yaw_angle_6050 - YAW_Angle_Zero)*CodedDiscToAngle));
0000cc  481c              LDR      r0,|L6.320|
0000ce  edd00a00          VLDR     s1,[r0,#0]
0000d2  481f              LDR      r0,|L6.336|
0000d4  ed901a00          VLDR     s2,[r0,#0]
0000d8  ee700ac1          VSUB.F32 s1,s1,s2
0000dc  ed9f1a1d          VLDR     s2,|L6.340|
0000e0  ee600a81          VMUL.F32 s1,s1,s2
0000e4  eeb00a60          VMOV.F32 s0,s1
0000e8  4818              LDR      r0,|L6.332|
0000ea  f7fffffe          BL       _ZN7PIDBase10SetCurrentEf ; PIDBase::SetCurrent(float)
0000ee  e017              B        |L6.288|
                  |L6.240|
;;;264    //			camera_a = yaw_angle_6050 + Middle/CodedDiscToAngle;
;;;265    		}
;;;266    		else if(FollowMode == 1)
0000f0  4816              LDR      r0,|L6.332|
0000f2  ed900a00          VLDR     s0,[r0,#0]
0000f6  eef70a00          VMOV.F32 s1,#1.00000000
0000fa  eeb40a60          VCMP.F32 s0,s1
0000fe  eef1fa10          VMRS     APSR_nzcv,FPSCR
000102  d10d              BNE      |L6.288|
;;;267    			YAW_Angle_Zero = yaw_angle_6050 - YawPID.Target/CodedDiscToAngle;
000104  ed900a01          VLDR     s0,[r0,#4]
000108  eddf0a12          VLDR     s1,|L6.340|
00010c  ee801a20          VDIV.F32 s2,s0,s1
000110  480b              LDR      r0,|L6.320|
000112  ed900a00          VLDR     s0,[r0,#0]
000116  ee300a41          VSUB.F32 s0,s0,s2
00011a  480d              LDR      r0,|L6.336|
00011c  ed800a00          VSTR     s0,[r0,#0]
                  |L6.288|
;;;268    //			temp_angle = yaw_angle_6050;
;;;269    //					printf("%f\r\n",-((YAW_Angle - YAW_Angle_Zero)*CodedDiscToAngle));
;;;270    	}
;;;271    }
000120  ecbd8b02          VPOP     {d8}
000124  bd10              POP      {r4,pc}
;;;272    
                          ENDP

000126  0000              DCW      0x0000
                  |L6.296|
                          DCD      |symbol_number.55|
                  |L6.300|
                          DCD      |symbol_number.56|
                  |L6.304|
000130  3c23d70a          DCFS     0x3c23d70a ; 0.0099999997764825821
                  |L6.308|
000134  43340000          DCFS     0x43340000 ; 180
                  |L6.312|
                          DCD      |symbol_number.57|
                  |L6.316|
00013c  c3340000          DCFS     0xc3340000 ; -180
                  |L6.320|
                          DCD      yaw_angle_6050
                  |L6.324|
                          DCD      AngleCorrect
                  |L6.328|
                          DCD      YawChangeFlag
                  |L6.332|
                          DCD      YawPID
                  |L6.336|
                          DCD      YAW_Angle_Zero
                  |L6.340|
000154  41b60b78          DCFS     0x41b60b78 ; 22.755599975585938

                          AREA ||i.YawAngle_ADXRS622||, CODE, READONLY, ALIGN=2

                  YawAngle_ADXRS622 PROC
;;;281    float yaw_angle_ADXRS622;
;;;282    void YawAngle_ADXRS622(CanRxMsg *msg_rece)
000000  b510              PUSH     {r4,lr}
;;;283    {
000002  4604              MOV      r4,r0
;;;284    //	float *p;
;;;285    	// yaw_angle_ADXRS622 = ((float)((msg_rece->Data[1]<<8 | msg_rece->Data[0]))/1000.0f);
;;;286    	tt.byte.index[0] = msg_rece->Data[0];
000004  7ae0              LDRB     r0,[r4,#0xb]
000006  4926              LDR      r1,|L7.160|
000008  7008              STRB     r0,[r1,#0]
;;;287    	tt.byte.index[1] = msg_rece->Data[1];
00000a  7b20              LDRB     r0,[r4,#0xc]
00000c  7048              STRB     r0,[r1,#1]
;;;288    	tt.byte.index[2] = msg_rece->Data[2];
00000e  7b60              LDRB     r0,[r4,#0xd]
000010  7088              STRB     r0,[r1,#2]
;;;289    	tt.byte.index[3] = msg_rece->Data[3];
000012  7ba0              LDRB     r0,[r4,#0xe]
000014  70c8              STRB     r0,[r1,#3]
;;;290    	yaw_angle_ADXRS622 = *((float *)(&msg_rece->Data[1]))/1000.0f;
000016  ed940a03          VLDR     s0,[r4,#0xc]
00001a  eddf0a22          VLDR     s1,|L7.164|
00001e  ee801a20          VDIV.F32 s2,s0,s1
000022  4821              LDR      r0,|L7.168|
000024  ed801a00          VSTR     s2,[r0,#0]
;;;291    //	u1_printf("%d\t%d\t%d\t%d\r\n",&msg_rece->Data[0],&msg_rece->Data[1],&msg_rece->Data[2],&msg_rece->Data[3]);
;;;292    //	u1_printf("%d\t%d\t%d\t%d\r\n",&tt.byte.index[0],&tt.byte.index[1],&tt.byte.index[2],&tt.byte.index[3]);
;;;293    //	u1_printf("%d.%d\t%d\r\n",(int)(yaw_angle_ADXRS622),myabs((int)((yaw_angle_ADXRS622 - (int)(yaw_angle_ADXRS622))*1000)),CarFramePID.counter);
;;;294    	AngleCorrect.w2 = yaw_angle_ADXRS622;
000028  ed900a00          VLDR     s0,[r0,#0]
00002c  481f              LDR      r0,|L7.172|
00002e  ed800a01          VSTR     s0,[r0,#4]
;;;295    	if(YawChangeFlag == 1)
000032  481f              LDR      r0,|L7.176|
000034  7800              LDRB     r0,[r0,#0]  ; YawChangeFlag
000036  2801              CMP      r0,#1
000038  d131              BNE      |L7.158|
;;;296    	{
;;;297    		if(FollowMode == 0)
00003a  481e              LDR      r0,|L7.180|
00003c  ed900a00          VLDR     s0,[r0,#0]
000040  eeb50ac0          VCMPE.F32 s0,#0.0
000044  eef1fa10          VMRS     APSR_nzcv,FPSCR
000048  d111              BNE      |L7.110|
;;;298    		{
;;;299    			YawPID.SetCurrent(((yaw_angle_ADXRS622 - YAW_Angle_Zero)*CodedDiscToAngle));
00004a  4817              LDR      r0,|L7.168|
00004c  edd00a00          VLDR     s1,[r0,#0]
000050  4819              LDR      r0,|L7.184|
000052  ed901a00          VLDR     s2,[r0,#0]
000056  ee700ac1          VSUB.F32 s1,s1,s2
00005a  ed9f1a18          VLDR     s2,|L7.188|
00005e  ee600a81          VMUL.F32 s1,s1,s2
000062  eeb00a60          VMOV.F32 s0,s1
000066  4813              LDR      r0,|L7.180|
000068  f7fffffe          BL       _ZN7PIDBase10SetCurrentEf ; PIDBase::SetCurrent(float)
00006c  e017              B        |L7.158|
                  |L7.110|
;;;300    //			camera_a = yaw_angle_ADXRS622 + Middle/CodedDiscToAngle;
;;;301    		}
;;;302    		else if(FollowMode == 1)
00006e  4811              LDR      r0,|L7.180|
000070  ed900a00          VLDR     s0,[r0,#0]
000074  eef70a00          VMOV.F32 s1,#1.00000000
000078  eeb40a60          VCMP.F32 s0,s1
00007c  eef1fa10          VMRS     APSR_nzcv,FPSCR
000080  d10d              BNE      |L7.158|
;;;303    			YAW_Angle_Zero = yaw_angle_ADXRS622 - YawPID.Target/CodedDiscToAngle;
000082  ed900a01          VLDR     s0,[r0,#4]
000086  eddf0a0d          VLDR     s1,|L7.188|
00008a  ee801a20          VDIV.F32 s2,s0,s1
00008e  4806              LDR      r0,|L7.168|
000090  ed900a00          VLDR     s0,[r0,#0]
000094  ee300a41          VSUB.F32 s0,s0,s2
000098  4807              LDR      r0,|L7.184|
00009a  ed800a00          VSTR     s0,[r0,#0]
                  |L7.158|
;;;304    //			temp_angle = yaw_angle_ADXRS622;
;;;305    //					printf("%f\r\n",-((YAW_Angle - YAW_Angle_Zero)*CodedDiscToAngle));
;;;306    	}
;;;307    }
00009e  bd10              POP      {r4,pc}
;;;308    
                          ENDP

                  |L7.160|
                          DCD      ||tt||
                  |L7.164|
0000a4  447a0000          DCFS     0x447a0000 ; 1000
                  |L7.168|
                          DCD      yaw_angle_ADXRS622
                  |L7.172|
                          DCD      AngleCorrect
                  |L7.176|
                          DCD      YawChangeFlag
                  |L7.180|
                          DCD      YawPID
                  |L7.184|
                          DCD      YAW_Angle_Zero
                  |L7.188|
0000bc  41b60b78          DCFS     0x41b60b78 ; 22.755599975585938

                          AREA ||i.YawMotor||, CODE, READONLY, ALIGN=2

                  YawMotor PROC
;;;117     */
;;;118    void YawMotor(CanRxMsg *msg_rece)
000000  b510              PUSH     {r4,lr}
;;;119    {
000002  4604              MOV      r4,r0
;;;120    	// short TempYaw[4];
;;;121    	static u16 flagYaw = 0, initcount = 0;
;;;122    	static short filter_bufYaw[Num];
;;;123    	static unsigned char iYaw=0;
;;;124    
;;;125    //=====================================================================================
;;;126    	static short last_angle,this_angle;
;;;127    	static int turn_cnt,first_flag=1;
;;;128    	last_angle = this_angle;
000004  485f              LDR      r0,|L8.388|
000006  f9b00000          LDRSH    r0,[r0,#0]  ; this_angle
00000a  495f              LDR      r1,|L8.392|
00000c  8008              STRH     r0,[r1,#0]
;;;129    	this_angle = (short)msg_rece->Data[0] <<8 | (short)msg_rece->Data[1];
00000e  7b20              LDRB     r0,[r4,#0xc]
000010  7ae1              LDRB     r1,[r4,#0xb]
000012  ea402001          ORR      r0,r0,r1,LSL #8
000016  b200              SXTH     r0,r0
000018  495a              LDR      r1,|L8.388|
00001a  8008              STRH     r0,[r1,#0]
;;;130    	if(first_flag)//第一次检测处理
00001c  485b              LDR      r0,|L8.396|
00001e  6800              LDR      r0,[r0,#0]  ; first_flag
000020  b138              CBZ      r0,|L8.50|
;;;131    	{
;;;132    		last_angle = this_angle;
000022  4608              MOV      r0,r1
000024  f9b00000          LDRSH    r0,[r0,#0]  ; this_angle
000028  4957              LDR      r1,|L8.392|
00002a  8008              STRH     r0,[r1,#0]
;;;133    		first_flag = 0;
00002c  2000              MOVS     r0,#0
00002e  4957              LDR      r1,|L8.396|
000030  6008              STR      r0,[r1,#0]  ; first_flag
                  |L8.50|
;;;134    	}
;;;135    	if(last_angle < 2048 && this_angle > 6144 )
000032  4855              LDR      r0,|L8.392|
000034  f9b00000          LDRSH    r0,[r0,#0]  ; last_angle
000038  f5b06f00          CMP      r0,#0x800
00003c  da0b              BGE      |L8.86|
00003e  4851              LDR      r0,|L8.388|
000040  f9b00000          LDRSH    r0,[r0,#0]  ; this_angle
000044  f5b05fc0          CMP      r0,#0x1800
000048  dd05              BLE      |L8.86|
;;;136    	{
;;;137    		turn_cnt--;
00004a  4851              LDR      r0,|L8.400|
00004c  6800              LDR      r0,[r0,#0]  ; turn_cnt
00004e  1e40              SUBS     r0,r0,#1
000050  494f              LDR      r1,|L8.400|
000052  6008              STR      r0,[r1,#0]  ; turn_cnt
000054  e010              B        |L8.120|
                  |L8.86|
;;;138    	}
;;;139    	else if(this_angle < 2048 && last_angle > 6144)
000056  484b              LDR      r0,|L8.388|
000058  f9b00000          LDRSH    r0,[r0,#0]  ; this_angle
00005c  f5b06f00          CMP      r0,#0x800
000060  da0a              BGE      |L8.120|
000062  4849              LDR      r0,|L8.392|
000064  f9b00000          LDRSH    r0,[r0,#0]  ; last_angle
000068  f5b05fc0          CMP      r0,#0x1800
00006c  dd04              BLE      |L8.120|
;;;140    	{
;;;141    		turn_cnt++;
00006e  4848              LDR      r0,|L8.400|
000070  6800              LDR      r0,[r0,#0]  ; turn_cnt
000072  1c40              ADDS     r0,r0,#1
000074  4946              LDR      r1,|L8.400|
000076  6008              STR      r0,[r1,#0]  ; turn_cnt
                  |L8.120|
;;;142    	}
;;;143    	MotorEncoder.YawEncoder = this_angle + turn_cnt*8192;
000078  4845              LDR      r0,|L8.400|
00007a  7800              LDRB     r0,[r0,#0]  ; turn_cnt
00007c  4941              LDR      r1,|L8.388|
00007e  8809              LDRH     r1,[r1,#0]  ; this_angle
000080  eb013040          ADD      r0,r1,r0,LSL #13
000084  b200              SXTH     r0,r0
000086  4943              LDR      r1,|L8.404|
000088  8048              STRH     r0,[r1,#2]
;;;144    //=====================================================================================
;;;145    //
;;;146    	MotorEncoder.YawEncoder = Middle_filter(filter_bufYaw,&iYaw,Num,MotorEncoder.YawEncoder);//滑动滤波
00008a  4608              MOV      r0,r1
00008c  f9b03002          LDRSH    r3,[r0,#2]  ; MotorEncoder
000090  2205              MOVS     r2,#5
000092  4941              LDR      r1,|L8.408|
000094  4841              LDR      r0,|L8.412|
000096  f7fffffe          BL       _Z13Middle_filterPsPhhs ; Middle_filter(short*, unsigned char*, unsigned char, short)
00009a  493e              LDR      r1,|L8.404|
00009c  8048              STRH     r0,[r1,#2]
;;;147    	AngleCorrect.w3 = MotorEncoder.YawEncoder;
00009e  4608              MOV      r0,r1
0000a0  f9b00002          LDRSH    r0,[r0,#2]  ; MotorEncoder
0000a4  ee000a10          VMOV     s0,r0
0000a8  eeb80ac0          VCVT.F32.S32 s0,s0
0000ac  483c              LDR      r0,|L8.416|
0000ae  ed800a03          VSTR     s0,[r0,#0xc]
;;;148    //	Set_Speed6623(MotorEncoder.YawEncoder,YAWSPEEDCODER);
;;;149    
;;;150    //	u1_printf("%d\r\n",MotorEncoder.YawEncoder);//调试用
;;;151    	 if(YawChangeFlag == 0 && initcount == 40)//
0000b2  483c              LDR      r0,|L8.420|
0000b4  7800              LDRB     r0,[r0,#0]  ; YawChangeFlag
0000b6  b9c8              CBNZ     r0,|L8.236|
0000b8  483b              LDR      r0,|L8.424|
0000ba  8800              LDRH     r0,[r0,#0]  ; initcount
0000bc  2828              CMP      r0,#0x28
0000be  d115              BNE      |L8.236|
;;;152    	 {
;;;153    		 YAW_Angle_Zero =  (MotorEncoder.YawEncoder - Parameter_Operater.data.YAW_Encoder_Mid)/CodedDiscToAngle;//计算好陀螺仪和码盘初始角度差，给陀螺仪零度校正		 
0000c0  4608              MOV      r0,r1
0000c2  f9b00002          LDRSH    r0,[r0,#2]  ; MotorEncoder
0000c6  ee000a10          VMOV     s0,r0
0000ca  eeb80ac0          VCVT.F32.S32 s0,s0
0000ce  4837              LDR      r0,|L8.428|
0000d0  edd00a04          VLDR     s1,[r0,#0x10]
0000d4  ee300a60          VSUB.F32 s0,s0,s1
0000d8  eddf0a35          VLDR     s1,|L8.432|
0000dc  ee801a20          VDIV.F32 s2,s0,s1
0000e0  4834              LDR      r0,|L8.436|
0000e2  ed801a00          VSTR     s2,[r0,#0]
;;;154    		 YawChangeFlag = 1;//使能陀螺仪输出给PID，进行控制
0000e6  2001              MOVS     r0,#1
0000e8  492e              LDR      r1,|L8.420|
0000ea  7008              STRB     r0,[r1,#0]
                  |L8.236|
;;;155    	 }
;;;156    	if(flagYaw)
0000ec  4832              LDR      r0,|L8.440|
0000ee  8800              LDRH     r0,[r0,#0]  ; flagYaw
0000f0  b3c8              CBZ      r0,|L8.358|
;;;157    	{ 
;;;158    		{
;;;159    			if(FollowMode ==1)
0000f2  4832              LDR      r0,|L8.444|
0000f4  ed900a00          VLDR     s0,[r0,#0]
0000f8  eef70a00          VMOV.F32 s1,#1.00000000
0000fc  eeb40a60          VCMP.F32 s0,s1
000100  eef1fa10          VMRS     APSR_nzcv,FPSCR
000104  d115              BNE      |L8.306|
;;;160    			{	YawPID.SetCurrent((MotorEncoder.YawEncoder - Parameter_Operater.data.YAW_Encoder_Mid + YawPID.Target));
000106  4823              LDR      r0,|L8.404|
000108  f9b00002          LDRSH    r0,[r0,#2]  ; MotorEncoder
00010c  ee000a90          VMOV     s1,r0
000110  eef80ae0          VCVT.F32.S32 s1,s1
000114  4825              LDR      r0,|L8.428|
000116  ed901a04          VLDR     s2,[r0,#0x10]
00011a  ee700ac1          VSUB.F32 s1,s1,s2
00011e  4827              LDR      r0,|L8.444|
000120  ed901a01          VLDR     s2,[r0,#4]
000124  ee700a81          VADD.F32 s1,s1,s2
000128  eeb00a60          VMOV.F32 s0,s1
00012c  f7fffffe          BL       _ZN7PIDBase10SetCurrentEf ; PIDBase::SetCurrent(float)
000130  e026              B        |L8.384|
                  |L8.306|
;;;161    			  
;;;162    				}
;;;163    			else if(FollowMode == 0)
000132  4822              LDR      r0,|L8.444|
000134  ed900a00          VLDR     s0,[r0,#0]
000138  eeb50ac0          VCMPE.F32 s0,#0.0
00013c  eef1fa10          VMRS     APSR_nzcv,FPSCR
000140  d11e              BNE      |L8.384|
;;;164    			{
;;;165    				CarFramePID.SetCurrent((float)(MotorEncoder.YawEncoder - Parameter_Operater.data.YAW_Encoder_Mid));//Yaw轴码盘输出给PID，进行控制
000142  4814              LDR      r0,|L8.404|
000144  f9b00002          LDRSH    r0,[r0,#2]  ; MotorEncoder
000148  ee000a90          VMOV     s1,r0
00014c  eef80ae0          VCVT.F32.S32 s1,s1
000150  4816              LDR      r0,|L8.428|
000152  ed901a04          VLDR     s2,[r0,#0x10]
000156  ee700ac1          VSUB.F32 s1,s1,s2
00015a  eeb00a60          VMOV.F32 s0,s1
00015e  4818              LDR      r0,|L8.448|
000160  f7fffffe          BL       _ZN7PIDBase10SetCurrentEf ; PIDBase::SetCurrent(float)
000164  e00c              B        |L8.384|
                  |L8.358|
000166  e7ff              B        |L8.360|
                  |L8.360|
;;;166    
;;;167    //				u1_printf("%d\r\n",(int)CarFramePID.Current);
;;;168    //				ANO_Data3_Send(0xf1,((float)camera_angle - Middle)/22.7556f,camera_angle/22.7556f,(CarFramePID.Current)/22.7556f);
;;;169    			}
;;;170    		}
;;;171    	}
;;;172    	else
;;;173    	{
;;;174    		initcount ++;
000168  480f              LDR      r0,|L8.424|
00016a  8800              LDRH     r0,[r0,#0]  ; initcount
00016c  1c40              ADDS     r0,r0,#1
00016e  490e              LDR      r1,|L8.424|
000170  8008              STRH     r0,[r1,#0]
;;;175    		if(initcount == 50)
000172  4608              MOV      r0,r1
000174  8800              LDRH     r0,[r0,#0]  ; initcount
000176  2832              CMP      r0,#0x32
000178  d102              BNE      |L8.384|
;;;176    		{
;;;177    			flagYaw = 1;
00017a  2001              MOVS     r0,#1
00017c  490e              LDR      r1,|L8.440|
00017e  8008              STRH     r0,[r1,#0]
                  |L8.384|
;;;178    		}
;;;179    	}
;;;180    }
000180  bd10              POP      {r4,pc}
;;;181    
                          ENDP

000182  0000              DCW      0x0000
                  |L8.388|
                          DCD      |symbol_number.49|
                  |L8.392|
                          DCD      |symbol_number.48|
                  |L8.396|
                          DCD      |symbol_number.51|
                  |L8.400|
                          DCD      |symbol_number.50|
                  |L8.404|
                          DCD      MotorEncoder
                  |L8.408|
                          DCD      iYaw
                  |L8.412|
                          DCD      filter_bufYaw
                  |L8.416|
                          DCD      AngleCorrect
                  |L8.420|
                          DCD      YawChangeFlag
                  |L8.424|
                          DCD      initcount
                  |L8.428|
                          DCD      Parameter_Operater
                  |L8.432|
0001b0  41b60b78          DCFS     0x41b60b78 ; 22.755599975585938
                  |L8.436|
                          DCD      YAW_Angle_Zero
                  |L8.440|
                          DCD      flagYaw
                  |L8.444|
                          DCD      YawPID
                  |L8.448|
                          DCD      CarFramePID

                          AREA ||i._Z13Set_Speed6623ih||, CODE, READONLY, ALIGN=2

                  _Z13Set_Speed6623ih PROC ; Set_Speed6623(int, unsigned char)
;;;31     EncoderStuct Speed6623[2];
;;;32     void Set_Speed6623(int32_t temp,u8 id)
000000  4a25              LDR      r2,|L9.152|
;;;33     {
;;;34     	static int last_position[2];
;;;35     	static int last_coder[2],this_coder[2],turn_cnt[2];
;;;36     
;;;37     	this_coder[id] = temp;
000002  f8420021          STR      r0,[r2,r1,LSL #2]
;;;38     
;;;39     	if(this_coder[id] - last_coder[id] > 4096)
000006  f8522021          LDR      r2,[r2,r1,LSL #2]
00000a  4b24              LDR      r3,|L9.156|
00000c  f8533021          LDR      r3,[r3,r1,LSL #2]
000010  1ad2              SUBS     r2,r2,r3
000012  f5b25f80          CMP      r2,#0x1000
000016  dd07              BLE      |L9.40|
;;;40     	{
;;;41     		turn_cnt[id]--;
000018  4a21              LDR      r2,|L9.160|
00001a  f8522021          LDR      r2,[r2,r1,LSL #2]
00001e  1e52              SUBS     r2,r2,#1
000020  4b1f              LDR      r3,|L9.160|
000022  f8432021          STR      r2,[r3,r1,LSL #2]
000026  e010              B        |L9.74|
                  |L9.40|
;;;42     	}
;;;43     	else if(this_coder[id] - last_coder[id] < -4096)
000028  4a1b              LDR      r2,|L9.152|
00002a  f8522021          LDR      r2,[r2,r1,LSL #2]
00002e  4b1b              LDR      r3,|L9.156|
000030  f8533021          LDR      r3,[r3,r1,LSL #2]
000034  1ad2              SUBS     r2,r2,r3
000036  f5125f80          CMN      r2,#0x1000
00003a  da06              BGE      |L9.74|
;;;44     	{
;;;45     		turn_cnt[id]++;
00003c  4a18              LDR      r2,|L9.160|
00003e  f8522021          LDR      r2,[r2,r1,LSL #2]
000042  1c52              ADDS     r2,r2,#1
000044  4b16              LDR      r3,|L9.160|
000046  f8432021          STR      r2,[r3,r1,LSL #2]
                  |L9.74|
;;;46     	}
;;;47     	last_coder[id] = this_coder[id];
00004a  4a13              LDR      r2,|L9.152|
00004c  f8522021          LDR      r2,[r2,r1,LSL #2]
000050  4b12              LDR      r3,|L9.156|
000052  f8432021          STR      r2,[r3,r1,LSL #2]
;;;48     
;;;49     	Speed6623[id].Position = this_coder[id] + turn_cnt[id] * 8192;
000056  4a10              LDR      r2,|L9.152|
000058  f8523021          LDR      r3,[r2,r1,LSL #2]
00005c  4a10              LDR      r2,|L9.160|
00005e  f8522021          LDR      r2,[r2,r1,LSL #2]
000062  eb033242          ADD      r2,r3,r2,LSL #13
000066  4b0f              LDR      r3,|L9.164|
000068  eb0303c1          ADD      r3,r3,r1,LSL #3
00006c  605a              STR      r2,[r3,#4]
;;;50     	Speed6623[id].Speed = Speed6623[id].Position - last_position[id];
00006e  4a0d              LDR      r2,|L9.164|
000070  eb0202c1          ADD      r2,r2,r1,LSL #3
000074  8892              LDRH     r2,[r2,#4]
000076  4b0c              LDR      r3,|L9.168|
000078  f8333021          LDRH     r3,[r3,r1,LSL #2]
00007c  1ad2              SUBS     r2,r2,r3
00007e  b212              SXTH     r2,r2
000080  4b08              LDR      r3,|L9.164|
000082  f8232031          STRH     r2,[r3,r1,LSL #3]
;;;51     	last_position[id] = Speed6623[id].Position;
000086  461a              MOV      r2,r3
000088  eb0202c1          ADD      r2,r2,r1,LSL #3
00008c  6852              LDR      r2,[r2,#4]
00008e  4b06              LDR      r3,|L9.168|
000090  f8432021          STR      r2,[r3,r1,LSL #2]
;;;52     }
000094  4770              BX       lr
;;;53     
                          ENDP

000096  0000              DCW      0x0000
                  |L9.152|
                          DCD      this_coder
                  |L9.156|
                          DCD      last_coder
                  |L9.160|
                          DCD      turn_cnt
                  |L9.164|
                          DCD      Speed6623
                  |L9.168|
                          DCD      last_position

                          AREA ||.ARM.exidx||, LINKORDER=||i._Z13Set_Speed6623ih||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i._Z13Set_Speed6623ih||
                          DCD      0x00000001

                          AREA ||area_number.11||, LINKORDER=||i.Get_Speed6623||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.11||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.Get_Speed6623||
                          DCD      0x00000001

                          AREA ||area_number.12||, LINKORDER=||i.PitchMotor||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.12||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.PitchMotor||
                          DCD      0x00000001

                          AREA ||area_number.13||, LINKORDER=||i.YawMotor||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.13||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.YawMotor||
                          DCD      0x00000001

                          AREA ||area_number.14||, LINKORDER=||i.YawAngle||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.14||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.YawAngle||
                          DCD      0x00000001

                          AREA ||area_number.15||, LINKORDER=||i.YawAngle_6050||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.15||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.YawAngle_6050||
                          DCD      0x00000001

                          AREA ||area_number.16||, LINKORDER=||i.YawAngle_ADXRS622||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.16||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.YawAngle_ADXRS622||
                          DCD      0x00000001

                          AREA ||area_number.17||, LINKORDER=||i.GetMotorEncoder||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.17||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.GetMotorEncoder||
                          DCD      0x00000001

                          AREA ||area_number.18||, LINKORDER=||i.New_Board||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.18||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.New_Board||
                          DCD      0x00000001

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  AngleCorrect
                          %        24
                  Speed6623
                          %        16
                  filter_bufPitch
                          %        10
                  filter_bufYaw
                          %        10

                          AREA ||.data||, DATA, ALIGN=2

                  YawChangeFlag
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  YAW_Angle
                          DCD      0x00000000
                  YAW_Angle_Zero
                          DCD      0x00000000
                  Infrared_High
00000c  00                DCB      0x00
                  Infrared_Cnt
00000d  00                DCB      0x00
                  Infrared_Message
00000e  00                DCB      0x00
                  runstart_flag
00000f  00                DCB      0x00
                  MotorEncoder
                          DCD      0x00000000
                  yaw_angle_6050
                          DCD      0x00000000
                  ||tt||
                          DCD      0x00000000
                  yaw_angle_ADXRS622
                          DCD      0x00000000
                  last_position
                          %        8
                  last_coder
                          %        8
                  this_coder
                          %        8
                  turn_cnt
                          %        8
                  flagPitch
000040  0000              DCW      0x0000
                  initcountPitch
000042  0000              DCW      0x0000
                  iPitch
000044  0000              DCB      0x00,0x00
                  last_angle
000046  0000              DCB      0x00,0x00
                  this_angle
000048  00000000          DCB      0x00,0x00,0x00,0x00
                  |symbol_number.43|
                          DCD      0x00000000
                  first_flag
                          DCD      0x00000001
                  flagYaw
000054  0000              DCW      0x0000
                  initcount
000056  0000              DCW      0x0000
                  iYaw
000058  0000              DCB      0x00,0x00
                  |symbol_number.48|
00005a  0000              DCB      0x00,0x00
                  |symbol_number.49|
00005c  00000000          DCB      0x00,0x00,0x00,0x00
                  |symbol_number.50|
                          DCD      0x00000000
                  |symbol_number.51|
                          DCD      0x00000001
                  this_yaw_angle
                          DCD      0x00000000
                  last_yaw_angle
                          DCD      0x00000000
                  |symbol_number.54|
                          DCD      0x00000000
                  |symbol_number.55|
                          DCD      0x00000000
                  |symbol_number.56|
                          DCD      0x00000000
                  |symbol_number.57|
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\MySrc\\ostask\\os_can2.cpp"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_os_can2_cpp_a4da48e9___Z7__REV16j|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_os_can2_cpp_a4da48e9___Z7__REV16j| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_os_can2_cpp_a4da48e9___Z7__REVSHi|
#line 144
|__asm___11_os_can2_cpp_a4da48e9___Z7__REVSHi| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___11_os_can2_cpp_a4da48e9___Z5__RRXj|
#line 300
|__asm___11_os_can2_cpp_a4da48e9___Z5__RRXj| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
