; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\stm32f4xx_flash.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\stm32f4xx_flash.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -I..\..\RTX\inc -I..\..\RTX\portable -I..\..\MySrc -I..\..\Libraries -I..\..\MySrc\ostask -I..\..\MySrc\MPU6050 -D__MICROLIB -D__UVISION_VERSION=514 -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DARM_MATH_CM4 -DSTM32F40_41xxx --omf_browse=.\flash\obj\stm32f4xx_flash.crf ..\..\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_flash.c]
                          THUMB

                          AREA ||i.FLASH_ClearFlag||, CODE, READONLY, ALIGN=2

                  FLASH_ClearFlag PROC
;;;1512     */
;;;1513   void FLASH_ClearFlag(uint32_t FLASH_FLAG)
000000  4901              LDR      r1,|L1.8|
;;;1514   {
;;;1515     /* Check the parameters */
;;;1516     assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG));
;;;1517     
;;;1518     /* Clear the flags */
;;;1519     FLASH->SR = FLASH_FLAG;
000002  6008              STR      r0,[r1,#0]
;;;1520   }
000004  4770              BX       lr
;;;1521   
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      0x40023c0c

                          AREA ||i.FLASH_DataCacheCmd||, CODE, READONLY, ALIGN=2

                  FLASH_DataCacheCmd PROC
;;;334      */
;;;335    void FLASH_DataCacheCmd(FunctionalState NewState)
000000  b130              CBZ      r0,|L2.16|
;;;336    {
;;;337      /* Check the parameters */
;;;338      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;339      
;;;340      if(NewState != DISABLE)
;;;341      {
;;;342        FLASH->ACR |= FLASH_ACR_DCEN;
000002  4907              LDR      r1,|L2.32|
000004  6809              LDR      r1,[r1,#0]
000006  f4416180          ORR      r1,r1,#0x400
00000a  4a05              LDR      r2,|L2.32|
00000c  6011              STR      r1,[r2,#0]
00000e  e005              B        |L2.28|
                  |L2.16|
;;;343      }
;;;344      else
;;;345      {
;;;346        FLASH->ACR &= (~FLASH_ACR_DCEN);
000010  4903              LDR      r1,|L2.32|
000012  6809              LDR      r1,[r1,#0]
000014  f4216180          BIC      r1,r1,#0x400
000018  4a01              LDR      r2,|L2.32|
00001a  6011              STR      r1,[r2,#0]
                  |L2.28|
;;;347      }
;;;348    }
00001c  4770              BX       lr
;;;349    
                          ENDP

00001e  0000              DCW      0x0000
                  |L2.32|
                          DCD      0x40023c00

                          AREA ||i.FLASH_DataCacheReset||, CODE, READONLY, ALIGN=2

                  FLASH_DataCacheReset PROC
;;;366      */
;;;367    void FLASH_DataCacheReset(void)
000000  4803              LDR      r0,|L3.16|
;;;368    {
;;;369      FLASH->ACR |= FLASH_ACR_DCRST;
000002  6800              LDR      r0,[r0,#0]
000004  f4405080          ORR      r0,r0,#0x1000
000008  4901              LDR      r1,|L3.16|
00000a  6008              STR      r0,[r1,#0]
;;;370    }
00000c  4770              BX       lr
;;;371    
                          ENDP

00000e  0000              DCW      0x0000
                  |L3.16|
                          DCD      0x40023c00

                          AREA ||i.FLASH_EraseAllBank1Sectors||, CODE, READONLY, ALIGN=2

                  FLASH_EraseAllBank1Sectors PROC
;;;617      */
;;;618    FLASH_Status FLASH_EraseAllBank1Sectors(uint8_t VoltageRange)
000000  b530              PUSH     {r4,r5,lr}
;;;619    {
000002  4602              MOV      r2,r0
;;;620      uint32_t tmp_psize = 0x0;
000004  2500              MOVS     r5,#0
;;;621      FLASH_Status status = FLASH_COMPLETE;
000006  2409              MOVS     r4,#9
;;;622      
;;;623      /* Wait for last operation to be completed */
;;;624      status = FLASH_WaitForLastOperation();
000008  f7fffffe          BL       FLASH_WaitForLastOperation
00000c  4604              MOV      r4,r0
;;;625      assert_param(IS_VOLTAGERANGE(VoltageRange));
;;;626      
;;;627      if(VoltageRange == VoltageRange_1)
00000e  b902              CBNZ     r2,|L4.18|
;;;628      {
;;;629         tmp_psize = FLASH_PSIZE_BYTE;
000010  e009              B        |L4.38|
                  |L4.18|
;;;630      }
;;;631      else if(VoltageRange == VoltageRange_2)
000012  2a01              CMP      r2,#1
000014  d101              BNE      |L4.26|
;;;632      {
;;;633        tmp_psize = FLASH_PSIZE_HALF_WORD;
000016  0215              LSLS     r5,r2,#8
000018  e005              B        |L4.38|
                  |L4.26|
;;;634      }
;;;635      else if(VoltageRange == VoltageRange_3)
00001a  2a02              CMP      r2,#2
00001c  d101              BNE      |L4.34|
;;;636      {
;;;637        tmp_psize = FLASH_PSIZE_WORD;
00001e  0215              LSLS     r5,r2,#8
000020  e001              B        |L4.38|
                  |L4.34|
;;;638      }
;;;639      else
;;;640      {
;;;641        tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
000022  f44f7540          MOV      r5,#0x300
                  |L4.38|
;;;642      }  
;;;643      if(status == FLASH_COMPLETE)
000026  2c09              CMP      r4,#9
000028  d11c              BNE      |L4.100|
;;;644      {
;;;645        /* if the previous operation is completed, proceed to erase all sectors */
;;;646         FLASH->CR &= CR_PSIZE_MASK;
00002a  480f              LDR      r0,|L4.104|
00002c  6800              LDR      r0,[r0,#0]
00002e  f4207040          BIC      r0,r0,#0x300
000032  490d              LDR      r1,|L4.104|
000034  6008              STR      r0,[r1,#0]
;;;647         FLASH->CR |= tmp_psize;
000036  4608              MOV      r0,r1
000038  6800              LDR      r0,[r0,#0]
00003a  4328              ORRS     r0,r0,r5
00003c  6008              STR      r0,[r1,#0]
;;;648         FLASH->CR |= FLASH_CR_MER1;
00003e  4608              MOV      r0,r1
000040  6800              LDR      r0,[r0,#0]
000042  f0400004          ORR      r0,r0,#4
000046  6008              STR      r0,[r1,#0]
;;;649         FLASH->CR |= FLASH_CR_STRT;
000048  4608              MOV      r0,r1
00004a  6800              LDR      r0,[r0,#0]
00004c  f4403080          ORR      r0,r0,#0x10000
000050  6008              STR      r0,[r1,#0]
;;;650        
;;;651        /* Wait for last operation to be completed */
;;;652        status = FLASH_WaitForLastOperation();
000052  f7fffffe          BL       FLASH_WaitForLastOperation
000056  4604              MOV      r4,r0
;;;653    
;;;654        /* if the erase operation is completed, disable the MER Bit */
;;;655        FLASH->CR &= (~FLASH_CR_MER1);
000058  4803              LDR      r0,|L4.104|
00005a  6800              LDR      r0,[r0,#0]
00005c  f0200004          BIC      r0,r0,#4
000060  4901              LDR      r1,|L4.104|
000062  6008              STR      r0,[r1,#0]
                  |L4.100|
;;;656    
;;;657      }   
;;;658      /* Return the Erase Status */
;;;659      return status;
000064  4620              MOV      r0,r4
;;;660    }
000066  bd30              POP      {r4,r5,pc}
;;;661    
                          ENDP

                  |L4.104|
                          DCD      0x40023c10

                          AREA ||i.FLASH_EraseAllBank2Sectors||, CODE, READONLY, ALIGN=2

                  FLASH_EraseAllBank2Sectors PROC
;;;684      */
;;;685    FLASH_Status FLASH_EraseAllBank2Sectors(uint8_t VoltageRange)
000000  b530              PUSH     {r4,r5,lr}
;;;686    {
000002  4602              MOV      r2,r0
;;;687      uint32_t tmp_psize = 0x0;
000004  2500              MOVS     r5,#0
;;;688      FLASH_Status status = FLASH_COMPLETE;
000006  2409              MOVS     r4,#9
;;;689      
;;;690      /* Wait for last operation to be completed */
;;;691      status = FLASH_WaitForLastOperation();
000008  f7fffffe          BL       FLASH_WaitForLastOperation
00000c  4604              MOV      r4,r0
;;;692      assert_param(IS_VOLTAGERANGE(VoltageRange));
;;;693      
;;;694      if(VoltageRange == VoltageRange_1)
00000e  b902              CBNZ     r2,|L5.18|
;;;695      {
;;;696         tmp_psize = FLASH_PSIZE_BYTE;
000010  e009              B        |L5.38|
                  |L5.18|
;;;697      }
;;;698      else if(VoltageRange == VoltageRange_2)
000012  2a01              CMP      r2,#1
000014  d101              BNE      |L5.26|
;;;699      {
;;;700        tmp_psize = FLASH_PSIZE_HALF_WORD;
000016  0215              LSLS     r5,r2,#8
000018  e005              B        |L5.38|
                  |L5.26|
;;;701      }
;;;702      else if(VoltageRange == VoltageRange_3)
00001a  2a02              CMP      r2,#2
00001c  d101              BNE      |L5.34|
;;;703      {
;;;704        tmp_psize = FLASH_PSIZE_WORD;
00001e  0215              LSLS     r5,r2,#8
000020  e001              B        |L5.38|
                  |L5.34|
;;;705      }
;;;706      else
;;;707      {
;;;708        tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
000022  f44f7540          MOV      r5,#0x300
                  |L5.38|
;;;709      }  
;;;710      if(status == FLASH_COMPLETE)
000026  2c09              CMP      r4,#9
000028  d11c              BNE      |L5.100|
;;;711      {
;;;712        /* if the previous operation is completed, proceed to erase all sectors */
;;;713         FLASH->CR &= CR_PSIZE_MASK;
00002a  480f              LDR      r0,|L5.104|
00002c  6800              LDR      r0,[r0,#0]
00002e  f4207040          BIC      r0,r0,#0x300
000032  490d              LDR      r1,|L5.104|
000034  6008              STR      r0,[r1,#0]
;;;714         FLASH->CR |= tmp_psize;
000036  4608              MOV      r0,r1
000038  6800              LDR      r0,[r0,#0]
00003a  4328              ORRS     r0,r0,r5
00003c  6008              STR      r0,[r1,#0]
;;;715         FLASH->CR |= FLASH_CR_MER2;
00003e  4608              MOV      r0,r1
000040  6800              LDR      r0,[r0,#0]
000042  f4404000          ORR      r0,r0,#0x8000
000046  6008              STR      r0,[r1,#0]
;;;716         FLASH->CR |= FLASH_CR_STRT;
000048  4608              MOV      r0,r1
00004a  6800              LDR      r0,[r0,#0]
00004c  f4403080          ORR      r0,r0,#0x10000
000050  6008              STR      r0,[r1,#0]
;;;717        
;;;718        /* Wait for last operation to be completed */
;;;719        status = FLASH_WaitForLastOperation();
000052  f7fffffe          BL       FLASH_WaitForLastOperation
000056  4604              MOV      r4,r0
;;;720    
;;;721        /* if the erase operation is completed, disable the MER Bit */
;;;722        FLASH->CR &= (~FLASH_CR_MER2);
000058  4803              LDR      r0,|L5.104|
00005a  6800              LDR      r0,[r0,#0]
00005c  f4204000          BIC      r0,r0,#0x8000
000060  4901              LDR      r1,|L5.104|
000062  6008              STR      r0,[r1,#0]
                  |L5.100|
;;;723    
;;;724      }   
;;;725      /* Return the Erase Status */
;;;726      return status;
000064  4620              MOV      r0,r4
;;;727    }
000066  bd30              POP      {r4,r5,pc}
;;;728    
                          ENDP

                  |L5.104|
                          DCD      0x40023c10

                          AREA ||i.FLASH_EraseAllSectors||, CODE, READONLY, ALIGN=2

                  FLASH_EraseAllSectors PROC
;;;536      */
;;;537    FLASH_Status FLASH_EraseAllSectors(uint8_t VoltageRange)
000000  b530              PUSH     {r4,r5,lr}
;;;538    {
000002  4602              MOV      r2,r0
;;;539      uint32_t tmp_psize = 0x0;
000004  2500              MOVS     r5,#0
;;;540      FLASH_Status status = FLASH_COMPLETE;
000006  2409              MOVS     r4,#9
;;;541      
;;;542      /* Wait for last operation to be completed */
;;;543      status = FLASH_WaitForLastOperation();
000008  f7fffffe          BL       FLASH_WaitForLastOperation
00000c  4604              MOV      r4,r0
;;;544      assert_param(IS_VOLTAGERANGE(VoltageRange));
;;;545      
;;;546      if(VoltageRange == VoltageRange_1)
00000e  b902              CBNZ     r2,|L6.18|
;;;547      {
;;;548         tmp_psize = FLASH_PSIZE_BYTE;
000010  e009              B        |L6.38|
                  |L6.18|
;;;549      }
;;;550      else if(VoltageRange == VoltageRange_2)
000012  2a01              CMP      r2,#1
000014  d101              BNE      |L6.26|
;;;551      {
;;;552        tmp_psize = FLASH_PSIZE_HALF_WORD;
000016  0215              LSLS     r5,r2,#8
000018  e005              B        |L6.38|
                  |L6.26|
;;;553      }
;;;554      else if(VoltageRange == VoltageRange_3)
00001a  2a02              CMP      r2,#2
00001c  d101              BNE      |L6.34|
;;;555      {
;;;556        tmp_psize = FLASH_PSIZE_WORD;
00001e  0215              LSLS     r5,r2,#8
000020  e001              B        |L6.38|
                  |L6.34|
;;;557      }
;;;558      else
;;;559      {
;;;560        tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
000022  f44f7540          MOV      r5,#0x300
                  |L6.38|
;;;561      }  
;;;562      if(status == FLASH_COMPLETE)
000026  2c09              CMP      r4,#9
000028  d11c              BNE      |L6.100|
;;;563      {
;;;564        /* if the previous operation is completed, proceed to erase all sectors */
;;;565    #if defined(STM32F427_437xx) || defined(STM32F429_439xx)   
;;;566        FLASH->CR &= CR_PSIZE_MASK;
;;;567        FLASH->CR |= tmp_psize;
;;;568        FLASH->CR |= (FLASH_CR_MER1 | FLASH_CR_MER2);
;;;569        FLASH->CR |= FLASH_CR_STRT;
;;;570        
;;;571        /* Wait for last operation to be completed */
;;;572        status = FLASH_WaitForLastOperation();
;;;573    
;;;574        /* if the erase operation is completed, disable the MER Bit */
;;;575        FLASH->CR &= ~(FLASH_CR_MER1 | FLASH_CR_MER2);
;;;576    #endif /* STM32F427_437xx ||  STM32F429_439xx */
;;;577    
;;;578    #if defined(STM32F40_41xxx) || defined(STM32F401xx) || defined(STM32F411xE) || defined(STM32F446xx)
;;;579        FLASH->CR &= CR_PSIZE_MASK;
00002a  480f              LDR      r0,|L6.104|
00002c  6800              LDR      r0,[r0,#0]
00002e  f4207040          BIC      r0,r0,#0x300
000032  490d              LDR      r1,|L6.104|
000034  6008              STR      r0,[r1,#0]
;;;580        FLASH->CR |= tmp_psize;
000036  4608              MOV      r0,r1
000038  6800              LDR      r0,[r0,#0]
00003a  4328              ORRS     r0,r0,r5
00003c  6008              STR      r0,[r1,#0]
;;;581        FLASH->CR |= FLASH_CR_MER;
00003e  4608              MOV      r0,r1
000040  6800              LDR      r0,[r0,#0]
000042  f0400004          ORR      r0,r0,#4
000046  6008              STR      r0,[r1,#0]
;;;582        FLASH->CR |= FLASH_CR_STRT;
000048  4608              MOV      r0,r1
00004a  6800              LDR      r0,[r0,#0]
00004c  f4403080          ORR      r0,r0,#0x10000
000050  6008              STR      r0,[r1,#0]
;;;583        
;;;584        /* Wait for last operation to be completed */
;;;585        status = FLASH_WaitForLastOperation();
000052  f7fffffe          BL       FLASH_WaitForLastOperation
000056  4604              MOV      r4,r0
;;;586    
;;;587        /* if the erase operation is completed, disable the MER Bit */
;;;588        FLASH->CR &= (~FLASH_CR_MER);
000058  4803              LDR      r0,|L6.104|
00005a  6800              LDR      r0,[r0,#0]
00005c  f0200004          BIC      r0,r0,#4
000060  4901              LDR      r1,|L6.104|
000062  6008              STR      r0,[r1,#0]
                  |L6.100|
;;;589    #endif /* STM32F40_41xxx || STM32F401xx || STM32F411xE || STM32F446xx */
;;;590    
;;;591      }   
;;;592      /* Return the Erase Status */
;;;593      return status;
000064  4620              MOV      r0,r4
;;;594    }
000066  bd30              POP      {r4,r5,pc}
;;;595    
                          ENDP

                  |L6.104|
                          DCD      0x40023c10

                          AREA ||i.FLASH_EraseSector||, CODE, READONLY, ALIGN=2

                  FLASH_EraseSector PROC
;;;468      */
;;;469    FLASH_Status FLASH_EraseSector(uint32_t FLASH_Sector, uint8_t VoltageRange)
000000  b570              PUSH     {r4-r6,lr}
;;;470    {
000002  4604              MOV      r4,r0
000004  460a              MOV      r2,r1
;;;471      uint32_t tmp_psize = 0x0;
000006  2600              MOVS     r6,#0
;;;472      FLASH_Status status = FLASH_COMPLETE;
000008  2509              MOVS     r5,#9
;;;473    
;;;474      /* Check the parameters */
;;;475      assert_param(IS_FLASH_SECTOR(FLASH_Sector));
;;;476      assert_param(IS_VOLTAGERANGE(VoltageRange));
;;;477      
;;;478      if(VoltageRange == VoltageRange_1)
00000a  b902              CBNZ     r2,|L7.14|
;;;479      {
;;;480         tmp_psize = FLASH_PSIZE_BYTE;
00000c  e009              B        |L7.34|
                  |L7.14|
;;;481      }
;;;482      else if(VoltageRange == VoltageRange_2)
00000e  2a01              CMP      r2,#1
000010  d101              BNE      |L7.22|
;;;483      {
;;;484        tmp_psize = FLASH_PSIZE_HALF_WORD;
000012  0216              LSLS     r6,r2,#8
000014  e005              B        |L7.34|
                  |L7.22|
;;;485      }
;;;486      else if(VoltageRange == VoltageRange_3)
000016  2a02              CMP      r2,#2
000018  d101              BNE      |L7.30|
;;;487      {
;;;488        tmp_psize = FLASH_PSIZE_WORD;
00001a  0216              LSLS     r6,r2,#8
00001c  e001              B        |L7.34|
                  |L7.30|
;;;489      }
;;;490      else
;;;491      {
;;;492        tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
00001e  f44f7640          MOV      r6,#0x300
                  |L7.34|
;;;493      }
;;;494      /* Wait for last operation to be completed */
;;;495      status = FLASH_WaitForLastOperation();
000022  f7fffffe          BL       FLASH_WaitForLastOperation
000026  4605              MOV      r5,r0
;;;496      
;;;497      if(status == FLASH_COMPLETE)
000028  2d09              CMP      r5,#9
00002a  d128              BNE      |L7.126|
;;;498      { 
;;;499        /* if the previous operation is completed, proceed to erase the sector */
;;;500        FLASH->CR &= CR_PSIZE_MASK;
00002c  4815              LDR      r0,|L7.132|
00002e  6800              LDR      r0,[r0,#0]
000030  f4207040          BIC      r0,r0,#0x300
000034  4913              LDR      r1,|L7.132|
000036  6008              STR      r0,[r1,#0]
;;;501        FLASH->CR |= tmp_psize;
000038  4608              MOV      r0,r1
00003a  6800              LDR      r0,[r0,#0]
00003c  4330              ORRS     r0,r0,r6
00003e  6008              STR      r0,[r1,#0]
;;;502        FLASH->CR &= SECTOR_MASK;
000040  4608              MOV      r0,r1
000042  6800              LDR      r0,[r0,#0]
000044  f02000f8          BIC      r0,r0,#0xf8
000048  6008              STR      r0,[r1,#0]
;;;503        FLASH->CR |= FLASH_CR_SER | FLASH_Sector;
00004a  4608              MOV      r0,r1
00004c  6800              LDR      r0,[r0,#0]
00004e  f0440102          ORR      r1,r4,#2
000052  4308              ORRS     r0,r0,r1
000054  490b              LDR      r1,|L7.132|
000056  6008              STR      r0,[r1,#0]
;;;504        FLASH->CR |= FLASH_CR_STRT;
000058  4608              MOV      r0,r1
00005a  6800              LDR      r0,[r0,#0]
00005c  f4403080          ORR      r0,r0,#0x10000
000060  6008              STR      r0,[r1,#0]
;;;505        
;;;506        /* Wait for last operation to be completed */
;;;507        status = FLASH_WaitForLastOperation();
000062  f7fffffe          BL       FLASH_WaitForLastOperation
000066  4605              MOV      r5,r0
;;;508        
;;;509        /* if the erase operation is completed, disable the SER Bit */
;;;510        FLASH->CR &= (~FLASH_CR_SER);
000068  4806              LDR      r0,|L7.132|
00006a  6800              LDR      r0,[r0,#0]
00006c  f0200002          BIC      r0,r0,#2
000070  4904              LDR      r1,|L7.132|
000072  6008              STR      r0,[r1,#0]
;;;511        FLASH->CR &= SECTOR_MASK; 
000074  4608              MOV      r0,r1
000076  6800              LDR      r0,[r0,#0]
000078  f02000f8          BIC      r0,r0,#0xf8
00007c  6008              STR      r0,[r1,#0]
                  |L7.126|
;;;512      }
;;;513      /* Return the Erase Status */
;;;514      return status;
00007e  4628              MOV      r0,r5
;;;515    }
000080  bd70              POP      {r4-r6,pc}
;;;516    
                          ENDP

000082  0000              DCW      0x0000
                  |L7.132|
                          DCD      0x40023c10

                          AREA ||i.FLASH_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetFlagStatus PROC
;;;1481     */
;;;1482   FlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG)
000000  4601              MOV      r1,r0
;;;1483   {
;;;1484     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1485     /* Check the parameters */
;;;1486     assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG));
;;;1487   
;;;1488     if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
000004  4a03              LDR      r2,|L8.20|
000006  6812              LDR      r2,[r2,#0]
000008  400a              ANDS     r2,r2,r1
00000a  b10a              CBZ      r2,|L8.16|
;;;1489     {
;;;1490       bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L8.18|
                  |L8.16|
;;;1491     }
;;;1492     else
;;;1493     {
;;;1494       bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L8.18|
;;;1495     }
;;;1496     /* Return the new state of FLASH_FLAG (SET or RESET) */
;;;1497     return bitstatus; 
;;;1498   }
000012  4770              BX       lr
;;;1499   
                          ENDP

                  |L8.20|
                          DCD      0x40023c0c

                          AREA ||i.FLASH_GetStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetStatus PROC
;;;1527     */
;;;1528   FLASH_Status FLASH_GetStatus(void)
000000  2009              MOVS     r0,#9
;;;1529   {
;;;1530     FLASH_Status flashstatus = FLASH_COMPLETE;
;;;1531     
;;;1532     if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
000002  4913              LDR      r1,|L9.80|
000004  6809              LDR      r1,[r1,#0]
000006  f4013180          AND      r1,r1,#0x10000
00000a  f5b13f80          CMP      r1,#0x10000
00000e  d101              BNE      |L9.20|
;;;1533     {
;;;1534       flashstatus = FLASH_BUSY;
000010  2001              MOVS     r0,#1
000012  e01c              B        |L9.78|
                  |L9.20|
;;;1535     }
;;;1536     else 
;;;1537     {  
;;;1538       if((FLASH->SR & FLASH_FLAG_WRPERR) != (uint32_t)0x00)
000014  490e              LDR      r1,|L9.80|
000016  6809              LDR      r1,[r1,#0]
000018  f0010110          AND      r1,r1,#0x10
00001c  b109              CBZ      r1,|L9.34|
;;;1539       { 
;;;1540         flashstatus = FLASH_ERROR_WRP;
00001e  2006              MOVS     r0,#6
000020  e015              B        |L9.78|
                  |L9.34|
;;;1541       }
;;;1542       else
;;;1543       {
;;;1544         if((FLASH->SR & FLASH_FLAG_RDERR) != (uint32_t)0x00)
000022  490b              LDR      r1,|L9.80|
000024  6809              LDR      r1,[r1,#0]
000026  f4017180          AND      r1,r1,#0x100
00002a  b109              CBZ      r1,|L9.48|
;;;1545         { 
;;;1546           flashstatus = FLASH_ERROR_RD;
00002c  2002              MOVS     r0,#2
00002e  e00e              B        |L9.78|
                  |L9.48|
;;;1547         } 
;;;1548         else 
;;;1549         {
;;;1550           if((FLASH->SR & (uint32_t)0xE0) != (uint32_t)0x00)
000030  4907              LDR      r1,|L9.80|
000032  6809              LDR      r1,[r1,#0]
000034  f00101e0          AND      r1,r1,#0xe0
000038  b109              CBZ      r1,|L9.62|
;;;1551           {
;;;1552             flashstatus = FLASH_ERROR_PROGRAM; 
00003a  2007              MOVS     r0,#7
00003c  e007              B        |L9.78|
                  |L9.62|
;;;1553           }
;;;1554           else
;;;1555           {
;;;1556             if((FLASH->SR & FLASH_FLAG_OPERR) != (uint32_t)0x00)
00003e  4904              LDR      r1,|L9.80|
000040  6809              LDR      r1,[r1,#0]
000042  f0010102          AND      r1,r1,#2
000046  b109              CBZ      r1,|L9.76|
;;;1557             {
;;;1558               flashstatus = FLASH_ERROR_OPERATION;
000048  2008              MOVS     r0,#8
00004a  e000              B        |L9.78|
                  |L9.76|
;;;1559             }
;;;1560             else
;;;1561             {
;;;1562               flashstatus = FLASH_COMPLETE;
00004c  2009              MOVS     r0,#9
                  |L9.78|
;;;1563             }
;;;1564           }
;;;1565         }
;;;1566       }
;;;1567     }
;;;1568     /* Return the FLASH Status */
;;;1569     return flashstatus;
;;;1570   }
00004e  4770              BX       lr
;;;1571   
                          ENDP

                  |L9.80|
                          DCD      0x40023c0c

                          AREA ||i.FLASH_ITConfig||, CODE, READONLY, ALIGN=2

                  FLASH_ITConfig PROC
;;;1449     */
;;;1450   void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState)
000000  b129              CBZ      r1,|L10.14|
;;;1451   {
;;;1452     /* Check the parameters */
;;;1453     assert_param(IS_FLASH_IT(FLASH_IT)); 
;;;1454     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1455   
;;;1456     if(NewState != DISABLE)
;;;1457     {
;;;1458       /* Enable the interrupt sources */
;;;1459       FLASH->CR |= FLASH_IT;
000002  4a06              LDR      r2,|L10.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L10.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L10.24|
                  |L10.14|
;;;1460     }
;;;1461     else
;;;1462     {
;;;1463       /* Disable the interrupt sources */
;;;1464       FLASH->CR &= ~(uint32_t)FLASH_IT;
00000e  4a03              LDR      r2,|L10.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L10.28|
000016  601a              STR      r2,[r3,#0]
                  |L10.24|
;;;1465     }
;;;1466   }
000018  4770              BX       lr
;;;1467   
                          ENDP

00001a  0000              DCW      0x0000
                  |L10.28|
                          DCD      0x40023c10

                          AREA ||i.FLASH_InstructionCacheCmd||, CODE, READONLY, ALIGN=2

                  FLASH_InstructionCacheCmd PROC
;;;313      */
;;;314    void FLASH_InstructionCacheCmd(FunctionalState NewState)
000000  b130              CBZ      r0,|L11.16|
;;;315    {
;;;316      /* Check the parameters */
;;;317      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;318      
;;;319      if(NewState != DISABLE)
;;;320      {
;;;321        FLASH->ACR |= FLASH_ACR_ICEN;
000002  4907              LDR      r1,|L11.32|
000004  6809              LDR      r1,[r1,#0]
000006  f4417100          ORR      r1,r1,#0x200
00000a  4a05              LDR      r2,|L11.32|
00000c  6011              STR      r1,[r2,#0]
00000e  e005              B        |L11.28|
                  |L11.16|
;;;322      }
;;;323      else
;;;324      {
;;;325        FLASH->ACR &= (~FLASH_ACR_ICEN);
000010  4903              LDR      r1,|L11.32|
000012  6809              LDR      r1,[r1,#0]
000014  f4217100          BIC      r1,r1,#0x200
000018  4a01              LDR      r2,|L11.32|
00001a  6011              STR      r1,[r2,#0]
                  |L11.28|
;;;326      }
;;;327    }
00001c  4770              BX       lr
;;;328    
                          ENDP

00001e  0000              DCW      0x0000
                  |L11.32|
                          DCD      0x40023c00

                          AREA ||i.FLASH_InstructionCacheReset||, CODE, READONLY, ALIGN=2

                  FLASH_InstructionCacheReset PROC
;;;355      */
;;;356    void FLASH_InstructionCacheReset(void)
000000  4803              LDR      r0,|L12.16|
;;;357    {
;;;358      FLASH->ACR |= FLASH_ACR_ICRST;
000002  6800              LDR      r0,[r0,#0]
000004  f4406000          ORR      r0,r0,#0x800
000008  4901              LDR      r1,|L12.16|
00000a  6008              STR      r0,[r1,#0]
;;;359    }
00000c  4770              BX       lr
;;;360    
                          ENDP

00000e  0000              DCW      0x0000
                  |L12.16|
                          DCD      0x40023c00

                          AREA ||i.FLASH_Lock||, CODE, READONLY, ALIGN=2

                  FLASH_Lock PROC
;;;428      */
;;;429    void FLASH_Lock(void)
000000  4803              LDR      r0,|L13.16|
;;;430    {
;;;431      /* Set the LOCK Bit to lock the FLASH Registers access */
;;;432      FLASH->CR |= FLASH_CR_LOCK;
000002  6800              LDR      r0,[r0,#0]
000004  f0404000          ORR      r0,r0,#0x80000000
000008  4901              LDR      r1,|L13.16|
00000a  6008              STR      r0,[r1,#0]
;;;433    }
00000c  4770              BX       lr
;;;434    
                          ENDP

00000e  0000              DCW      0x0000
                  |L13.16|
                          DCD      0x40023c10

                          AREA ||i.FLASH_OB_BORConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_BORConfig PROC
;;;1294     */
;;;1295   void FLASH_OB_BORConfig(uint8_t OB_BOR)
000000  4905              LDR      r1,|L14.24|
;;;1296   {
;;;1297     /* Check the parameters */
;;;1298     assert_param(IS_OB_BOR(OB_BOR));
;;;1299   
;;;1300     /* Set the BOR Level */
;;;1301     *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS &= (~FLASH_OPTCR_BOR_LEV);
000002  7809              LDRB     r1,[r1,#0]
000004  f021010c          BIC      r1,r1,#0xc
000008  4a03              LDR      r2,|L14.24|
00000a  7011              STRB     r1,[r2,#0]
;;;1302     *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= OB_BOR;
00000c  4611              MOV      r1,r2
00000e  7809              LDRB     r1,[r1,#0]
000010  4301              ORRS     r1,r1,r0
000012  7011              STRB     r1,[r2,#0]
;;;1303   
;;;1304   }
000014  4770              BX       lr
;;;1305   
                          ENDP

000016  0000              DCW      0x0000
                  |L14.24|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_BootConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_BootConfig PROC
;;;1273     */
;;;1274   void FLASH_OB_BootConfig(uint8_t OB_BOOT)
000000  4905              LDR      r1,|L15.24|
;;;1275   {
;;;1276     /* Check the parameters */
;;;1277     assert_param(IS_OB_BOOT(OB_BOOT));
;;;1278   
;;;1279     /* Set Dual Bank Boot */
;;;1280     *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS &= (~FLASH_OPTCR_BFB2);
000002  7809              LDRB     r1,[r1,#0]
000004  f0210110          BIC      r1,r1,#0x10
000008  4a03              LDR      r2,|L15.24|
00000a  7011              STRB     r1,[r2,#0]
;;;1281     *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= OB_BOOT;
00000c  4611              MOV      r1,r2
00000e  7809              LDRB     r1,[r1,#0]
000010  4301              ORRS     r1,r1,r0
000012  7011              STRB     r1,[r2,#0]
;;;1282   
;;;1283   }
000014  4770              BX       lr
;;;1284   
                          ENDP

000016  0000              DCW      0x0000
                  |L15.24|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_GetBOR||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetBOR PROC
;;;1420     */
;;;1421   uint8_t FLASH_OB_GetBOR(void)
000000  4802              LDR      r0,|L16.12|
;;;1422   {
;;;1423     /* Return the FLASH BOR level */
;;;1424     return (uint8_t)(*(__IO uint8_t *)(OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0C);
000002  7800              LDRB     r0,[r0,#0]
000004  f000000c          AND      r0,r0,#0xc
;;;1425   }
000008  4770              BX       lr
;;;1426   
                          ENDP

00000a  0000              DCW      0x0000
                  |L16.12|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_GetPCROP||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetPCROP PROC
;;;1369     */
;;;1370   uint16_t FLASH_OB_GetPCROP(void)
000000  4801              LDR      r0,|L17.8|
;;;1371   {
;;;1372     /* Return the FLASH PC Read/write protection Register value */
;;;1373     return (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
000002  8800              LDRH     r0,[r0,#0]
;;;1374   }
000004  4770              BX       lr
;;;1375   
                          ENDP

000006  0000              DCW      0x0000
                  |L17.8|
                          DCD      0x40023c16

                          AREA ||i.FLASH_OB_GetPCROP1||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetPCROP1 PROC
;;;1383     */
;;;1384   uint16_t FLASH_OB_GetPCROP1(void)
000000  4801              LDR      r0,|L18.8|
;;;1385   {
;;;1386     /* Return the FLASH write protection Register value */
;;;1387     return (*(__IO uint16_t *)(OPTCR1_BYTE2_ADDRESS));
000002  8800              LDRH     r0,[r0,#0]
;;;1388   }
000004  4770              BX       lr
;;;1389   
                          ENDP

000006  0000              DCW      0x0000
                  |L18.8|
                          DCD      0x40023c1a

                          AREA ||i.FLASH_OB_GetRDP||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetRDP PROC
;;;1396     */
;;;1397   FlagStatus FLASH_OB_GetRDP(void)
000000  2000              MOVS     r0,#0
;;;1398   {
;;;1399     FlagStatus readstatus = RESET;
;;;1400   
;;;1401     if ((*(__IO uint8_t*)(OPTCR_BYTE1_ADDRESS) != (uint8_t)OB_RDP_Level_0))
000002  4904              LDR      r1,|L19.20|
000004  7809              LDRB     r1,[r1,#0]
000006  29aa              CMP      r1,#0xaa
000008  d001              BEQ      |L19.14|
;;;1402     {
;;;1403       readstatus = SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L19.16|
                  |L19.14|
;;;1404     }
;;;1405     else
;;;1406     {
;;;1407       readstatus = RESET;
00000e  2000              MOVS     r0,#0
                  |L19.16|
;;;1408     }
;;;1409     return readstatus;
;;;1410   }
000010  4770              BX       lr
;;;1411   
                          ENDP

000012  0000              DCW      0x0000
                  |L19.20|
                          DCD      0x40023c15

                          AREA ||i.FLASH_OB_GetUser||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetUser PROC
;;;1330     */
;;;1331   uint8_t FLASH_OB_GetUser(void)
000000  4802              LDR      r0,|L20.12|
;;;1332   {
;;;1333     /* Return the User Option Byte */
;;;1334     return (uint8_t)(FLASH->OPTCR >> 5);
000002  6800              LDR      r0,[r0,#0]
000004  f3c01047          UBFX     r0,r0,#5,#8
;;;1335   }
000008  4770              BX       lr
;;;1336   
                          ENDP

00000a  0000              DCW      0x0000
                  |L20.12|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_GetWRP||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetWRP PROC
;;;1341     */
;;;1342   uint16_t FLASH_OB_GetWRP(void)
000000  4801              LDR      r0,|L21.8|
;;;1343   {
;;;1344     /* Return the FLASH write protection Register value */
;;;1345     return (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
000002  8800              LDRH     r0,[r0,#0]
;;;1346   }
000004  4770              BX       lr
;;;1347   
                          ENDP

000006  0000              DCW      0x0000
                  |L21.8|
                          DCD      0x40023c16

                          AREA ||i.FLASH_OB_GetWRP1||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetWRP1 PROC
;;;1355     */
;;;1356   uint16_t FLASH_OB_GetWRP1(void)
000000  4801              LDR      r0,|L22.8|
;;;1357   {
;;;1358     /* Return the FLASH write protection Register value */
;;;1359     return (*(__IO uint16_t *)(OPTCR1_BYTE2_ADDRESS));
000002  8800              LDRH     r0,[r0,#0]
;;;1360   }
000004  4770              BX       lr
;;;1361   
                          ENDP

000006  0000              DCW      0x0000
                  |L22.8|
                          DCD      0x40023c1a

                          AREA ||i.FLASH_OB_Launch||, CODE, READONLY, ALIGN=2

                  FLASH_OB_Launch PROC
;;;1311     */
;;;1312   FLASH_Status FLASH_OB_Launch(void)
000000  b500              PUSH     {lr}
;;;1313   {
;;;1314     FLASH_Status status = FLASH_COMPLETE;
000002  2209              MOVS     r2,#9
;;;1315   
;;;1316     /* Set the OPTSTRT bit in OPTCR register */
;;;1317     *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= FLASH_OPTCR_OPTSTRT;
000004  4805              LDR      r0,|L23.28|
000006  7800              LDRB     r0,[r0,#0]
000008  f0400002          ORR      r0,r0,#2
00000c  4903              LDR      r1,|L23.28|
00000e  7008              STRB     r0,[r1,#0]
;;;1318   
;;;1319     /* Wait for last operation to be completed */
;;;1320     status = FLASH_WaitForLastOperation();
000010  f7fffffe          BL       FLASH_WaitForLastOperation
000014  4602              MOV      r2,r0
;;;1321   
;;;1322     return status;
000016  4610              MOV      r0,r2
;;;1323   }
000018  bd00              POP      {pc}
;;;1324   
                          ENDP

00001a  0000              DCW      0x0000
                  |L23.28|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_Lock||, CODE, READONLY, ALIGN=2

                  FLASH_OB_Lock PROC
;;;982      */
;;;983    void FLASH_OB_Lock(void)
000000  4803              LDR      r0,|L24.16|
;;;984    {
;;;985      /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
;;;986      FLASH->OPTCR |= FLASH_OPTCR_OPTLOCK;
000002  6800              LDR      r0,[r0,#0]
000004  f0400001          ORR      r0,r0,#1
000008  4901              LDR      r1,|L24.16|
00000a  6008              STR      r0,[r1,#0]
;;;987    }
00000c  4770              BX       lr
;;;988    
                          ENDP

00000e  0000              DCW      0x0000
                  |L24.16|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_PCROP1Config||, CODE, READONLY, ALIGN=2

                  FLASH_OB_PCROP1Config PROC
;;;1164     */
;;;1165   void FLASH_OB_PCROP1Config(uint32_t OB_PCROP, FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;1166   { 
000002  4602              MOV      r2,r0
000004  460c              MOV      r4,r1
;;;1167     FLASH_Status status = FLASH_COMPLETE;
000006  2509              MOVS     r5,#9
;;;1168     
;;;1169     /* Check the parameters */
;;;1170     assert_param(IS_OB_PCROP(OB_PCROP));
;;;1171     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1172       
;;;1173     status = FLASH_WaitForLastOperation();
000008  f7fffffe          BL       FLASH_WaitForLastOperation
00000c  4605              MOV      r5,r0
;;;1174   
;;;1175     if(status == FLASH_COMPLETE)
00000e  2d09              CMP      r5,#9
000010  d10c              BNE      |L25.44|
;;;1176     { 
;;;1177       if(NewState != DISABLE)
000012  b134              CBZ      r4,|L25.34|
;;;1178       {
;;;1179         *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS |= (uint16_t)OB_PCROP;
000014  4806              LDR      r0,|L25.48|
000016  8800              LDRH     r0,[r0,#0]
000018  b291              UXTH     r1,r2
00001a  4308              ORRS     r0,r0,r1
00001c  4904              LDR      r1,|L25.48|
00001e  8008              STRH     r0,[r1,#0]
000020  e004              B        |L25.44|
                  |L25.34|
;;;1180       }
;;;1181       else
;;;1182       {
;;;1183         *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS &= (~OB_PCROP);
000022  4803              LDR      r0,|L25.48|
000024  8800              LDRH     r0,[r0,#0]
000026  4390              BICS     r0,r0,r2
000028  4901              LDR      r1,|L25.48|
00002a  8008              STRH     r0,[r1,#0]
                  |L25.44|
;;;1184       }
;;;1185     }
;;;1186   }
00002c  bd30              POP      {r4,r5,pc}
;;;1187   
                          ENDP

00002e  0000              DCW      0x0000
                  |L25.48|
                          DCD      0x40023c1a

                          AREA ||i.FLASH_OB_PCROPConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_PCROPConfig PROC
;;;1127     */
;;;1128   void FLASH_OB_PCROPConfig(uint32_t OB_PCROP, FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;1129   { 
000002  4602              MOV      r2,r0
000004  460c              MOV      r4,r1
;;;1130     FLASH_Status status = FLASH_COMPLETE;
000006  2509              MOVS     r5,#9
;;;1131     
;;;1132     /* Check the parameters */
;;;1133     assert_param(IS_OB_PCROP(OB_PCROP));
;;;1134     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1135       
;;;1136     status = FLASH_WaitForLastOperation();
000008  f7fffffe          BL       FLASH_WaitForLastOperation
00000c  4605              MOV      r5,r0
;;;1137   
;;;1138     if(status == FLASH_COMPLETE)
00000e  2d09              CMP      r5,#9
000010  d10c              BNE      |L26.44|
;;;1139     { 
;;;1140       if(NewState != DISABLE)
000012  b134              CBZ      r4,|L26.34|
;;;1141       {
;;;1142         *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)OB_PCROP;    
000014  4806              LDR      r0,|L26.48|
000016  8800              LDRH     r0,[r0,#0]
000018  b291              UXTH     r1,r2
00001a  4308              ORRS     r0,r0,r1
00001c  4904              LDR      r1,|L26.48|
00001e  8008              STRH     r0,[r1,#0]
000020  e004              B        |L26.44|
                  |L26.34|
;;;1143       }
;;;1144       else
;;;1145       {
;;;1146         *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~OB_PCROP);
000022  4803              LDR      r0,|L26.48|
000024  8800              LDRH     r0,[r0,#0]
000026  4390              BICS     r0,r0,r2
000028  4901              LDR      r1,|L26.48|
00002a  8008              STRH     r0,[r1,#0]
                  |L26.44|
;;;1147       }
;;;1148     }
;;;1149   }
00002c  bd30              POP      {r4,r5,pc}
;;;1150   
                          ENDP

00002e  0000              DCW      0x0000
                  |L26.48|
                          DCD      0x40023c16

                          AREA ||i.FLASH_OB_PCROPSelectionConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_PCROPSelectionConfig PROC
;;;1097     */
;;;1098   void FLASH_OB_PCROPSelectionConfig(uint8_t OB_PcROP)
000000  21ff              MOVS     r1,#0xff
;;;1099   {  
;;;1100     uint8_t optiontmp = 0xFF;
;;;1101         
;;;1102     /* Check the parameters */
;;;1103     assert_param(IS_OB_PCROP_SELECT(OB_PcROP));
;;;1104     
;;;1105     /* Mask SPRMOD bit */
;;;1106     optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE3_ADDRESS) & (uint8_t)0x7F); 
000002  4a04              LDR      r2,|L27.20|
000004  7812              LDRB     r2,[r2,#0]
000006  f002017f          AND      r1,r2,#0x7f
;;;1107     /* Update Option Byte */
;;;1108     *(__IO uint8_t *)OPTCR_BYTE3_ADDRESS = (uint8_t)(OB_PcROP | optiontmp); 
00000a  ea400201          ORR      r2,r0,r1
00000e  4b01              LDR      r3,|L27.20|
000010  701a              STRB     r2,[r3,#0]
;;;1109       
;;;1110   }
000012  4770              BX       lr
;;;1111   
                          ENDP

                  |L27.20|
                          DCD      0x40023c17

                          AREA ||i.FLASH_OB_RDPConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_RDPConfig PROC
;;;1200     */
;;;1201   void FLASH_OB_RDPConfig(uint8_t OB_RDP)
000000  b510              PUSH     {r4,lr}
;;;1202   {
000002  4602              MOV      r2,r0
;;;1203     FLASH_Status status = FLASH_COMPLETE;
000004  2409              MOVS     r4,#9
;;;1204   
;;;1205     /* Check the parameters */
;;;1206     assert_param(IS_OB_RDP(OB_RDP));
;;;1207   
;;;1208     status = FLASH_WaitForLastOperation();
000006  f7fffffe          BL       FLASH_WaitForLastOperation
00000a  4604              MOV      r4,r0
;;;1209   
;;;1210     if(status == FLASH_COMPLETE)
00000c  2c09              CMP      r4,#9
00000e  d101              BNE      |L28.20|
;;;1211     {
;;;1212       *(__IO uint8_t*)OPTCR_BYTE1_ADDRESS = OB_RDP;
000010  4801              LDR      r0,|L28.24|
000012  7002              STRB     r2,[r0,#0]
                  |L28.20|
;;;1213   
;;;1214     }
;;;1215   }
000014  bd10              POP      {r4,pc}
;;;1216   
                          ENDP

000016  0000              DCW      0x0000
                  |L28.24|
                          DCD      0x40023c15

                          AREA ||i.FLASH_OB_Unlock||, CODE, READONLY, ALIGN=2

                  FLASH_OB_Unlock PROC
;;;967      */
;;;968    void FLASH_OB_Unlock(void)
000000  4805              LDR      r0,|L29.24|
;;;969    {
;;;970      if((FLASH->OPTCR & FLASH_OPTCR_OPTLOCK) != RESET)
000002  6800              LDR      r0,[r0,#0]
000004  f0000001          AND      r0,r0,#1
000008  b128              CBZ      r0,|L29.22|
;;;971      {
;;;972        /* Authorizes the Option Byte register programming */
;;;973        FLASH->OPTKEYR = FLASH_OPT_KEY1;
00000a  4804              LDR      r0,|L29.28|
00000c  4902              LDR      r1,|L29.24|
00000e  390c              SUBS     r1,r1,#0xc
000010  6008              STR      r0,[r1,#0]
;;;974        FLASH->OPTKEYR = FLASH_OPT_KEY2;
000012  4803              LDR      r0,|L29.32|
000014  6008              STR      r0,[r1,#0]
                  |L29.22|
;;;975      }  
;;;976    }
000016  4770              BX       lr
;;;977    
                          ENDP

                  |L29.24|
                          DCD      0x40023c14
                  |L29.28|
                          DCD      0x08192a3b
                  |L29.32|
                          DCD      0x4c5d6e7f

                          AREA ||i.FLASH_OB_UserConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_UserConfig PROC
;;;1232     */
;;;1233   void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1234   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1235     uint8_t optiontmp = 0xFF;
000006  26ff              MOVS     r6,#0xff
;;;1236     FLASH_Status status = FLASH_COMPLETE; 
000008  2709              MOVS     r7,#9
;;;1237   
;;;1238     /* Check the parameters */
;;;1239     assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
;;;1240     assert_param(IS_OB_STOP_SOURCE(OB_STOP));
;;;1241     assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
;;;1242   
;;;1243     /* Wait for last operation to be completed */
;;;1244     status = FLASH_WaitForLastOperation();
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4607              MOV      r7,r0
;;;1245     
;;;1246     if(status == FLASH_COMPLETE)
000010  2f09              CMP      r7,#9
000012  d109              BNE      |L30.40|
;;;1247     { 
;;;1248   #if defined(STM32F427_437xx) || defined(STM32F429_439xx)
;;;1249       /* Mask OPTLOCK, OPTSTRT, BOR_LEV and BFB2 bits */
;;;1250       optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE0_ADDRESS) & (uint8_t)0x1F);
;;;1251   #endif /* STM32F427_437xx ||  STM32F429_439xx */
;;;1252   
;;;1253   #if defined(STM32F40_41xxx) || defined(STM32F401xx) || defined(STM32F411xE) || defined(STM32F446xx)
;;;1254       /* Mask OPTLOCK, OPTSTRT and BOR_LEV bits */
;;;1255       optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0F); 
000014  4805              LDR      r0,|L30.44|
000016  7800              LDRB     r0,[r0,#0]
000018  f000060f          AND      r6,r0,#0xf
;;;1256   #endif /* STM32F40_41xxx || STM32F401xx || STM32F411xE || STM32F446xx */ 
;;;1257   
;;;1258       /* Update User Option Byte */
;;;1259       *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS = OB_IWDG | (uint8_t)(OB_STDBY | (uint8_t)(OB_STOP | ((uint8_t)optiontmp))); 
00001c  ea450006          ORR      r0,r5,r6
000020  4310              ORRS     r0,r0,r2
000022  4320              ORRS     r0,r0,r4
000024  4901              LDR      r1,|L30.44|
000026  7008              STRB     r0,[r1,#0]
                  |L30.40|
;;;1260     }  
;;;1261   }
000028  bdf0              POP      {r4-r7,pc}
;;;1262   
                          ENDP

00002a  0000              DCW      0x0000
                  |L30.44|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_WRP1Config||, CODE, READONLY, ALIGN=2

                  FLASH_OB_WRP1Config PROC
;;;1047     */
;;;1048   void FLASH_OB_WRP1Config(uint32_t OB_WRP, FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;1049   { 
000002  4602              MOV      r2,r0
000004  460c              MOV      r4,r1
;;;1050     FLASH_Status status = FLASH_COMPLETE;
000006  2509              MOVS     r5,#9
;;;1051     
;;;1052     /* Check the parameters */
;;;1053     assert_param(IS_OB_WRP(OB_WRP));
;;;1054     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1055       
;;;1056     status = FLASH_WaitForLastOperation();
000008  f7fffffe          BL       FLASH_WaitForLastOperation
00000c  4605              MOV      r5,r0
;;;1057   
;;;1058     if(status == FLASH_COMPLETE)
00000e  2d09              CMP      r5,#9
000010  d10c              BNE      |L31.44|
;;;1059     { 
;;;1060       if(NewState != DISABLE)
000012  b12c              CBZ      r4,|L31.32|
;;;1061       {
;;;1062         *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS &= (~OB_WRP);
000014  4806              LDR      r0,|L31.48|
000016  8800              LDRH     r0,[r0,#0]
000018  4390              BICS     r0,r0,r2
00001a  4905              LDR      r1,|L31.48|
00001c  8008              STRH     r0,[r1,#0]
00001e  e005              B        |L31.44|
                  |L31.32|
;;;1063       }
;;;1064       else
;;;1065       {
;;;1066         *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS |= (uint16_t)OB_WRP;
000020  4803              LDR      r0,|L31.48|
000022  8800              LDRH     r0,[r0,#0]
000024  b291              UXTH     r1,r2
000026  4308              ORRS     r0,r0,r1
000028  4901              LDR      r1,|L31.48|
00002a  8008              STRH     r0,[r1,#0]
                  |L31.44|
;;;1067       }
;;;1068     }
;;;1069   }
00002c  bd30              POP      {r4,r5,pc}
;;;1070   
                          ENDP

00002e  0000              DCW      0x0000
                  |L31.48|
                          DCD      0x40023c1a

                          AREA ||i.FLASH_OB_WRPConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_WRPConfig PROC
;;;1005     */
;;;1006   void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;1007   { 
000002  4602              MOV      r2,r0
000004  460c              MOV      r4,r1
;;;1008     FLASH_Status status = FLASH_COMPLETE;
000006  2509              MOVS     r5,#9
;;;1009     
;;;1010     /* Check the parameters */
;;;1011     assert_param(IS_OB_WRP(OB_WRP));
;;;1012     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1013       
;;;1014     status = FLASH_WaitForLastOperation();
000008  f7fffffe          BL       FLASH_WaitForLastOperation
00000c  4605              MOV      r5,r0
;;;1015   
;;;1016     if(status == FLASH_COMPLETE)
00000e  2d09              CMP      r5,#9
000010  d10c              BNE      |L32.44|
;;;1017     { 
;;;1018       if(NewState != DISABLE)
000012  b12c              CBZ      r4,|L32.32|
;;;1019       {
;;;1020         *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~OB_WRP);
000014  4806              LDR      r0,|L32.48|
000016  8800              LDRH     r0,[r0,#0]
000018  4390              BICS     r0,r0,r2
00001a  4905              LDR      r1,|L32.48|
00001c  8008              STRH     r0,[r1,#0]
00001e  e005              B        |L32.44|
                  |L32.32|
;;;1021       }
;;;1022       else
;;;1023       {
;;;1024         *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)OB_WRP;
000020  4803              LDR      r0,|L32.48|
000022  8800              LDRH     r0,[r0,#0]
000024  b291              UXTH     r1,r2
000026  4308              ORRS     r0,r0,r1
000028  4901              LDR      r1,|L32.48|
00002a  8008              STRH     r0,[r1,#0]
                  |L32.44|
;;;1025       }
;;;1026     }
;;;1027   }
00002c  bd30              POP      {r4,r5,pc}
;;;1028   
                          ENDP

00002e  0000              DCW      0x0000
                  |L32.48|
                          DCD      0x40023c16

                          AREA ||i.FLASH_PrefetchBufferCmd||, CODE, READONLY, ALIGN=2

                  FLASH_PrefetchBufferCmd PROC
;;;291      */
;;;292    void FLASH_PrefetchBufferCmd(FunctionalState NewState)
000000  b130              CBZ      r0,|L33.16|
;;;293    {
;;;294      /* Check the parameters */
;;;295      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;296      
;;;297      /* Enable or disable the Prefetch Buffer */
;;;298      if(NewState != DISABLE)
;;;299      {
;;;300        FLASH->ACR |= FLASH_ACR_PRFTEN;
000002  4907              LDR      r1,|L33.32|
000004  6809              LDR      r1,[r1,#0]
000006  f4417180          ORR      r1,r1,#0x100
00000a  4a05              LDR      r2,|L33.32|
00000c  6011              STR      r1,[r2,#0]
00000e  e005              B        |L33.28|
                  |L33.16|
;;;301      }
;;;302      else
;;;303      {
;;;304        FLASH->ACR &= (~FLASH_ACR_PRFTEN);
000010  4903              LDR      r1,|L33.32|
000012  6809              LDR      r1,[r1,#0]
000014  f4217180          BIC      r1,r1,#0x100
000018  4a01              LDR      r2,|L33.32|
00001a  6011              STR      r1,[r2,#0]
                  |L33.28|
;;;305      }
;;;306    }
00001c  4770              BX       lr
;;;307    
                          ENDP

00001e  0000              DCW      0x0000
                  |L33.32|
                          DCD      0x40023c00

                          AREA ||i.FLASH_ProgramByte||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramByte PROC
;;;868      */
;;;869    FLASH_Status FLASH_ProgramByte(uint32_t Address, uint8_t Data)
000000  b530              PUSH     {r4,r5,lr}
;;;870    {
000002  4602              MOV      r2,r0
000004  460c              MOV      r4,r1
;;;871      FLASH_Status status = FLASH_COMPLETE;
000006  2509              MOVS     r5,#9
;;;872    
;;;873      /* Check the parameters */
;;;874      assert_param(IS_FLASH_ADDRESS(Address));
;;;875    
;;;876      /* Wait for last operation to be completed */
;;;877      status = FLASH_WaitForLastOperation();
000008  f7fffffe          BL       FLASH_WaitForLastOperation
00000c  4605              MOV      r5,r0
;;;878      
;;;879      if(status == FLASH_COMPLETE)
00000e  2d09              CMP      r5,#9
000010  d117              BNE      |L34.66|
;;;880      {
;;;881        /* if the previous operation is completed, proceed to program the new data */
;;;882        FLASH->CR &= CR_PSIZE_MASK;
000012  480d              LDR      r0,|L34.72|
000014  6800              LDR      r0,[r0,#0]
000016  f4207040          BIC      r0,r0,#0x300
00001a  490b              LDR      r1,|L34.72|
00001c  6008              STR      r0,[r1,#0]
;;;883        FLASH->CR |= FLASH_PSIZE_BYTE;
00001e  4608              MOV      r0,r1
000020  6800              LDR      r0,[r0,#0]
000022  6008              STR      r0,[r1,#0]
;;;884        FLASH->CR |= FLASH_CR_PG;
000024  4608              MOV      r0,r1
000026  6800              LDR      r0,[r0,#0]
000028  f0400001          ORR      r0,r0,#1
00002c  6008              STR      r0,[r1,#0]
;;;885      
;;;886        *(__IO uint8_t*)Address = Data;
00002e  7014              STRB     r4,[r2,#0]
;;;887            
;;;888        /* Wait for last operation to be completed */
;;;889        status = FLASH_WaitForLastOperation();
000030  f7fffffe          BL       FLASH_WaitForLastOperation
000034  4605              MOV      r5,r0
;;;890    
;;;891        /* if the program operation is completed, disable the PG Bit */
;;;892        FLASH->CR &= (~FLASH_CR_PG);
000036  4804              LDR      r0,|L34.72|
000038  6800              LDR      r0,[r0,#0]
00003a  f0200001          BIC      r0,r0,#1
00003e  4902              LDR      r1,|L34.72|
000040  6008              STR      r0,[r1,#0]
                  |L34.66|
;;;893      } 
;;;894    
;;;895      /* Return the Program Status */
;;;896      return status;
000042  4628              MOV      r0,r5
;;;897    }
000044  bd30              POP      {r4,r5,pc}
;;;898    
                          ENDP

000046  0000              DCW      0x0000
                  |L34.72|
                          DCD      0x40023c10

                          AREA ||i.FLASH_ProgramDoubleWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramDoubleWord PROC
;;;741      */
;;;742    FLASH_Status FLASH_ProgramDoubleWord(uint32_t Address, uint64_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;743    {
000002  4606              MOV      r6,r0
000004  4614              MOV      r4,r2
000006  461d              MOV      r5,r3
;;;744      FLASH_Status status = FLASH_COMPLETE;
000008  2209              MOVS     r2,#9
;;;745    
;;;746      /* Check the parameters */
;;;747      assert_param(IS_FLASH_ADDRESS(Address));
;;;748    
;;;749      /* Wait for last operation to be completed */
;;;750      status = FLASH_WaitForLastOperation();
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4602              MOV      r2,r0
;;;751      
;;;752      if(status == FLASH_COMPLETE)
000010  2a09              CMP      r2,#9
000012  d11a              BNE      |L35.74|
;;;753      {
;;;754        /* if the previous operation is completed, proceed to program the new data */
;;;755        FLASH->CR &= CR_PSIZE_MASK;
000014  480e              LDR      r0,|L35.80|
000016  6800              LDR      r0,[r0,#0]
000018  f4207040          BIC      r0,r0,#0x300
00001c  490c              LDR      r1,|L35.80|
00001e  6008              STR      r0,[r1,#0]
;;;756        FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
000020  4608              MOV      r0,r1
000022  6800              LDR      r0,[r0,#0]
000024  f4407040          ORR      r0,r0,#0x300
000028  6008              STR      r0,[r1,#0]
;;;757        FLASH->CR |= FLASH_CR_PG;
00002a  4608              MOV      r0,r1
00002c  6800              LDR      r0,[r0,#0]
00002e  f0400001          ORR      r0,r0,#1
000032  6008              STR      r0,[r1,#0]
;;;758      
;;;759        *(__IO uint64_t*)Address = Data;
000034  6034              STR      r4,[r6,#0]
000036  6075              STR      r5,[r6,#4]
;;;760            
;;;761        /* Wait for last operation to be completed */
;;;762        status = FLASH_WaitForLastOperation();
000038  f7fffffe          BL       FLASH_WaitForLastOperation
00003c  4602              MOV      r2,r0
;;;763    
;;;764        /* if the program operation is completed, disable the PG Bit */
;;;765        FLASH->CR &= (~FLASH_CR_PG);
00003e  4804              LDR      r0,|L35.80|
000040  6800              LDR      r0,[r0,#0]
000042  f0200001          BIC      r0,r0,#1
000046  4902              LDR      r1,|L35.80|
000048  6008              STR      r0,[r1,#0]
                  |L35.74|
;;;766      } 
;;;767      /* Return the Program Status */
;;;768      return status;
00004a  4610              MOV      r0,r2
;;;769    }
00004c  bd70              POP      {r4-r6,pc}
;;;770    
                          ENDP

00004e  0000              DCW      0x0000
                  |L35.80|
                          DCD      0x40023c10

                          AREA ||i.FLASH_ProgramHalfWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramHalfWord PROC
;;;826      */
;;;827    FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
000000  b530              PUSH     {r4,r5,lr}
;;;828    {
000002  4602              MOV      r2,r0
000004  460c              MOV      r4,r1
;;;829      FLASH_Status status = FLASH_COMPLETE;
000006  2509              MOVS     r5,#9
;;;830    
;;;831      /* Check the parameters */
;;;832      assert_param(IS_FLASH_ADDRESS(Address));
;;;833    
;;;834      /* Wait for last operation to be completed */
;;;835      status = FLASH_WaitForLastOperation();
000008  f7fffffe          BL       FLASH_WaitForLastOperation
00000c  4605              MOV      r5,r0
;;;836      
;;;837      if(status == FLASH_COMPLETE)
00000e  2d09              CMP      r5,#9
000010  d119              BNE      |L36.70|
;;;838      {
;;;839        /* if the previous operation is completed, proceed to program the new data */
;;;840        FLASH->CR &= CR_PSIZE_MASK;
000012  480e              LDR      r0,|L36.76|
000014  6800              LDR      r0,[r0,#0]
000016  f4207040          BIC      r0,r0,#0x300
00001a  490c              LDR      r1,|L36.76|
00001c  6008              STR      r0,[r1,#0]
;;;841        FLASH->CR |= FLASH_PSIZE_HALF_WORD;
00001e  4608              MOV      r0,r1
000020  6800              LDR      r0,[r0,#0]
000022  f4407080          ORR      r0,r0,#0x100
000026  6008              STR      r0,[r1,#0]
;;;842        FLASH->CR |= FLASH_CR_PG;
000028  4608              MOV      r0,r1
00002a  6800              LDR      r0,[r0,#0]
00002c  f0400001          ORR      r0,r0,#1
000030  6008              STR      r0,[r1,#0]
;;;843      
;;;844        *(__IO uint16_t*)Address = Data;
000032  8014              STRH     r4,[r2,#0]
;;;845            
;;;846        /* Wait for last operation to be completed */
;;;847        status = FLASH_WaitForLastOperation();
000034  f7fffffe          BL       FLASH_WaitForLastOperation
000038  4605              MOV      r5,r0
;;;848    
;;;849        /* if the program operation is completed, disable the PG Bit */
;;;850        FLASH->CR &= (~FLASH_CR_PG);
00003a  4804              LDR      r0,|L36.76|
00003c  6800              LDR      r0,[r0,#0]
00003e  f0200001          BIC      r0,r0,#1
000042  4902              LDR      r1,|L36.76|
000044  6008              STR      r0,[r1,#0]
                  |L36.70|
;;;851      } 
;;;852      /* Return the Program Status */
;;;853      return status;
000046  4628              MOV      r0,r5
;;;854    }
000048  bd30              POP      {r4,r5,pc}
;;;855    
                          ENDP

00004a  0000              DCW      0x0000
                  |L36.76|
                          DCD      0x40023c10

                          AREA ||i.FLASH_ProgramWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramWord PROC
;;;784      */
;;;785    FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
000000  b530              PUSH     {r4,r5,lr}
;;;786    {
000002  4602              MOV      r2,r0
000004  460c              MOV      r4,r1
;;;787      FLASH_Status status = FLASH_COMPLETE;
000006  2509              MOVS     r5,#9
;;;788    
;;;789      /* Check the parameters */
;;;790      assert_param(IS_FLASH_ADDRESS(Address));
;;;791    
;;;792      /* Wait for last operation to be completed */
;;;793      status = FLASH_WaitForLastOperation();
000008  f7fffffe          BL       FLASH_WaitForLastOperation
00000c  4605              MOV      r5,r0
;;;794      
;;;795      if(status == FLASH_COMPLETE)
00000e  2d09              CMP      r5,#9
000010  d119              BNE      |L37.70|
;;;796      {
;;;797        /* if the previous operation is completed, proceed to program the new data */
;;;798        FLASH->CR &= CR_PSIZE_MASK;
000012  480e              LDR      r0,|L37.76|
000014  6800              LDR      r0,[r0,#0]
000016  f4207040          BIC      r0,r0,#0x300
00001a  490c              LDR      r1,|L37.76|
00001c  6008              STR      r0,[r1,#0]
;;;799        FLASH->CR |= FLASH_PSIZE_WORD;
00001e  4608              MOV      r0,r1
000020  6800              LDR      r0,[r0,#0]
000022  f4407000          ORR      r0,r0,#0x200
000026  6008              STR      r0,[r1,#0]
;;;800        FLASH->CR |= FLASH_CR_PG;
000028  4608              MOV      r0,r1
00002a  6800              LDR      r0,[r0,#0]
00002c  f0400001          ORR      r0,r0,#1
000030  6008              STR      r0,[r1,#0]
;;;801      
;;;802        *(__IO uint32_t*)Address = Data;
000032  6014              STR      r4,[r2,#0]
;;;803            
;;;804        /* Wait for last operation to be completed */
;;;805        status = FLASH_WaitForLastOperation();
000034  f7fffffe          BL       FLASH_WaitForLastOperation
000038  4605              MOV      r5,r0
;;;806    
;;;807        /* if the program operation is completed, disable the PG Bit */
;;;808        FLASH->CR &= (~FLASH_CR_PG);
00003a  4804              LDR      r0,|L37.76|
00003c  6800              LDR      r0,[r0,#0]
00003e  f0200001          BIC      r0,r0,#1
000042  4902              LDR      r1,|L37.76|
000044  6008              STR      r0,[r1,#0]
                  |L37.70|
;;;809      } 
;;;810      /* Return the Program Status */
;;;811      return status;
000046  4628              MOV      r0,r5
;;;812    }
000048  bd30              POP      {r4,r5,pc}
;;;813    
                          ENDP

00004a  0000              DCW      0x0000
                  |L37.76|
                          DCD      0x40023c10

                          AREA ||i.FLASH_SetLatency||, CODE, READONLY, ALIGN=2

                  FLASH_SetLatency PROC
;;;276      */
;;;277    void FLASH_SetLatency(uint32_t FLASH_Latency)
000000  4a01              LDR      r2,|L38.8|
;;;278    {
;;;279      /* Check the parameters */
;;;280      assert_param(IS_FLASH_LATENCY(FLASH_Latency));
;;;281      
;;;282      /* Perform Byte access to FLASH_ACR[8:0] to set the Latency value */
;;;283      *(__IO uint8_t *)ACR_BYTE0_ADDRESS = (uint8_t)FLASH_Latency;
000002  7010              STRB     r0,[r2,#0]
;;;284    }
000004  4770              BX       lr
;;;285    
                          ENDP

000006  0000              DCW      0x0000
                  |L38.8|
                          DCD      0x40023c00

                          AREA ||i.FLASH_Unlock||, CODE, READONLY, ALIGN=2

                  FLASH_Unlock PROC
;;;413      */
;;;414    void FLASH_Unlock(void)
000000  4805              LDR      r0,|L39.24|
;;;415    {
;;;416      if((FLASH->CR & FLASH_CR_LOCK) != RESET)
000002  6800              LDR      r0,[r0,#0]
000004  f0004000          AND      r0,r0,#0x80000000
000008  b128              CBZ      r0,|L39.22|
;;;417      {
;;;418        /* Authorize the FLASH Registers access */
;;;419        FLASH->KEYR = FLASH_KEY1;
00000a  4804              LDR      r0,|L39.28|
00000c  4902              LDR      r1,|L39.24|
00000e  390c              SUBS     r1,r1,#0xc
000010  6008              STR      r0,[r1,#0]
;;;420        FLASH->KEYR = FLASH_KEY2;
000012  4803              LDR      r0,|L39.32|
000014  6008              STR      r0,[r1,#0]
                  |L39.22|
;;;421      }  
;;;422    }
000016  4770              BX       lr
;;;423    
                          ENDP

                  |L39.24|
                          DCD      0x40023c10
                  |L39.28|
                          DCD      0x45670123
                  |L39.32|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_WaitForLastOperation||, CODE, READONLY, ALIGN=1

                  FLASH_WaitForLastOperation PROC
;;;1577     */
;;;1578   FLASH_Status FLASH_WaitForLastOperation(void)
000000  b508              PUSH     {r3,lr}
;;;1579   { 
;;;1580     __IO FLASH_Status status = FLASH_COMPLETE;
000002  2009              MOVS     r0,#9
000004  9000              STR      r0,[sp,#0]
;;;1581      
;;;1582     /* Check for the FLASH Status */
;;;1583     status = FLASH_GetStatus();
000006  f7fffffe          BL       FLASH_GetStatus
00000a  9000              STR      r0,[sp,#0]
;;;1584   
;;;1585     /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
;;;1586        Even if the FLASH operation fails, the BUSY flag will be reset and an error
;;;1587        flag will be set */
;;;1588     while(status == FLASH_BUSY)
00000c  e002              B        |L40.20|
                  |L40.14|
;;;1589     {
;;;1590       status = FLASH_GetStatus();
00000e  f7fffffe          BL       FLASH_GetStatus
000012  9000              STR      r0,[sp,#0]
                  |L40.20|
000014  f89d0000          LDRB     r0,[sp,#0]            ;1588
000018  2801              CMP      r0,#1                 ;1588
00001a  d0f8              BEQ      |L40.14|
;;;1591     }
;;;1592     /* Return the operation status */
;;;1593     return status;
00001c  f89d0000          LDRB     r0,[sp,#0]
;;;1594   }
000020  bd08              POP      {r3,pc}
;;;1595   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_flash.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f4xx_flash_c_a2a150d6____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___17_stm32f4xx_flash_c_a2a150d6____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f4xx_flash_c_a2a150d6____REVSH|
#line 144
|__asm___17_stm32f4xx_flash_c_a2a150d6____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f4xx_flash_c_a2a150d6____RRX|
#line 300
|__asm___17_stm32f4xx_flash_c_a2a150d6____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
