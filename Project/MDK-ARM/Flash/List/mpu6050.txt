; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\mpu6050.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\mpu6050.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -I..\..\RTX\inc -I..\..\RTX\portable -I..\..\MySrc -I..\..\Libraries -I..\..\MySrc\ostask -I..\..\MySrc\MPU6050 -D__MICROLIB -D__UVISION_VERSION=514 -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DARM_MATH_CM4 -DSTM32F40_41xxx --omf_browse=.\flash\obj\mpu6050.crf ..\..\MySrc\MPU6050\mpu6050.c]
                          THUMB

                          AREA ||i.MPU_Get_Accelerometer||, CODE, READONLY, ALIGN=1

                  MPU_Get_Accelerometer PROC
;;;133    //    其他,错误代码
;;;134    u8 MPU_Get_Accelerometer(short *ax,short *ay,short *az)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;135    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;136        u8 buf[6],res;
;;;137    	res=MPU_Read_Len(MPU_ADDR,MPU_ACCEL_XOUTH_REG,6,buf);
00000a  466b              MOV      r3,sp
00000c  2206              MOVS     r2,#6
00000e  213b              MOVS     r1,#0x3b
000010  2068              MOVS     r0,#0x68
000012  f7fffffe          BL       MPU_Read_Len
000016  4607              MOV      r7,r0
;;;138    	if(res==0)
000018  b9bf              CBNZ     r7,|L1.74|
;;;139    	{
;;;140    		*ax=((u16)buf[0]<<8)|buf[1];
00001a  f89d0001          LDRB     r0,[sp,#1]
00001e  f89d1000          LDRB     r1,[sp,#0]
000022  ea402001          ORR      r0,r0,r1,LSL #8
000026  b200              SXTH     r0,r0
000028  8020              STRH     r0,[r4,#0]
;;;141    		*ay=((u16)buf[2]<<8)|buf[3];
00002a  f89d0003          LDRB     r0,[sp,#3]
00002e  f89d1002          LDRB     r1,[sp,#2]
000032  ea402001          ORR      r0,r0,r1,LSL #8
000036  b200              SXTH     r0,r0
000038  8028              STRH     r0,[r5,#0]
;;;142    		*az=((u16)buf[4]<<8)|buf[5];
00003a  f89d0005          LDRB     r0,[sp,#5]
00003e  f89d1004          LDRB     r1,[sp,#4]
000042  ea402001          ORR      r0,r0,r1,LSL #8
000046  b200              SXTH     r0,r0
000048  8030              STRH     r0,[r6,#0]
                  |L1.74|
;;;143    	}
;;;144        return res;;
00004a  4638              MOV      r0,r7
;;;145    }
00004c  e8bd81fc          POP      {r2-r8,pc}
;;;146    //IIC连续写
                          ENDP


                          AREA ||i.MPU_Get_Gyroscope||, CODE, READONLY, ALIGN=1

                  MPU_Get_Gyroscope PROC
;;;113    
;;;114    u8 MPU_Get_Gyroscope(short *gx,short *gy,short *gz)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;115    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;116        u8 buf[6],res;
;;;117    	
;;;118    	res=MPU_Read_Len(MPU_ADDR,MPU_GYRO_XOUTH_REG,6,buf);
00000a  466b              MOV      r3,sp
00000c  2206              MOVS     r2,#6
00000e  2143              MOVS     r1,#0x43
000010  2068              MOVS     r0,#0x68
000012  f7fffffe          BL       MPU_Read_Len
000016  4607              MOV      r7,r0
;;;119    	if(res==0)
000018  b9bf              CBNZ     r7,|L2.74|
;;;120    	{
;;;121    		*gx=(short)(((u16)buf[0]<<8)|buf[1]);
00001a  f89d0001          LDRB     r0,[sp,#1]
00001e  f89d1000          LDRB     r1,[sp,#0]
000022  ea402001          ORR      r0,r0,r1,LSL #8
000026  b200              SXTH     r0,r0
000028  8020              STRH     r0,[r4,#0]
;;;122    		*gy=(short)(((u16)buf[2]<<8)|buf[3]);
00002a  f89d0003          LDRB     r0,[sp,#3]
00002e  f89d1002          LDRB     r1,[sp,#2]
000032  ea402001          ORR      r0,r0,r1,LSL #8
000036  b200              SXTH     r0,r0
000038  8028              STRH     r0,[r5,#0]
;;;123    		*gz=(short)(((u16)buf[4]<<8)|buf[5]);
00003a  f89d0005          LDRB     r0,[sp,#5]
00003e  f89d1004          LDRB     r1,[sp,#4]
000042  ea402001          ORR      r0,r0,r1,LSL #8
000046  b200              SXTH     r0,r0
000048  8030              STRH     r0,[r6,#0]
                  |L2.74|
;;;124    ////		*gx=(short)(((u16)buf[0]<<8)|buf[1]) + 21;
;;;125    ////		*gy=(short)(((u16)buf[2]<<8)|buf[3]) - 10;
;;;126    ////		*gz=(short)(((u16)buf[4]<<8)|buf[5]) + 3;
;;;127    	}
;;;128        return res;;
00004a  4638              MOV      r0,r7
;;;129    }
00004c  e8bd81fc          POP      {r2-r8,pc}
;;;130    //得到加速度值(原始值)
                          ENDP


                          AREA ||i.MPU_Get_Temperature||, CODE, READONLY, ALIGN=2

                  MPU_Get_Temperature PROC
;;;98     //返回值:温度值(扩大了100倍)
;;;99     short MPU_Get_Temperature(void)
000000  b510              PUSH     {r4,lr}
;;;100    {
000002  ed2d8b08          VPUSH    {d8-d11}
000006  b082              SUB      sp,sp,#8
;;;101        u8 buf[2];
;;;102        short raw;
;;;103    	float temp;
;;;104    	MPU_Read_Len(MPU_ADDR,MPU_TEMP_OUTH_REG,2,buf);
000008  ab01              ADD      r3,sp,#4
00000a  2202              MOVS     r2,#2
00000c  2141              MOVS     r1,#0x41
00000e  2068              MOVS     r0,#0x68
000010  f7fffffe          BL       MPU_Read_Len
;;;105        raw=((u16)buf[0]<<8)|buf[1];
000014  f89d0005          LDRB     r0,[sp,#5]
000018  f89d1004          LDRB     r1,[sp,#4]
00001c  ea402001          ORR      r0,r0,r1,LSL #8
000020  b204              SXTH     r4,r0
;;;106        temp=36.53+((double)raw)/340;
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       __aeabi_i2d
000028  ec410b1b          VMOV     d11,r0,r1
00002c  ed9f0b10          VLDR     d0,|L3.112|
000030  ec532b10          VMOV     r2,r3,d0
000034  f7fffffe          BL       __aeabi_ddiv
000038  ec410b1a          VMOV     d10,r0,r1
00003c  ed9f0b0e          VLDR     d0,|L3.120|
000040  ec532b10          VMOV     r2,r3,d0
000044  f7fffffe          BL       __aeabi_dadd
000048  ec410b19          VMOV     d9,r0,r1
00004c  f7fffffe          BL       __aeabi_d2f
000050  ee080a10          VMOV     s16,r0
;;;107        return temp*100;;
000054  ed9f0a0a          VLDR     s0,|L3.128|
000058  ee280a00          VMUL.F32 s0,s16,s0
00005c  eebd0ac0          VCVT.S32.F32 s0,s0
000060  ee100a10          VMOV     r0,s0
000064  b200              SXTH     r0,r0
;;;108    }
000066  b002              ADD      sp,sp,#8
000068  ecbd8b08          VPOP     {d8-d11}
00006c  bd10              POP      {r4,pc}
;;;109    //得到陀螺仪值(原始值)
                          ENDP

00006e  0000              DCW      0x0000
                  |L3.112|
000070  00000000          DCFD     0x4075400000000000 ; 340
000074  40754000
                  |L3.120|
000078  0a3d70a4          DCFD     0x404243d70a3d70a4 ; 36.530000000000001
00007c  404243d7
                  |L3.128|
000080  42c80000          DCFS     0x42c80000 ; 100

                          AREA ||i.MPU_Init||, CODE, READONLY, ALIGN=1

                  MPU_Init PROC
;;;20     //    其他,错误代码
;;;21     u8 MPU_Init(void)
000000  b510              PUSH     {r4,lr}
;;;22     {
;;;23     	u8 res;
;;;24     	IIC_Init();//初始化IIC总线
000002  f7fffffe          BL       IIC_Init
;;;25     	
;;;26     //	RunTime(StartCheck);
;;;27     //	delay_ms(1000);
;;;28     //	RunTime(StopCheck);
;;;29     		
;;;30     	
;;;31     	MPU_Write_Byte(MPU_PWR_MGMT1_REG,0X80);	//复位MPU6050
000006  2180              MOVS     r1,#0x80
000008  206b              MOVS     r0,#0x6b
00000a  f7fffffe          BL       MPU_Write_Byte
;;;32     	
;;;33         delay_ms_nos(100);
00000e  2064              MOVS     r0,#0x64
000010  f7fffffe          BL       delay_ms_nos
;;;34     	
;;;35     	MPU_Write_Byte(MPU_PWR_MGMT1_REG,0X00);	//唤醒MPU6050
000014  2100              MOVS     r1,#0
000016  206b              MOVS     r0,#0x6b
000018  f7fffffe          BL       MPU_Write_Byte
;;;36     	MPU_Set_Gyro_Fsr(3);					//陀螺仪传感器,±2000dps
00001c  2003              MOVS     r0,#3
00001e  f7fffffe          BL       MPU_Set_Gyro_Fsr
;;;37     	MPU_Set_Accel_Fsr(0);					//加速度传感器,±2g
000022  2000              MOVS     r0,#0
000024  f7fffffe          BL       MPU_Set_Accel_Fsr
;;;38     	MPU_Set_Rate(1000);						//设置采样率50Hz
000028  f44f707a          MOV      r0,#0x3e8
00002c  f7fffffe          BL       MPU_Set_Rate
;;;39     	MPU_Write_Byte(MPU_INT_EN_REG,0X00);	//关闭所有中断
000030  2100              MOVS     r1,#0
000032  2038              MOVS     r0,#0x38
000034  f7fffffe          BL       MPU_Write_Byte
;;;40     	MPU_Write_Byte(MPU_USER_CTRL_REG,0X00);	//I2C主模式关闭
000038  2100              MOVS     r1,#0
00003a  206a              MOVS     r0,#0x6a
00003c  f7fffffe          BL       MPU_Write_Byte
;;;41     	MPU_Write_Byte(MPU_FIFO_EN_REG,0X00);	//关闭FIFO
000040  2100              MOVS     r1,#0
000042  2023              MOVS     r0,#0x23
000044  f7fffffe          BL       MPU_Write_Byte
;;;42     	MPU_Write_Byte(MPU_INTBP_CFG_REG,0X80);	//INT引脚低电平有效
000048  2180              MOVS     r1,#0x80
00004a  2037              MOVS     r0,#0x37
00004c  f7fffffe          BL       MPU_Write_Byte
;;;43     	res=MPU_Read_Byte(MPU_DEVICE_ID_REG);
000050  2075              MOVS     r0,#0x75
000052  f7fffffe          BL       MPU_Read_Byte
000056  4604              MOV      r4,r0
;;;44     	if(res==MPU_ADDR)//器件ID正确
000058  2c68              CMP      r4,#0x68
00005a  d10c              BNE      |L4.118|
;;;45     	{
;;;46     		MPU_Write_Byte(MPU_PWR_MGMT1_REG,0X01);	//设置CLKSEL,PLL X轴为参考
00005c  2101              MOVS     r1,#1
00005e  206b              MOVS     r0,#0x6b
000060  f7fffffe          BL       MPU_Write_Byte
;;;47     		MPU_Write_Byte(MPU_PWR_MGMT2_REG,0X00);	//加速度与陀螺仪都工作
000064  2100              MOVS     r1,#0
000066  206c              MOVS     r0,#0x6c
000068  f7fffffe          BL       MPU_Write_Byte
;;;48     		MPU_Set_Rate(1000);						//设置采样率为50Hz
00006c  f44f707a          MOV      r0,#0x3e8
000070  f7fffffe          BL       MPU_Set_Rate
000074  e001              B        |L4.122|
                  |L4.118|
;;;49      	}else return 1;
000076  2001              MOVS     r0,#1
                  |L4.120|
;;;50     	return 0;
;;;51     }
000078  bd10              POP      {r4,pc}
                  |L4.122|
00007a  2000              MOVS     r0,#0                 ;50
00007c  e7fc              B        |L4.120|
;;;52     //设置MPU6050陀螺仪传感器满量程范围
                          ENDP


                          AREA ||i.MPU_Read_Byte||, CODE, READONLY, ALIGN=1

                  MPU_Read_Byte PROC
;;;235    //返回值:读到的数据
;;;236    u8 MPU_Read_Byte(u8 reg)
000000  b570              PUSH     {r4-r6,lr}
;;;237    {
000002  4604              MOV      r4,r0
;;;238    	u8 res;
;;;239        IIC_Start();
000004  f7fffffe          BL       IIC_Start
;;;240    	IIC_Send_Byte((MPU_ADDR<<1)|0);//发送器件地址+写命令
000008  20d0              MOVS     r0,#0xd0
00000a  f7fffffe          BL       IIC_Send_Byte
;;;241    	IIC_Wait_Ack();		//等待应答
00000e  f7fffffe          BL       IIC_Wait_Ack
;;;242        IIC_Send_Byte(reg);	//写寄存器地址
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       IIC_Send_Byte
;;;243        IIC_Wait_Ack();		//等待应答
000018  f7fffffe          BL       IIC_Wait_Ack
;;;244        IIC_Start();
00001c  f7fffffe          BL       IIC_Start
;;;245    	IIC_Send_Byte((MPU_ADDR<<1)|1);//发送器件地址+读命令
000020  20d1              MOVS     r0,#0xd1
000022  f7fffffe          BL       IIC_Send_Byte
;;;246        IIC_Wait_Ack();		//等待应答
000026  f7fffffe          BL       IIC_Wait_Ack
;;;247    	res=IIC_Read_Byte(0);//读取数据,发送nACK
00002a  2000              MOVS     r0,#0
00002c  f7fffffe          BL       IIC_Read_Byte
000030  4605              MOV      r5,r0
;;;248        IIC_Stop();			//产生一个停止条件
000032  f7fffffe          BL       IIC_Stop
;;;249    	return res;
000036  4628              MOV      r0,r5
;;;250    }
000038  bd70              POP      {r4-r6,pc}
;;;251    
                          ENDP


                          AREA ||i.MPU_Read_Len||, CODE, READONLY, ALIGN=1

                  MPU_Read_Len PROC
;;;183    //    其他,错误代码
;;;184    u8 MPU_Read_Len(u8 addr,u8 reg,u8 len,u8 *buf)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;185    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;186     	IIC_Start();
00000c  f7fffffe          BL       IIC_Start
;;;187    	IIC_Send_Byte((addr<<1)|0);//发送器件地址+写命令
000010  2100              MOVS     r1,#0
000012  ea410146          ORR      r1,r1,r6,LSL #1
000016  b2c8              UXTB     r0,r1
000018  f7fffffe          BL       IIC_Send_Byte
;;;188    	if(IIC_Wait_Ack())	//等待应答
00001c  f7fffffe          BL       IIC_Wait_Ack
000020  b120              CBZ      r0,|L6.44|
;;;189    	{
;;;190    		IIC_Stop();
000022  f7fffffe          BL       IIC_Stop
;;;191    		return 1;
000026  2001              MOVS     r0,#1
                  |L6.40|
;;;192    	}
;;;193        IIC_Send_Byte(reg);	//写寄存器地址
;;;194        IIC_Wait_Ack();		//等待应答
;;;195        IIC_Start();
;;;196    	IIC_Send_Byte((addr<<1)|1);//发送器件地址+读命令
;;;197        IIC_Wait_Ack();		//等待应答
;;;198    	while(len)
;;;199    	{
;;;200    		if(len==1)*buf=IIC_Read_Byte(0);//读数据,发送nACK
;;;201    		else *buf=IIC_Read_Byte(1);		//读数据,发送ACK
;;;202    		len--;
;;;203    		buf++;
;;;204    	}
;;;205        IIC_Stop();	//产生一个停止条件
;;;206    	return 0;
;;;207    }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L6.44|
00002c  4638              MOV      r0,r7                 ;193
00002e  f7fffffe          BL       IIC_Send_Byte
000032  f7fffffe          BL       IIC_Wait_Ack
000036  f7fffffe          BL       IIC_Start
00003a  2101              MOVS     r1,#1                 ;196
00003c  eb010146          ADD      r1,r1,r6,LSL #1       ;196
000040  b2c8              UXTB     r0,r1                 ;196
000042  f7fffffe          BL       IIC_Send_Byte
000046  f7fffffe          BL       IIC_Wait_Ack
00004a  e00d              B        |L6.104|
                  |L6.76|
00004c  2c01              CMP      r4,#1                 ;200
00004e  d104              BNE      |L6.90|
000050  2000              MOVS     r0,#0                 ;200
000052  f7fffffe          BL       IIC_Read_Byte
000056  7028              STRB     r0,[r5,#0]            ;200
000058  e003              B        |L6.98|
                  |L6.90|
00005a  2001              MOVS     r0,#1                 ;201
00005c  f7fffffe          BL       IIC_Read_Byte
000060  7028              STRB     r0,[r5,#0]            ;201
                  |L6.98|
000062  1e60              SUBS     r0,r4,#1              ;202
000064  b2c4              UXTB     r4,r0                 ;202
000066  1c6d              ADDS     r5,r5,#1              ;203
                  |L6.104|
000068  2c00              CMP      r4,#0                 ;198
00006a  d1ef              BNE      |L6.76|
00006c  f7fffffe          BL       IIC_Stop
000070  2000              MOVS     r0,#0                 ;206
000072  e7d9              B        |L6.40|
;;;208    //IIC写一个字节
                          ENDP


                          AREA ||i.MPU_Set_Accel_Fsr||, CODE, READONLY, ALIGN=1

                  MPU_Set_Accel_Fsr PROC
;;;63     //    其他,设置失败
;;;64     u8 MPU_Set_Accel_Fsr(u8 fsr)
000000  b510              PUSH     {r4,lr}
;;;65     {
000002  4604              MOV      r4,r0
;;;66     	return MPU_Write_Byte(MPU_ACCEL_CFG_REG,fsr<<3);//设置加速度传感器满量程范围
000004  06e0              LSLS     r0,r4,#27
000006  0e01              LSRS     r1,r0,#24
000008  201c              MOVS     r0,#0x1c
00000a  f7fffffe          BL       MPU_Write_Byte
;;;67     }
00000e  bd10              POP      {r4,pc}
;;;68     //设置MPU6050的数字低通滤波器
                          ENDP


                          AREA ||i.MPU_Set_Gyro_Fsr||, CODE, READONLY, ALIGN=1

                  MPU_Set_Gyro_Fsr PROC
;;;55     //    其他,设置失败
;;;56     u8 MPU_Set_Gyro_Fsr(u8 fsr)
000000  b510              PUSH     {r4,lr}
;;;57     {
000002  4604              MOV      r4,r0
;;;58     	return MPU_Write_Byte(MPU_GYRO_CFG_REG,fsr<<3);//设置陀螺仪满量程范围
000004  06e0              LSLS     r0,r4,#27
000006  0e01              LSRS     r1,r0,#24
000008  201b              MOVS     r0,#0x1b
00000a  f7fffffe          BL       MPU_Write_Byte
;;;59     }
00000e  bd10              POP      {r4,pc}
;;;60     //设置MPU6050加速度传感器满量程范围
                          ENDP


                          AREA ||i.MPU_Set_LPF||, CODE, READONLY, ALIGN=1

                  MPU_Set_LPF PROC
;;;71     //    其他,设置失败
;;;72     u8 MPU_Set_LPF(u16 lpf)
000000  b570              PUSH     {r4-r6,lr}
;;;73     {
000002  4604              MOV      r4,r0
;;;74     	u8 data=0;
000004  2500              MOVS     r5,#0
;;;75     	if(lpf>=188)data=1;
000006  2cbc              CMP      r4,#0xbc
000008  db01              BLT      |L9.14|
00000a  2501              MOVS     r5,#1
00000c  e010              B        |L9.48|
                  |L9.14|
;;;76     	else if(lpf>=98)data=2;
00000e  2c62              CMP      r4,#0x62
000010  db01              BLT      |L9.22|
000012  2502              MOVS     r5,#2
000014  e00c              B        |L9.48|
                  |L9.22|
;;;77     	else if(lpf>=42)data=3;
000016  2c2a              CMP      r4,#0x2a
000018  db01              BLT      |L9.30|
00001a  2503              MOVS     r5,#3
00001c  e008              B        |L9.48|
                  |L9.30|
;;;78     	else if(lpf>=20)data=4;
00001e  2c14              CMP      r4,#0x14
000020  db01              BLT      |L9.38|
000022  2504              MOVS     r5,#4
000024  e004              B        |L9.48|
                  |L9.38|
;;;79     	else if(lpf>=10)data=5;
000026  2c0a              CMP      r4,#0xa
000028  db01              BLT      |L9.46|
00002a  2505              MOVS     r5,#5
00002c  e000              B        |L9.48|
                  |L9.46|
;;;80     	else data=6;
00002e  2506              MOVS     r5,#6
                  |L9.48|
;;;81     	return MPU_Write_Byte(MPU_CFG_REG,data);//设置数字低通滤波器
000030  4629              MOV      r1,r5
000032  201a              MOVS     r0,#0x1a
000034  f7fffffe          BL       MPU_Write_Byte
;;;82     }
000038  bd70              POP      {r4-r6,pc}
;;;83     //设置MPU6050的采样率(假定Fs=1KHz)
                          ENDP


                          AREA ||i.MPU_Set_Rate||, CODE, READONLY, ALIGN=1

                  MPU_Set_Rate PROC
;;;86     //    其他,设置失败
;;;87     u8 MPU_Set_Rate(u16 rate)
000000  b570              PUSH     {r4-r6,lr}
;;;88     {
000002  4604              MOV      r4,r0
;;;89     	u8 data;
;;;90     	if(rate>1000)rate=1000;
000004  f5b47f7a          CMP      r4,#0x3e8
000008  dd01              BLE      |L10.14|
00000a  f44f747a          MOV      r4,#0x3e8
                  |L10.14|
;;;91     	if(rate<4)rate=4;
00000e  2c04              CMP      r4,#4
000010  da00              BGE      |L10.20|
000012  2404              MOVS     r4,#4
                  |L10.20|
;;;92     	data=1000/rate-1;
000014  f44f707a          MOV      r0,#0x3e8
000018  fb90f0f4          SDIV     r0,r0,r4
00001c  1e40              SUBS     r0,r0,#1
00001e  b2c5              UXTB     r5,r0
;;;93     	data=MPU_Write_Byte(MPU_SAMPLE_RATE_REG,data);	//设置数字低通滤波器
000020  4629              MOV      r1,r5
000022  2019              MOVS     r0,#0x19
000024  f7fffffe          BL       MPU_Write_Byte
000028  4605              MOV      r5,r0
;;;94      	return MPU_Set_LPF(rate/2);	//自动设置LPF为采样率的一半
00002a  4626              MOV      r6,r4
00002c  eb0471d6          ADD      r1,r4,r6,LSR #31
000030  f3c1004f          UBFX     r0,r1,#1,#16
000034  f7fffffe          BL       MPU_Set_LPF
;;;95     }
000038  bd70              POP      {r4-r6,pc}
;;;96     
                          ENDP


                          AREA ||i.MPU_Write_Byte||, CODE, READONLY, ALIGN=1

                  MPU_Write_Byte PROC
;;;212    //    其他,错误代码
;;;213    u8 MPU_Write_Byte(u8 reg,u8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;214    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;215        IIC_Start();
000006  f7fffffe          BL       IIC_Start
;;;216    	IIC_Send_Byte((MPU_ADDR<<1)|0);//发送器件地址+写命令
00000a  20d0              MOVS     r0,#0xd0
00000c  f7fffffe          BL       IIC_Send_Byte
;;;217    	if(IIC_Wait_Ack())	//等待应答
000010  f7fffffe          BL       IIC_Wait_Ack
000014  b118              CBZ      r0,|L11.30|
;;;218    	{
;;;219    		IIC_Stop();
000016  f7fffffe          BL       IIC_Stop
;;;220    		return 1;
00001a  2001              MOVS     r0,#1
                  |L11.28|
;;;221    	}
;;;222        IIC_Send_Byte(reg);	//写寄存器地址
;;;223        IIC_Wait_Ack();		//等待应答
;;;224    	IIC_Send_Byte(data);//发送数据
;;;225    	if(IIC_Wait_Ack())	//等待ACK
;;;226    	{
;;;227    		IIC_Stop();
;;;228    		return 1;
;;;229    	}
;;;230        IIC_Stop();
;;;231    	return 0;
;;;232    }
00001c  bd70              POP      {r4-r6,pc}
                  |L11.30|
00001e  4628              MOV      r0,r5                 ;222
000020  f7fffffe          BL       IIC_Send_Byte
000024  f7fffffe          BL       IIC_Wait_Ack
000028  4620              MOV      r0,r4                 ;224
00002a  f7fffffe          BL       IIC_Send_Byte
00002e  f7fffffe          BL       IIC_Wait_Ack
000032  b118              CBZ      r0,|L11.60|
000034  f7fffffe          BL       IIC_Stop
000038  2001              MOVS     r0,#1                 ;228
00003a  e7ef              B        |L11.28|
                  |L11.60|
00003c  f7fffffe          BL       IIC_Stop
000040  2000              MOVS     r0,#0                 ;231
000042  e7eb              B        |L11.28|
;;;233    //IIC读一个字节
                          ENDP


                          AREA ||i.MPU_Write_Len||, CODE, READONLY, ALIGN=1

                  MPU_Write_Len PROC
;;;152    //    其他,错误代码
;;;153    u8 MPU_Write_Len(u8 addr,u8 reg,u8 len,u8 *buf)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;154    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;155    	u8 i;
;;;156        IIC_Start();
00000c  f7fffffe          BL       IIC_Start
;;;157    	IIC_Send_Byte((addr<<1)|0);//发送器件地址+写命令
000010  2100              MOVS     r1,#0
000012  ea410145          ORR      r1,r1,r5,LSL #1
000016  b2c8              UXTB     r0,r1
000018  f7fffffe          BL       IIC_Send_Byte
;;;158    	if(IIC_Wait_Ack())	//等待应答
00001c  f7fffffe          BL       IIC_Wait_Ack
000020  b120              CBZ      r0,|L12.44|
;;;159    	{
;;;160    		IIC_Stop();
000022  f7fffffe          BL       IIC_Stop
;;;161    		return 1;
000026  2001              MOVS     r0,#1
                  |L12.40|
;;;162    	}
;;;163        IIC_Send_Byte(reg);	//写寄存器地址
;;;164        IIC_Wait_Ack();		//等待应答
;;;165    	for(i=0;i<len;i++)
;;;166    	{
;;;167    		IIC_Send_Byte(buf[i]);	//发送数据
;;;168    		if(IIC_Wait_Ack())		//等待ACK
;;;169    		{
;;;170    			IIC_Stop();
;;;171    			return 1;
;;;172    		}
;;;173    	}
;;;174        IIC_Stop();
;;;175    	return 0;
;;;176    }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L12.44|
00002c  4630              MOV      r0,r6                 ;163
00002e  f7fffffe          BL       IIC_Send_Byte
000032  f7fffffe          BL       IIC_Wait_Ack
000036  2400              MOVS     r4,#0                 ;165
000038  e00c              B        |L12.84|
                  |L12.58|
00003a  f8180004          LDRB     r0,[r8,r4]            ;167
00003e  f7fffffe          BL       IIC_Send_Byte
000042  f7fffffe          BL       IIC_Wait_Ack
000046  b118              CBZ      r0,|L12.80|
000048  f7fffffe          BL       IIC_Stop
00004c  2001              MOVS     r0,#1                 ;171
00004e  e7eb              B        |L12.40|
                  |L12.80|
000050  1c60              ADDS     r0,r4,#1              ;165
000052  b2c4              UXTB     r4,r0                 ;165
                  |L12.84|
000054  42bc              CMP      r4,r7                 ;165
000056  dbf0              BLT      |L12.58|
000058  f7fffffe          BL       IIC_Stop
00005c  2000              MOVS     r0,#0                 ;175
00005e  e7e3              B        |L12.40|
;;;177    //IIC连续读
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\MySrc\\MPU6050\\mpu6050.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_mpu6050_c_MPU_Init____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_mpu6050_c_MPU_Init____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_mpu6050_c_MPU_Init____REVSH|
#line 144
|__asm___9_mpu6050_c_MPU_Init____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_mpu6050_c_MPU_Init____RRX|
#line 300
|__asm___9_mpu6050_c_MPU_Init____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
