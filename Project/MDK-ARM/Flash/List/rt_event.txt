; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\rt_event.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\rt_event.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -I..\..\RTX\inc -I..\..\RTX\portable -I..\..\MySrc -I..\..\Libraries -I..\..\MySrc\ostask -I..\..\MySrc\MPU6050 -D__MICROLIB -D__UVISION_VERSION=514 -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DARM_MATH_CM4 -DSTM32F40_41xxx --omf_browse=.\flash\obj\rt_event.crf ..\..\RTX\src\rt_Event.c]
                          THUMB

                          AREA ||i.isr_evt_set||, CODE, READONLY, ALIGN=2

                  isr_evt_set PROC
;;;109    
;;;110    void isr_evt_set (U16 event_flags, OS_TID task_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;111      /* Same function as "os_evt_set", but to be called by ISRs. */
;;;112      P_TCB p_tcb = os_active_TCB[task_id-1];
000006  1e70              SUBS     r0,r6,#1
000008  4906              LDR      r1,|L1.36|
00000a  f8515020          LDR      r5,[r1,r0,LSL #2]
;;;113    
;;;114      if (p_tcb == NULL) {
00000e  b905              CBNZ     r5,|L1.18|
                  |L1.16|
;;;115        return;
;;;116      }
;;;117      rt_psq_enq (p_tcb, event_flags);
;;;118      rt_psh_req ();
;;;119    }
000010  bd70              POP      {r4-r6,pc}
                  |L1.18|
000012  4621              MOV      r1,r4                 ;117
000014  4628              MOV      r0,r5                 ;117
000016  f7fffffe          BL       rt_psq_enq
00001a  f7fffffe          BL       rt_psh_req
00001e  bf00              NOP      
000020  e7f6              B        |L1.16|
;;;120    
                          ENDP

000022  0000              DCW      0x0000
                  |L1.36|
                          DCD      os_active_TCB

                          AREA ||i.rt_evt_clr||, CODE, READONLY, ALIGN=2

                  rt_evt_clr PROC
;;;95     
;;;96     void rt_evt_clr (U16 clear_flags, OS_TID task_id) {
000000  b510              PUSH     {r4,lr}
000002  4602              MOV      r2,r0
;;;97       /* Clear one or more event flags (identified by "clear_flags") of a */
;;;98       /* selectable task (identified by "task"). */
;;;99       P_TCB task = os_active_TCB[task_id-1];
000004  1e4b              SUBS     r3,r1,#1
000006  4c05              LDR      r4,|L2.28|
000008  f8540023          LDR      r0,[r4,r3,LSL #2]
;;;100    
;;;101      if (task == NULL) {
00000c  b900              CBNZ     r0,|L2.16|
                  |L2.14|
;;;102        return;
;;;103      }
;;;104      task->events &= ~clear_flags;
;;;105    }
00000e  bd10              POP      {r4,pc}
                  |L2.16|
000010  8b03              LDRH     r3,[r0,#0x18]         ;104
000012  4393              BICS     r3,r3,r2              ;104
000014  8303              STRH     r3,[r0,#0x18]         ;104
000016  bf00              NOP      
000018  e7f9              B        |L2.14|
;;;106    
                          ENDP

00001a  0000              DCW      0x0000
                  |L2.28|
                          DCD      os_active_TCB

                          AREA ||i.rt_evt_get||, CODE, READONLY, ALIGN=2

                  rt_evt_get PROC
;;;123    
;;;124    U16 rt_evt_get (void) {
000000  4801              LDR      r0,|L3.8|
;;;125      /* Get events of a running task after waiting for OR connected events. */
;;;126      return (os_tsk.run->waits);
000002  6800              LDR      r0,[r0,#0]  ; os_tsk
000004  8b40              LDRH     r0,[r0,#0x1a]
;;;127    }
000006  4770              BX       lr
;;;128    
                          ENDP

                  |L3.8|
                          DCD      os_tsk

                          AREA ||i.rt_evt_psh||, CODE, READONLY, ALIGN=2

                  rt_evt_psh PROC
;;;131    
;;;132    void rt_evt_psh (P_TCB p_CB, U16 set_flags) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;133      /* Check if task has to be waken up */
;;;134      U16 event_flags;
;;;135    
;;;136      p_CB->events |= set_flags;
000006  8b20              LDRH     r0,[r4,#0x18]
000008  4330              ORRS     r0,r0,r6
00000a  8320              STRH     r0,[r4,#0x18]
;;;137      event_flags = p_CB->waits;
00000c  8b65              LDRH     r5,[r4,#0x1a]
;;;138      if (p_CB->state == WAIT_AND) {
00000e  7860              LDRB     r0,[r4,#1]
000010  2806              CMP      r0,#6
000012  d104              BNE      |L4.30|
;;;139        /* Check for AND-connected events */
;;;140        if ((p_CB->events & event_flags) == event_flags) {
000014  8b20              LDRH     r0,[r4,#0x18]
000016  4028              ANDS     r0,r0,r5
000018  42a8              CMP      r0,r5
00001a  d100              BNE      |L4.30|
;;;141          goto rdy;
00001c  e00a              B        |L4.52|
                  |L4.30|
;;;142        }
;;;143      }
;;;144      if (p_CB->state == WAIT_OR) {
00001e  7860              LDRB     r0,[r4,#1]
000020  2805              CMP      r0,#5
000022  d116              BNE      |L4.82|
;;;145        /* Check for OR-connected events */
;;;146        if (p_CB->events & event_flags) {
000024  8b20              LDRH     r0,[r4,#0x18]
000026  4028              ANDS     r0,r0,r5
000028  b198              CBZ      r0,|L4.82|
;;;147          p_CB->waits  &= p_CB->events;
00002a  8b60              LDRH     r0,[r4,#0x1a]
00002c  8b21              LDRH     r1,[r4,#0x18]
00002e  4008              ANDS     r0,r0,r1
000030  8360              STRH     r0,[r4,#0x1a]
;;;148    rdy:  p_CB->events &= ~event_flags;
000032  bf00              NOP      
                  |L4.52|
000034  8b20              LDRH     r0,[r4,#0x18]
000036  43a8              BICS     r0,r0,r5
000038  8320              STRH     r0,[r4,#0x18]
;;;149          rt_rmv_dly (p_CB);
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       rt_rmv_dly
;;;150          p_CB->state   = READY;
000040  2001              MOVS     r0,#1
000042  7060              STRB     r0,[r4,#1]
;;;151          p_CB->ret_val = OS_R_EVT;
000044  2002              MOVS     r0,#2
000046  f8840025          STRB     r0,[r4,#0x25]
;;;152          rt_put_prio (&os_rdy, p_CB);
00004a  4621              MOV      r1,r4
00004c  4801              LDR      r0,|L4.84|
00004e  f7fffffe          BL       rt_put_prio
                  |L4.82|
;;;153        }
;;;154      }
;;;155    }
000052  bd70              POP      {r4-r6,pc}
;;;156    
                          ENDP

                  |L4.84|
                          DCD      os_rdy

                          AREA ||i.rt_evt_set||, CODE, READONLY, ALIGN=2

                  rt_evt_set PROC
;;;60     
;;;61     void rt_evt_set (U16 event_flags, OS_TID task_id) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;62       /* Set one or more event flags of a selectable task. */
;;;63       P_TCB p_tcb;
;;;64     
;;;65       p_tcb = os_active_TCB[task_id-1];
000006  1e70              SUBS     r0,r6,#1
000008  4917              LDR      r1,|L5.104|
00000a  f8514020          LDR      r4,[r1,r0,LSL #2]
;;;66       if (p_tcb == NULL) {
00000e  b904              CBNZ     r4,|L5.18|
                  |L5.16|
;;;67         return;
;;;68       }
;;;69       p_tcb->events |= event_flags;
;;;70       event_flags    = p_tcb->waits;
;;;71       /* If the task is not waiting for an event, it should not be put */
;;;72       /* to ready state. */
;;;73       if (p_tcb->state == WAIT_AND) {
;;;74         /* Check for AND-connected events */
;;;75         if ((p_tcb->events & event_flags) == event_flags) {
;;;76           goto wkup;
;;;77         }
;;;78       }
;;;79       if (p_tcb->state == WAIT_OR) {
;;;80         /* Check for OR-connected events */
;;;81         if (p_tcb->events & event_flags) {
;;;82           p_tcb->waits  &= p_tcb->events;
;;;83     wkup: p_tcb->events &= ~event_flags;
;;;84           rt_rmv_dly (p_tcb);
;;;85           p_tcb->events &= ~event_flags;
;;;86           p_tcb->state   = READY;
;;;87           p_tcb->ret_val = OS_R_EVT;
;;;88           rt_dispatch (p_tcb);
;;;89         }
;;;90       }
;;;91     }
000010  bd70              POP      {r4-r6,pc}
                  |L5.18|
000012  8b20              LDRH     r0,[r4,#0x18]         ;69
000014  4328              ORRS     r0,r0,r5              ;69
000016  8320              STRH     r0,[r4,#0x18]         ;69
000018  8b65              LDRH     r5,[r4,#0x1a]         ;70
00001a  7860              LDRB     r0,[r4,#1]            ;73
00001c  2806              CMP      r0,#6                 ;73
00001e  d104              BNE      |L5.42|
000020  8b20              LDRH     r0,[r4,#0x18]         ;75
000022  4028              ANDS     r0,r0,r5              ;75
000024  42a8              CMP      r0,r5                 ;75
000026  d100              BNE      |L5.42|
000028  e00a              B        |L5.64|
                  |L5.42|
00002a  7860              LDRB     r0,[r4,#1]            ;79
00002c  2805              CMP      r0,#5                 ;79
00002e  d118              BNE      |L5.98|
000030  8b20              LDRH     r0,[r4,#0x18]         ;81
000032  4028              ANDS     r0,r0,r5              ;81
000034  b1a8              CBZ      r0,|L5.98|
000036  8b60              LDRH     r0,[r4,#0x1a]         ;82
000038  8b21              LDRH     r1,[r4,#0x18]         ;82
00003a  4008              ANDS     r0,r0,r1              ;82
00003c  8360              STRH     r0,[r4,#0x1a]         ;82
00003e  bf00              NOP                            ;83
                  |L5.64|
000040  8b20              LDRH     r0,[r4,#0x18]         ;83
000042  43a8              BICS     r0,r0,r5              ;83
000044  8320              STRH     r0,[r4,#0x18]         ;83
000046  4620              MOV      r0,r4                 ;84
000048  f7fffffe          BL       rt_rmv_dly
00004c  8b20              LDRH     r0,[r4,#0x18]         ;85
00004e  43a8              BICS     r0,r0,r5              ;85
000050  8320              STRH     r0,[r4,#0x18]         ;85
000052  2001              MOVS     r0,#1                 ;86
000054  7060              STRB     r0,[r4,#1]            ;86
000056  2002              MOVS     r0,#2                 ;87
000058  f8840025          STRB     r0,[r4,#0x25]         ;87
00005c  4620              MOV      r0,r4                 ;88
00005e  f7fffffe          BL       rt_dispatch
                  |L5.98|
000062  bf00              NOP      
000064  e7d4              B        |L5.16|
;;;92     
                          ENDP

000066  0000              DCW      0x0000
                  |L5.104|
                          DCD      os_active_TCB

                          AREA ||i.rt_evt_wait||, CODE, READONLY, ALIGN=2

                  rt_evt_wait PROC
;;;26     
;;;27     OS_RESULT rt_evt_wait (U16 wait_flags, U16 timeout, BOOL and_wait) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;28       /* Wait for one or more event flags with optional time-out.                */
;;;29       /* "wait_flags" identifies the flags to wait for.                          */
;;;30       /* "timeout" is the time-out limit in system ticks (0xffff if no time-out) */
;;;31       /* "and_wait" specifies the AND-ing of "wait_flags" as condition to be met */
;;;32       /* to complete the wait. (OR-ing if set to 0).                             */
;;;33       U32 block_state;
;;;34     
;;;35       if (and_wait) {
00000a  b18f              CBZ      r7,|L6.48|
;;;36         /* Check for AND-connected events */
;;;37         if ((os_tsk.run->events & wait_flags) == wait_flags) {
00000c  4818              LDR      r0,|L6.112|
00000e  6800              LDR      r0,[r0,#0]  ; os_tsk
000010  8b00              LDRH     r0,[r0,#0x18]
000012  4020              ANDS     r0,r0,r4
000014  42a0              CMP      r0,r4
000016  d109              BNE      |L6.44|
;;;38           os_tsk.run->events &= ~wait_flags;
000018  4815              LDR      r0,|L6.112|
00001a  6800              LDR      r0,[r0,#0]  ; os_tsk
00001c  8b00              LDRH     r0,[r0,#0x18]
00001e  43a0              BICS     r0,r0,r4
000020  4913              LDR      r1,|L6.112|
000022  6809              LDR      r1,[r1,#0]  ; os_tsk
000024  8308              STRH     r0,[r1,#0x18]
;;;39           return (OS_R_EVT);
000026  2002              MOVS     r0,#2
                  |L6.40|
;;;40         }
;;;41         block_state = WAIT_AND;
;;;42       }
;;;43       else {
;;;44         /* Check for OR-connected events */
;;;45         if (os_tsk.run->events & wait_flags) {
;;;46           os_tsk.run->waits = os_tsk.run->events & wait_flags;
;;;47           os_tsk.run->events &= ~wait_flags;
;;;48           return (OS_R_EVT);
;;;49         }
;;;50         block_state = WAIT_OR;
;;;51       }
;;;52       /* Task has to wait */
;;;53       os_tsk.run->waits = wait_flags;
;;;54       rt_block (timeout, (U8)block_state);
;;;55       return (OS_R_TMO);
;;;56     }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L6.44|
00002c  2506              MOVS     r5,#6                 ;41
00002e  e015              B        |L6.92|
                  |L6.48|
000030  480f              LDR      r0,|L6.112|
000032  6800              LDR      r0,[r0,#0]            ;45  ; os_tsk
000034  8b00              LDRH     r0,[r0,#0x18]         ;45
000036  4020              ANDS     r0,r0,r4              ;45
000038  b178              CBZ      r0,|L6.90|
00003a  480d              LDR      r0,|L6.112|
00003c  6800              LDR      r0,[r0,#0]            ;46  ; os_tsk
00003e  8b00              LDRH     r0,[r0,#0x18]         ;46
000040  4020              ANDS     r0,r0,r4              ;46
000042  490b              LDR      r1,|L6.112|
000044  6809              LDR      r1,[r1,#0]            ;46  ; os_tsk
000046  8348              STRH     r0,[r1,#0x1a]         ;46
000048  4809              LDR      r0,|L6.112|
00004a  6800              LDR      r0,[r0,#0]            ;47  ; os_tsk
00004c  8b00              LDRH     r0,[r0,#0x18]         ;47
00004e  43a0              BICS     r0,r0,r4              ;47
000050  4907              LDR      r1,|L6.112|
000052  6809              LDR      r1,[r1,#0]            ;47  ; os_tsk
000054  8308              STRH     r0,[r1,#0x18]         ;47
000056  2002              MOVS     r0,#2                 ;48
000058  e7e6              B        |L6.40|
                  |L6.90|
00005a  2505              MOVS     r5,#5                 ;50
                  |L6.92|
00005c  4804              LDR      r0,|L6.112|
00005e  6800              LDR      r0,[r0,#0]            ;53  ; os_tsk
000060  8344              STRH     r4,[r0,#0x1a]         ;53
000062  b2e9              UXTB     r1,r5                 ;54
000064  4630              MOV      r0,r6                 ;54
000066  f7fffffe          BL       rt_block
00006a  2001              MOVS     r0,#1                 ;55
00006c  e7dc              B        |L6.40|
;;;57     
                          ENDP

00006e  0000              DCW      0x0000
                  |L6.112|
                          DCD      os_tsk
