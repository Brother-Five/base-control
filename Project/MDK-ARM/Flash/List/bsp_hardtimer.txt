; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_hardtimer.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_hardtimer.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -I..\..\RTX\inc -I..\..\RTX\portable -I..\..\MySrc -I..\..\Libraries -I..\..\MySrc\ostask -I..\..\MySrc\MPU6050 -D__MICROLIB -D__UVISION_VERSION=514 -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DARM_MATH_CM4 -DSTM32F40_41xxx --omf_browse=.\flash\obj\bsp_hardtimer.crf ..\..\User\bsp_stm32f4xx\src\bsp_hardtimer.c]
                          THUMB

                          AREA ||i.ConfigTIMNVIC||, CODE, READONLY, ALIGN=1

                  ConfigTIMNVIC PROC
;;;200    */
;;;201    static void ConfigTIMNVIC(void)
000000  b508              PUSH     {r3,lr}
;;;202    {
;;;203        NVIC_InitTypeDef NVIC_InitStructure;
;;;204    
;;;205        /* Configure the NVIC Preemption Priority Bits */
;;;206        /*  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);  --- 在 bsp.c 中 bsp_Init() 中配置中断优先级组 */
;;;207    
;;;208    #ifdef USE_TIM2
;;;209        /* 使能TIM2中断 */
;;;210        NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;
;;;211        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = Priority_TIM2_Pre;
;;;212        NVIC_InitStructure.NVIC_IRQChannelSubPriority        = Priority_TIM2_Sub;
;;;213        NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;214        NVIC_Init(&NVIC_InitStructure);
;;;215    #endif
;;;216    
;;;217    #ifdef USE_TIM3
;;;218        /* 使能TIM3中断 */
;;;219        NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;
000002  201d              MOVS     r0,#0x1d
000004  f88d0000          STRB     r0,[sp,#0]
;;;220        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = Priority_TIM3_Pre;
000008  2000              MOVS     r0,#0
00000a  f88d0001          STRB     r0,[sp,#1]
;;;221        NVIC_InitStructure.NVIC_IRQChannelSubPriority        = Priority_TIM3_Sub;
00000e  2003              MOVS     r0,#3
000010  f88d0002          STRB     r0,[sp,#2]
;;;222        NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000014  2001              MOVS     r0,#1
000016  f88d0003          STRB     r0,[sp,#3]
;;;223        NVIC_Init(&NVIC_InitStructure);
00001a  4668              MOV      r0,sp
00001c  f7fffffe          BL       NVIC_Init
;;;224    #endif
;;;225    
;;;226    #ifdef USE_TIM4
;;;227        /* 使能TIM4中断t */
;;;228        NVIC_InitStructure.NVIC_IRQChannel = TIM4_IRQn;
;;;229        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = Priority_TIM4_Pre;
;;;230        NVIC_InitStructure.NVIC_IRQChannelSubPriority        = Priority_TIM4_Sub;
;;;231        NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;232        NVIC_Init(&NVIC_InitStructure);
;;;233    #endif
;;;234    
;;;235    #ifdef USE_TIM5
;;;236        /* 使能TIM5中断t */
;;;237        NVIC_InitStructure.NVIC_IRQChannel = TIM5_IRQn;
;;;238        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = Priority_TIM5_Pre;
;;;239        NVIC_InitStructure.NVIC_IRQChannelSubPriority        = Priority_TIM5_Sub;
;;;240        NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;241        NVIC_Init(&NVIC_InitStructure);
;;;242    #endif
;;;243    }
000020  bd08              POP      {r3,pc}
;;;244    /*
                          ENDP


                          AREA ||i.InitHardTIM||, CODE, READONLY, ALIGN=2

                  InitHardTIM PROC
;;;125    */
;;;126    void InitHardTIM(void)
000000  b50e              PUSH     {r1-r3,lr}
;;;127    {
;;;128        TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;129    
;;;130        /* 使能TIM时钟 */
;;;131        // #ifdef (USE_TIM2||USE_TIM3||USE_TIM4||USE_TIM5||USE_TIM6||USE_TIM7||USE_TIM13||USE_TIM14)
;;;132    
;;;133    
;;;134    
;;;135        /*-----------------------------------------------------------------------
;;;136            system_stm32f4xx.c 文件中 void SetSysClock(void) 函数对时钟的配置如下：
;;;137    
;;;138            HCLK = SYSCLK / 1     (AHB1Periph)
;;;139            PCLK2 = HCLK / 2      (APB2Periph)
;;;140            PCLK1 = HCLK / 4      (APB1Periph)
;;;141    
;;;142            因为APB1 prescaler != 1, 所以 APB1上的TIMxCLK = PCLK1 x 2 = SystemCoreClock / 2;
;;;143            因为APB2 prescaler != 1, 所以 APB2上的TIMxCLK = PCLK2 x 2 = SystemCoreClock;
;;;144    
;;;145            APB1 定时器有 TIM2, TIM3 ,TIM4, TIM5, TIM6, TIM7, TIM12, TIM13,TIM14
;;;146            APB2 定时器有 TIM1, TIM8 ,TIM9, TIM10, TIM11
;;;147    
;;;148        ----------------------------------------------------------------------- */
;;;149    #ifdef USE_TIM2
;;;150        RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
;;;151        /* Time base configuration */
;;;152        TIM_TimeBaseStructure.TIM_Period = TIM2_Period;
;;;153        TIM_TimeBaseStructure.TIM_Prescaler = TIM2_Prescaler;
;;;154        TIM_TimeBaseStructure.TIM_ClockDivision = 0;
;;;155        TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
;;;156        TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
;;;157        TIM_Cmd(TIM2, ENABLE);/* TIMx enable counter */
;;;158    #endif
;;;159    
;;;160    #ifdef USE_TIM3
;;;161        RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
000002  2101              MOVS     r1,#1
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;162        /* Time base configuration */
;;;163        TIM_TimeBaseStructure.TIM_Period = TIM3_Period;
00000a  f64f70ff          MOV      r0,#0xffff
00000e  9001              STR      r0,[sp,#4]
;;;164        TIM_TimeBaseStructure.TIM_Prescaler = TIM3_Prescaler;
000010  2053              MOVS     r0,#0x53
000012  f8ad0000          STRH     r0,[sp,#0]
;;;165        TIM_TimeBaseStructure.TIM_ClockDivision = 0;
000016  2000              MOVS     r0,#0
000018  f8ad0008          STRH     r0,[sp,#8]
;;;166        TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
00001c  f8ad0002          STRH     r0,[sp,#2]
;;;167        TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
000020  4669              MOV      r1,sp
000022  4804              LDR      r0,|L2.52|
000024  f7fffffe          BL       TIM_TimeBaseInit
;;;168        TIM_Cmd(TIM3, ENABLE);/* TIMx enable counter */
000028  2101              MOVS     r1,#1
00002a  4802              LDR      r0,|L2.52|
00002c  f7fffffe          BL       TIM_Cmd
;;;169    #endif
;;;170    
;;;171    #ifdef USE_TIM4
;;;172        RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);
;;;173        /* Time base configuration */
;;;174        TIM_TimeBaseStructure.TIM_Period = TIM4_Period;
;;;175        TIM_TimeBaseStructure.TIM_Prescaler = TIM4_Prescaler;
;;;176        TIM_TimeBaseStructure.TIM_ClockDivision = 0;
;;;177        TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
;;;178        TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure);
;;;179        TIM_Cmd(TIM4, ENABLE);/* TIMx enable counter */
;;;180    #endif
;;;181    
;;;182    #ifdef USE_TIM5
;;;183        RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM5, ENABLE);
;;;184        /* Time base configuration */
;;;185        TIM_TimeBaseStructure.TIM_Period = TIM5_Period;
;;;186        TIM_TimeBaseStructure.TIM_Prescaler = TIM5_Prescaler;
;;;187        TIM_TimeBaseStructure.TIM_ClockDivision = 0;
;;;188        TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
;;;189        TIM_TimeBaseInit(TIM5, &TIM_TimeBaseStructure);
;;;190        TIM_Cmd(TIM5, ENABLE);/* TIMx enable counter */
;;;191    #endif
;;;192    }
000030  bd0e              POP      {r1-r3,pc}
;;;193    
                          ENDP

000032  0000              DCW      0x0000
                  |L2.52|
                          DCD      0x40000400

                          AREA ||i.TIM1_UP_TIM10_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM1_UP_TIM10_IRQHandler PROC
;;;581    //定时器3中断服务函数
;;;582    void TIM1_UP_TIM10_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;583    {
;;;584        if(TIM_GetITStatus(TIM1,TIM_IT_Update)==SET) //溢出中断
000002  2101              MOVS     r1,#1
000004  4806              LDR      r0,|L3.32|
000006  f7fffffe          BL       TIM_GetITStatus
00000a  2801              CMP      r0,#1
00000c  d102              BNE      |L3.20|
;;;585        {
;;;586    		s_TIM1_CallBack();
00000e  4805              LDR      r0,|L3.36|
000010  6800              LDR      r0,[r0,#0]  ; s_TIM1_CallBack
000012  4780              BLX      r0
                  |L3.20|
;;;587        }
;;;588        TIM_ClearITPendingBit(TIM1,TIM_IT_Update);  //清除中断标志位
000014  2101              MOVS     r1,#1
000016  4802              LDR      r0,|L3.32|
000018  f7fffffe          BL       TIM_ClearITPendingBit
;;;589    }
00001c  bd10              POP      {r4,pc}
;;;590    
                          ENDP

00001e  0000              DCW      0x0000
                  |L3.32|
                          DCD      0x40010000
                  |L3.36|
                          DCD      s_TIM1_CallBack

                          AREA ||i.TIM1_timer||, CODE, READONLY, ALIGN=2

                  TIM1_timer PROC
;;;551    static void (*s_TIM1_CallBack)(void);
;;;552    void TIM1_timer(uint32_t _uiTimeOut, void * _pCallBack){
000000  b57f              PUSH     {r0-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;553    
;;;554        TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
;;;555        NVIC_InitTypeDef NVIC_InitStructure;
;;;556    
;;;557    	s_TIM1_CallBack = (void (*)(void))_pCallBack;
000006  4816              LDR      r0,|L4.96|
000008  6005              STR      r5,[r0,#0]  ; s_TIM1_CallBack
;;;558    	
;;;559    	
;;;560    	
;;;561        RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1,ENABLE);  ///使能TIM1时钟
00000a  2101              MOVS     r1,#1
00000c  4608              MOV      r0,r1
00000e  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;562    
;;;563        TIM_TimeBaseInitStructure.TIM_Period = _uiTimeOut;     //自动重装载值
000012  9402              STR      r4,[sp,#8]
;;;564        TIM_TimeBaseInitStructure.TIM_Prescaler= 168-1;  //分出 1M 的时钟 保证每个周期为1us
000014  20a7              MOVS     r0,#0xa7
000016  f8ad0004          STRH     r0,[sp,#4]
;;;565        TIM_TimeBaseInitStructure.TIM_CounterMode=TIM_CounterMode_Up; //向上计数模式
00001a  2000              MOVS     r0,#0
00001c  f8ad0006          STRH     r0,[sp,#6]
;;;566        TIM_TimeBaseInitStructure.TIM_ClockDivision=TIM_CKD_DIV1;
000020  f8ad000c          STRH     r0,[sp,#0xc]
;;;567        TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;
000024  f88d000e          STRB     r0,[sp,#0xe]
;;;568        TIM_TimeBaseInit(TIM1,&TIM_TimeBaseInitStructure);//初始化TIM1
000028  a901              ADD      r1,sp,#4
00002a  480e              LDR      r0,|L4.100|
00002c  f7fffffe          BL       TIM_TimeBaseInit
;;;569    
;;;570        TIM_ITConfig(TIM1,TIM_IT_Update,ENABLE); //允许定时器1更新中断
000030  2201              MOVS     r2,#1
000032  4611              MOV      r1,r2
000034  480b              LDR      r0,|L4.100|
000036  f7fffffe          BL       TIM_ITConfig
;;;571        TIM_Cmd(TIM1,ENABLE); //使能定时器1
00003a  2101              MOVS     r1,#1
00003c  4809              LDR      r0,|L4.100|
00003e  f7fffffe          BL       TIM_Cmd
;;;572    
;;;573        NVIC_InitStructure.NVIC_IRQChannel=TIM1_UP_TIM10_IRQn; //定时器3中断
000042  2019              MOVS     r0,#0x19
000044  f88d0000          STRB     r0,[sp,#0]
;;;574        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=0x01; //抢占优先级1
000048  2001              MOVS     r0,#1
00004a  f88d0001          STRB     r0,[sp,#1]
;;;575        NVIC_InitStructure.NVIC_IRQChannelSubPriority=0x01; //子优先级3
00004e  f88d0002          STRB     r0,[sp,#2]
;;;576        NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;
000052  f88d0003          STRB     r0,[sp,#3]
;;;577        NVIC_Init(&NVIC_InitStructure);
000056  4668              MOV      r0,sp
000058  f7fffffe          BL       NVIC_Init
;;;578    	
;;;579    //	s_TIM1_CallBack = (void (*)(void))_pCallBack;
;;;580    }
00005c  bd7f              POP      {r0-r6,pc}
;;;581    //定时器3中断服务函数
                          ENDP

00005e  0000              DCW      0x0000
                  |L4.96|
                          DCD      s_TIM1_CallBack
                  |L4.100|
                          DCD      0x40010000

                          AREA ||i.TIM3_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM3_IRQHandler PROC
;;;390    #ifdef USE_TIM3
;;;391    void TIM3_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;392    {
;;;393        if (TIM_GetITStatus(TIM3, TIM_IT_CC1))
000002  2102              MOVS     r1,#2
000004  483d              LDR      r0,|L5.252|
000006  f7fffffe          BL       TIM_GetITStatus
00000a  b1c8              CBZ      r0,|L5.64|
;;;394        {
;;;395            TIM_ClearITPendingBit(TIM3, TIM_IT_CC1);
00000c  2102              MOVS     r1,#2
00000e  483b              LDR      r0,|L5.252|
000010  f7fffffe          BL       TIM_ClearITPendingBit
;;;396           if(g_tTIM3._uMode[0])
000014  483a              LDR      r0,|L5.256|
000016  6900              LDR      r0,[r0,#0x10]  ; g_tTIM3
000018  b128              CBZ      r0,|L5.38|
;;;397               TIM_ITConfig(TIM3, TIM_IT_CC1, DISABLE); /* 禁能CC1中断 */
00001a  2200              MOVS     r2,#0
00001c  2102              MOVS     r1,#2
00001e  4837              LDR      r0,|L5.252|
000020  f7fffffe          BL       TIM_ITConfig
000024  e009              B        |L5.58|
                  |L5.38|
;;;398           else
;;;399                TIM_SetCompare1(TIM3,TIM_GetCounter(TIM3) + g_tTIM3._uTimeOut[0]);
000026  4835              LDR      r0,|L5.252|
000028  f7fffffe          BL       TIM_GetCounter
00002c  4934              LDR      r1,|L5.256|
00002e  6809              LDR      r1,[r1,#0]  ; g_tTIM3
000030  1844              ADDS     r4,r0,r1
000032  4621              MOV      r1,r4
000034  4831              LDR      r0,|L5.252|
000036  f7fffffe          BL       TIM_SetCompare1
                  |L5.58|
;;;400            /* 先关闭中断，再执行回调函数。因为回调函数可能需要重启定时器 */
;;;401    //      TIM_SetCounter(TIM3, 0);
;;;402            g_tTIM3.s_TIM_CallBack1();
00003a  4931              LDR      r1,|L5.256|
00003c  6a88              LDR      r0,[r1,#0x28]  ; g_tTIM3
00003e  4780              BLX      r0
                  |L5.64|
;;;403        }
;;;404    
;;;405        if (TIM_GetITStatus(TIM3, TIM_IT_CC2))
000040  2104              MOVS     r1,#4
000042  482e              LDR      r0,|L5.252|
000044  f7fffffe          BL       TIM_GetITStatus
000048  b1c8              CBZ      r0,|L5.126|
;;;406        {
;;;407            TIM_ClearITPendingBit(TIM3, TIM_IT_CC2);
00004a  2104              MOVS     r1,#4
00004c  482b              LDR      r0,|L5.252|
00004e  f7fffffe          BL       TIM_ClearITPendingBit
;;;408            if(g_tTIM3._uMode[1])
000052  482b              LDR      r0,|L5.256|
000054  6940              LDR      r0,[r0,#0x14]
000056  b128              CBZ      r0,|L5.100|
;;;409               TIM_ITConfig(TIM3, TIM_IT_CC2, DISABLE); /* 禁能CC2中断 */
000058  2200              MOVS     r2,#0
00005a  2104              MOVS     r1,#4
00005c  4827              LDR      r0,|L5.252|
00005e  f7fffffe          BL       TIM_ITConfig
000062  e009              B        |L5.120|
                  |L5.100|
;;;410            else
;;;411                TIM_SetCompare2(TIM3,TIM_GetCounter(TIM3) + g_tTIM3._uTimeOut[1]);
000064  4825              LDR      r0,|L5.252|
000066  f7fffffe          BL       TIM_GetCounter
00006a  4925              LDR      r1,|L5.256|
00006c  6849              LDR      r1,[r1,#4]  ; g_tTIM3
00006e  1844              ADDS     r4,r0,r1
000070  4621              MOV      r1,r4
000072  4822              LDR      r0,|L5.252|
000074  f7fffffe          BL       TIM_SetCompare2
                  |L5.120|
;;;412    
;;;413            /* 先关闭中断，再执行回调函数。因为回调函数可能需要重启定时器 */
;;;414            g_tTIM3.s_TIM_CallBack2();
000078  4921              LDR      r1,|L5.256|
00007a  6ac8              LDR      r0,[r1,#0x2c]  ; g_tTIM3
00007c  4780              BLX      r0
                  |L5.126|
;;;415        }
;;;416    
;;;417        if (TIM_GetITStatus(TIM3, TIM_IT_CC3))
00007e  2108              MOVS     r1,#8
000080  481e              LDR      r0,|L5.252|
000082  f7fffffe          BL       TIM_GetITStatus
000086  b1c8              CBZ      r0,|L5.188|
;;;418        {
;;;419            TIM_ClearITPendingBit(TIM3, TIM_IT_CC3);
000088  2108              MOVS     r1,#8
00008a  481c              LDR      r0,|L5.252|
00008c  f7fffffe          BL       TIM_ClearITPendingBit
;;;420            if(g_tTIM3._uMode[2])
000090  481b              LDR      r0,|L5.256|
000092  6980              LDR      r0,[r0,#0x18]
000094  b128              CBZ      r0,|L5.162|
;;;421               TIM_ITConfig(TIM3, TIM_IT_CC3, DISABLE); /* 禁能CC3中断 */
000096  2200              MOVS     r2,#0
000098  2108              MOVS     r1,#8
00009a  4818              LDR      r0,|L5.252|
00009c  f7fffffe          BL       TIM_ITConfig
0000a0  e009              B        |L5.182|
                  |L5.162|
;;;422            else
;;;423                TIM_SetCompare3(TIM3,TIM_GetCounter(TIM3) + g_tTIM3._uTimeOut[2]);
0000a2  4816              LDR      r0,|L5.252|
0000a4  f7fffffe          BL       TIM_GetCounter
0000a8  4915              LDR      r1,|L5.256|
0000aa  6889              LDR      r1,[r1,#8]  ; g_tTIM3
0000ac  1844              ADDS     r4,r0,r1
0000ae  4621              MOV      r1,r4
0000b0  4812              LDR      r0,|L5.252|
0000b2  f7fffffe          BL       TIM_SetCompare3
                  |L5.182|
;;;424    
;;;425            /* 先关闭中断，再执行回调函数。因为回调函数可能需要重启定时器 */
;;;426           g_tTIM3.s_TIM_CallBack3();
0000b6  4912              LDR      r1,|L5.256|
0000b8  6b08              LDR      r0,[r1,#0x30]  ; g_tTIM3
0000ba  4780              BLX      r0
                  |L5.188|
;;;427        }
;;;428    
;;;429        if (TIM_GetITStatus(TIM3, TIM_IT_CC4))
0000bc  2110              MOVS     r1,#0x10
0000be  480f              LDR      r0,|L5.252|
0000c0  f7fffffe          BL       TIM_GetITStatus
0000c4  b1c8              CBZ      r0,|L5.250|
;;;430        {
;;;431            TIM_ClearITPendingBit(TIM3, TIM_IT_CC4);
0000c6  2110              MOVS     r1,#0x10
0000c8  480c              LDR      r0,|L5.252|
0000ca  f7fffffe          BL       TIM_ClearITPendingBit
;;;432            if(g_tTIM3._uMode[3])
0000ce  480c              LDR      r0,|L5.256|
0000d0  69c0              LDR      r0,[r0,#0x1c]
0000d2  b128              CBZ      r0,|L5.224|
;;;433               TIM_ITConfig(TIM3, TIM_IT_CC4, DISABLE); /* 禁能CC4中断 */
0000d4  2200              MOVS     r2,#0
0000d6  2110              MOVS     r1,#0x10
0000d8  4808              LDR      r0,|L5.252|
0000da  f7fffffe          BL       TIM_ITConfig
0000de  e009              B        |L5.244|
                  |L5.224|
;;;434            else
;;;435                TIM_SetCompare4(TIM3,TIM_GetCounter(TIM3) + g_tTIM3._uTimeOut[3]);
0000e0  4806              LDR      r0,|L5.252|
0000e2  f7fffffe          BL       TIM_GetCounter
0000e6  4906              LDR      r1,|L5.256|
0000e8  68c9              LDR      r1,[r1,#0xc]  ; g_tTIM3
0000ea  1844              ADDS     r4,r0,r1
0000ec  4621              MOV      r1,r4
0000ee  4803              LDR      r0,|L5.252|
0000f0  f7fffffe          BL       TIM_SetCompare4
                  |L5.244|
;;;436    
;;;437            /* 先关闭中断，再执行回调函数。因为回调函数可能需要重启定时器 */
;;;438            g_tTIM3.s_TIM_CallBack4();
0000f4  4902              LDR      r1,|L5.256|
0000f6  6b48              LDR      r0,[r1,#0x34]  ; g_tTIM3
0000f8  4780              BLX      r0
                  |L5.250|
;;;439        }
;;;440    }
0000fa  bd10              POP      {r4,pc}
;;;441    #endif
                          ENDP

                  |L5.252|
                          DCD      0x40000400
                  |L5.256|
                          DCD      g_tTIM3

                          AREA ||i.TIMVarInit||, CODE, READONLY, ALIGN=2

                  TIMVarInit PROC
;;;40     */
;;;41     void TIMVarInit(void)
000000  2001              MOVS     r0,#1
;;;42     {
;;;43     #ifdef USE_TIM2
;;;44         g_tTIM2._uMode[0]          = ONCE_MODE;
;;;45         g_tTIM2._uMode[1]          = ONCE_MODE;
;;;46         g_tTIM2._uMode[2]          = ONCE_MODE;
;;;47         g_tTIM2._uMode[3]          = ONCE_MODE;
;;;48         g_tTIM2._Prescaler     = 84 - 1;                  /*1us */
;;;49         g_tTIM2._Period        = 0xFFFFFFFF;              /* 最大 */
;;;50         g_tTIM2._uTimeOut[0]    = 0;
;;;51         g_tTIM2._uTimeOut[1]    = 0;
;;;52         g_tTIM2._uTimeOut[2]    = 0;
;;;53         g_tTIM2._uTimeOut[3]    = 0;
;;;54     
;;;55         g_tTIM2.s_TIM_CallBack1 = 0;
;;;56         g_tTIM2.s_TIM_CallBack2 = 0;
;;;57         g_tTIM2.s_TIM_CallBack3 = 0;
;;;58         g_tTIM2.s_TIM_CallBack4 = 0;
;;;59     #endif
;;;60     
;;;61     #ifdef USE_TIM3
;;;62         g_tTIM3._uMode[0]          = ONCE_MODE;
000002  490b              LDR      r1,|L6.48|
000004  6108              STR      r0,[r1,#0x10]  ; g_tTIM3
;;;63         g_tTIM3._uMode[1]          = ONCE_MODE;
000006  2101              MOVS     r1,#1
000008  4809              LDR      r0,|L6.48|
00000a  6141              STR      r1,[r0,#0x14]
;;;64         g_tTIM3._uMode[2]          = ONCE_MODE;
00000c  6181              STR      r1,[r0,#0x18]
;;;65         g_tTIM3._uMode[3]          = ONCE_MODE;
00000e  61c1              STR      r1,[r0,#0x1c]
;;;66         g_tTIM3._Prescaler     = 84 - 1;                  /*1us */
000010  2053              MOVS     r0,#0x53
000012  4907              LDR      r1,|L6.48|
000014  6208              STR      r0,[r1,#0x20]  ; g_tTIM3
;;;67         g_tTIM3._Period        = 0xFFFF;              /* 最大 */
000016  f64f70ff          MOV      r0,#0xffff
00001a  6248              STR      r0,[r1,#0x24]  ; g_tTIM3
;;;68         g_tTIM3._uTimeOut[0]    = 0;
00001c  2000              MOVS     r0,#0
00001e  6008              STR      r0,[r1,#0]  ; g_tTIM3
;;;69         g_tTIM3._uTimeOut[1]    = 0;
000020  6048              STR      r0,[r1,#4]  ; g_tTIM3
;;;70         g_tTIM3._uTimeOut[2]    = 0;
000022  6088              STR      r0,[r1,#8]  ; g_tTIM3
;;;71         g_tTIM3._uTimeOut[3]    = 0;
000024  60c8              STR      r0,[r1,#0xc]  ; g_tTIM3
;;;72     
;;;73         g_tTIM3.s_TIM_CallBack1 = 0;
000026  6288              STR      r0,[r1,#0x28]  ; g_tTIM3
;;;74         g_tTIM3.s_TIM_CallBack2 = 0;
000028  62c8              STR      r0,[r1,#0x2c]  ; g_tTIM3
;;;75         g_tTIM3.s_TIM_CallBack3 = 0;
00002a  6308              STR      r0,[r1,#0x30]  ; g_tTIM3
;;;76         g_tTIM3.s_TIM_CallBack4 = 0;
00002c  6348              STR      r0,[r1,#0x34]  ; g_tTIM3
;;;77     #endif
;;;78     
;;;79     #ifdef USE_TIM4
;;;80         g_tTIM4._uMode[0]          = ONCE_MODE;
;;;81         g_tTIM4._uMode[1]          = ONCE_MODE;
;;;82         g_tTIM4._uMode[2]          = ONCE_MODE;
;;;83         g_tTIM4._uMode[3]          = ONCE_MODE;
;;;84         g_tTIM4._Prescaler     = 84 - 1;                  /*1us */
;;;85         g_tTIM4._Period        = 0xFFFF;              /* 最大 */
;;;86         g_tTIM4._uTimeOut[0]    = 0;
;;;87         g_tTIM4._uTimeOut[1]    = 0;
;;;88         g_tTIM4._uTimeOut[2]    = 0;
;;;89         g_tTIM4._uTimeOut[3]    = 0;
;;;90     
;;;91         g_tTIM4.s_TIM_CallBack1 = 0;
;;;92         g_tTIM4.s_TIM_CallBack2 = 0;
;;;93         g_tTIM4.s_TIM_CallBack3 = 0;
;;;94         g_tTIM4.s_TIM_CallBack4 = 0;
;;;95     #endif
;;;96     
;;;97     #ifdef USE_TIM5
;;;98         g_tTIM5._uMode[0]       = ONCE_MODE;
;;;99         g_tTIM5._uMode[1]       = ONCE_MODE;
;;;100        g_tTIM5._uMode[2]       = ONCE_MODE;
;;;101        g_tTIM5._uMode[3]       = ONCE_MODE;
;;;102        g_tTIM5._Prescaler     = TIM5_Prescaler;                  /*1us */
;;;103        g_tTIM5._Period        = TIM5_Period;              /* 最大 */
;;;104        g_tTIM5._uTimeOut[0]    = 0;
;;;105        g_tTIM5._uTimeOut[1]    = 0;
;;;106        g_tTIM5._uTimeOut[2]    = 0;
;;;107        g_tTIM5._uTimeOut[3]    = 0;
;;;108    
;;;109        g_tTIM5.s_TIM_CallBack1 = 0;
;;;110        g_tTIM5.s_TIM_CallBack2 = 0;
;;;111        g_tTIM5.s_TIM_CallBack3 = 0;
;;;112        g_tTIM5.s_TIM_CallBack4 = 0;
;;;113    
;;;114    #endif
;;;115    }
00002e  4770              BX       lr
;;;116    
                          ENDP

                  |L6.48|
                          DCD      g_tTIM3

                          AREA ||i.bsp_InitHardTimer||, CODE, READONLY, ALIGN=1

                  bsp_InitHardTimer PROC
;;;26     
;;;27     void bsp_InitHardTimer(void)
000000  b510              PUSH     {r4,lr}
;;;28     {
;;;29         TIMVarInit();
000002  f7fffffe          BL       TIMVarInit
;;;30         InitHardTIM();
000006  f7fffffe          BL       InitHardTIM
;;;31         ConfigTIMNVIC();
00000a  f7fffffe          BL       ConfigTIMNVIC
;;;32     }
00000e  bd10              POP      {r4,pc}
;;;33     /*
                          ENDP


                          AREA ||i.bsp_StartHardTimer||, CODE, READONLY, ALIGN=2

                  bsp_StartHardTimer PROC
;;;256    */
;;;257    void bsp_StartHardTimer(TIM_TypeDef *TIMx,uint8_t _CC, uint32_t _uiTimeOut, void * _pCallBack,MODE_T _mode)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;258    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4690              MOV      r8,r2
00000a  461e              MOV      r6,r3
00000c  f8dd9020          LDR      r9,[sp,#0x20]
;;;259        TIM_T *T;
;;;260        switch ((uint32_t)TIMx)
000010  4830              LDR      r0,|L8.212|
000012  4438              ADD      r0,r0,r7
000014  b908              CBNZ     r0,|L8.26|
;;;261        {
;;;262    
;;;263    #ifdef USE_TIM2
;;;264            case (uint32_t)TIM2: T = &g_tTIM2;break;
;;;265    #endif
;;;266    
;;;267    #ifdef USE_TIM3
;;;268            case (uint32_t)TIM3: T = &g_tTIM3;break;
000016  4d30              LDR      r5,|L8.216|
000018  e003              B        |L8.34|
                  |L8.26|
;;;269    #endif
;;;270    
;;;271    #ifdef USE_TIM4
;;;272            case (uint32_t)TIM4: T = &g_tTIM4;break;
;;;273    #endif
;;;274    
;;;275    #ifdef USE_TIM5
;;;276            case (uint32_t)TIM5: T = &g_tTIM5;break;
;;;277    #endif
;;;278    		default:printf("有TIM未开启却被使用\r\n");
00001a  a030              ADR      r0,|L8.220|
00001c  f7fffffe          BL       __2printf
000020  bf00              NOP                            ;260
                  |L8.34|
000022  bf00              NOP                            ;268
;;;279        }
;;;280    
;;;281        T->_uTimeOut[_CC -1] = TIM_GetCounter(TIMx) + _uiTimeOut;
000024  4638              MOV      r0,r7
000026  f7fffffe          BL       TIM_GetCounter
00002a  eb000108          ADD      r1,r0,r8
00002e  1e60              SUBS     r0,r4,#1
000030  f8451020          STR      r1,[r5,r0,LSL #2]
;;;282        T->_uMode[_CC -1]    = _mode;
000034  f1050110          ADD      r1,r5,#0x10
000038  f8419020          STR      r9,[r1,r0,LSL #2]
;;;283        if (_CC == 1)
00003c  2c01              CMP      r4,#1
00003e  d10f              BNE      |L8.96|
;;;284        {
;;;285    
;;;286            T->s_TIM_CallBack1 = (void (*)(void))_pCallBack;
000040  62ae              STR      r6,[r5,#0x28]
;;;287    
;;;288            TIM_SetCompare1(TIMx, T->_uTimeOut[_CC -1]);      	/* 设置捕获比较计数器CC1 */
000042  f8551020          LDR      r1,[r5,r0,LSL #2]
000046  4638              MOV      r0,r7
000048  f7fffffe          BL       TIM_SetCompare1
;;;289            TIM_ClearITPendingBit(TIMx, TIM_IT_CC1);
00004c  2102              MOVS     r1,#2
00004e  4638              MOV      r0,r7
000050  f7fffffe          BL       TIM_ClearITPendingBit
;;;290    		TIM_ITConfig(TIMx, TIM_IT_CC1, ENABLE);	/* 使能CC1中断 */
000054  2201              MOVS     r2,#1
000056  2102              MOVS     r1,#2
000058  4638              MOV      r0,r7
00005a  f7fffffe          BL       TIM_ITConfig
00005e  e037              B        |L8.208|
                  |L8.96|
;;;291    
;;;292        }
;;;293        else if (_CC == 2)
000060  2c02              CMP      r4,#2
000062  d110              BNE      |L8.134|
;;;294        {
;;;295    
;;;296    		T->s_TIM_CallBack2 = (void (*)(void))_pCallBack;
000064  62ee              STR      r6,[r5,#0x2c]
;;;297    
;;;298            TIM_SetCompare2(TIMx, T->_uTimeOut[_CC -1]);      	/* 设置捕获比较计数器CC2 */
000066  1e60              SUBS     r0,r4,#1
000068  f8551020          LDR      r1,[r5,r0,LSL #2]
00006c  4638              MOV      r0,r7
00006e  f7fffffe          BL       TIM_SetCompare2
;;;299    		TIM_ClearITPendingBit(TIMx, TIM_IT_CC2);
000072  2104              MOVS     r1,#4
000074  4638              MOV      r0,r7
000076  f7fffffe          BL       TIM_ClearITPendingBit
;;;300    		TIM_ITConfig(TIMx, TIM_IT_CC2, ENABLE);	/* 使能CC2中断 */
00007a  2201              MOVS     r2,#1
00007c  2104              MOVS     r1,#4
00007e  4638              MOV      r0,r7
000080  f7fffffe          BL       TIM_ITConfig
000084  e024              B        |L8.208|
                  |L8.134|
;;;301        }
;;;302        else if (_CC == 3)
000086  2c03              CMP      r4,#3
000088  d110              BNE      |L8.172|
;;;303        {
;;;304    
;;;305            T->s_TIM_CallBack3 = (void (*)(void))_pCallBack;
00008a  632e              STR      r6,[r5,#0x30]
;;;306    
;;;307            TIM_SetCompare3(TIMx, T->_uTimeOut[_CC -1]);      	/* 设置捕获比较计数器CC3 */
00008c  1e60              SUBS     r0,r4,#1
00008e  f8551020          LDR      r1,[r5,r0,LSL #2]
000092  4638              MOV      r0,r7
000094  f7fffffe          BL       TIM_SetCompare3
;;;308            TIM_ClearITPendingBit(TIMx, TIM_IT_CC3);
000098  2108              MOVS     r1,#8
00009a  4638              MOV      r0,r7
00009c  f7fffffe          BL       TIM_ClearITPendingBit
;;;309    		TIM_ITConfig(TIMx, TIM_IT_CC3, ENABLE);	/* 使能CC3中断 */
0000a0  2201              MOVS     r2,#1
0000a2  2108              MOVS     r1,#8
0000a4  4638              MOV      r0,r7
0000a6  f7fffffe          BL       TIM_ITConfig
0000aa  e011              B        |L8.208|
                  |L8.172|
;;;310        }
;;;311        else if (_CC == 4)
0000ac  2c04              CMP      r4,#4
0000ae  d10f              BNE      |L8.208|
;;;312        {
;;;313    
;;;314            T->s_TIM_CallBack4 = (void (*)(void))_pCallBack;
0000b0  636e              STR      r6,[r5,#0x34]
;;;315    
;;;316            TIM_SetCompare4(TIMx, T->_uTimeOut[_CC -1]);      	/* 设置捕获比较计数器CC4 */
0000b2  1e60              SUBS     r0,r4,#1
0000b4  f8551020          LDR      r1,[r5,r0,LSL #2]
0000b8  4638              MOV      r0,r7
0000ba  f7fffffe          BL       TIM_SetCompare4
;;;317    		TIM_ClearITPendingBit(TIMx, TIM_IT_CC4);
0000be  2110              MOVS     r1,#0x10
0000c0  4638              MOV      r0,r7
0000c2  f7fffffe          BL       TIM_ClearITPendingBit
;;;318    		TIM_ITConfig(TIMx, TIM_IT_CC4, ENABLE);	/* 使能CC4中断 */
0000c6  2201              MOVS     r2,#1
0000c8  2110              MOVS     r1,#0x10
0000ca  4638              MOV      r0,r7
0000cc  f7fffffe          BL       TIM_ITConfig
                  |L8.208|
;;;319        }
;;;320    
;;;321    }
0000d0  e8bd87f0          POP      {r4-r10,pc}
;;;322    
                          ENDP

                  |L8.212|
                          DCD      0xbffffc00
                  |L8.216|
                          DCD      g_tTIM3
                  |L8.220|
0000dc  d3d05449          DCB      211,208,"TIM",206,180,191,170,198,244,200,180,177,187,202
0000e0  4dceb4bf
0000e4  aac6f4c8
0000e8  b4b1bbca
0000ec  b9d3c30d          DCB      185,211,195,"\r\n",0
0000f0  0a00    
0000f2  00                DCB      0
0000f3  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_tTIM3
                          %        56

                          AREA ||.data||, DATA, ALIGN=2

                  s_TIM1_CallBack
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\bsp_hardtimer.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_hardtimer_c_3cb1b625____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_bsp_hardtimer_c_3cb1b625____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_hardtimer_c_3cb1b625____REVSH|
#line 144
|__asm___15_bsp_hardtimer_c_3cb1b625____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_hardtimer_c_3cb1b625____RRX|
#line 300
|__asm___15_bsp_hardtimer_c_3cb1b625____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
