; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\hal_cm4.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\hal_cm4.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -I..\..\RTX\inc -I..\..\RTX\portable -I..\..\MySrc -I..\..\Libraries -I..\..\MySrc\ostask -I..\..\MySrc\MPU6050 -D__MICROLIB -D__UVISION_VERSION=514 -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DARM_MATH_CM4 -DSTM32F40_41xxx --omf_browse=.\flash\obj\hal_cm4.crf ..\..\RTX\portable\HAL_CM4.c]
                          THUMB

                          AREA ||i.dbg_init||, CODE, READONLY, ALIGN=2

                  dbg_init PROC
;;;344    
;;;345    void dbg_init (void) {
000000  4809              LDR      r0,|L1.40|
;;;346      if ((DEMCR & DEMCR_TRCENA)     && 
000002  6800              LDR      r0,[r0,#0]
000004  f0007080          AND      r0,r0,#0x1000000
000008  b168              CBZ      r0,|L1.38|
;;;347          (ITM_CONTROL & ITM_ITMENA) &&
00000a  4808              LDR      r0,|L1.44|
00000c  6800              LDR      r0,[r0,#0]
00000e  f0000001          AND      r0,r0,#1
000012  b140              CBZ      r0,|L1.38|
;;;348          (ITM_ENABLE & (1UL << 31))) {
000014  4805              LDR      r0,|L1.44|
000016  3880              SUBS     r0,r0,#0x80
000018  6800              LDR      r0,[r0,#0]
00001a  f0004000          AND      r0,r0,#0x80000000
00001e  b110              CBZ      r0,|L1.38|
;;;349        dbg_msg = __TRUE;
000020  2001              MOVS     r0,#1
000022  4903              LDR      r1,|L1.48|
000024  7008              STRB     r0,[r1,#0]
                  |L1.38|
;;;350      }
;;;351    }
000026  4770              BX       lr
;;;352    
                          ENDP

                  |L1.40|
                          DCD      0xe000edfc
                  |L1.44|
                          DCD      0xe0000e80
                  |L1.48|
                          DCD      dbg_msg

                          AREA ||i.dbg_task_notify||, CODE, READONLY, ALIGN=2

                  dbg_task_notify PROC
;;;355    
;;;356    void dbg_task_notify (P_TCB p_tcb, BOOL create) {
000000  bf00              NOP      
                  |L2.2|
;;;357      while (ITM_PORT31_U32 == 0);
000002  f04f4260          MOV      r2,#0xe0000000
000006  6fd2              LDR      r2,[r2,#0x7c]
000008  2a00              CMP      r2,#0
00000a  d0fa              BEQ      |L2.2|
;;;358      ITM_PORT31_U32 = (U32)p_tcb->ptask;
00000c  f04f4360          MOV      r3,#0xe0000000
000010  6b42              LDR      r2,[r0,#0x34]
000012  67da              STR      r2,[r3,#0x7c]
;;;359      while (ITM_PORT31_U32 == 0);
000014  bf00              NOP      
                  |L2.22|
000016  f04f4260          MOV      r2,#0xe0000000
00001a  6fd2              LDR      r2,[r2,#0x7c]
00001c  2a00              CMP      r2,#0
00001e  d0fa              BEQ      |L2.22|
;;;360      ITM_PORT31_U16 = (create << 8) | p_tcb->task_id;
000020  78c2              LDRB     r2,[r0,#3]
000022  ea422201          ORR      r2,r2,r1,LSL #8
000026  4b01              LDR      r3,|L2.44|
000028  801a              STRH     r2,[r3,#0]
;;;361    }
00002a  4770              BX       lr
;;;362    
                          ENDP

                  |L2.44|
                          DCD      0xe000007c

                          AREA ||i.dbg_task_switch||, CODE, READONLY, ALIGN=2

                  dbg_task_switch PROC
;;;365    
;;;366    void dbg_task_switch (U32 task_id) {
000000  bf00              NOP      
                  |L3.2|
;;;367      while (ITM_PORT31_U32 == 0);
000002  f04f4160          MOV      r1,#0xe0000000
000006  6fc9              LDR      r1,[r1,#0x7c]
000008  2900              CMP      r1,#0
00000a  d0fa              BEQ      |L3.2|
;;;368      ITM_PORT31_U8 = task_id;
00000c  4a01              LDR      r2,|L3.20|
00000e  7010              STRB     r0,[r2,#0]
;;;369    }
000010  4770              BX       lr
;;;370    
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      0xe000007c

                          AREA ||i.rt_init_stack||, CODE, READONLY, ALIGN=2

                  rt_init_stack PROC
;;;299    
;;;300    void rt_init_stack (P_TCB p_TCB, FUNCP task_body) {
000000  b570              PUSH     {r4-r6,lr}
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;301      /* Prepare TCB and saved context for a first time start of a task. */
;;;302      U32 *stk,i,size;
;;;303    
;;;304      /* Prepare a complete interrupt frame for first task start */
;;;305      size = p_TCB->priv_stack >> 2;
000006  8d15              LDRH     r5,[r2,#0x28]
000008  10ac              ASRS     r4,r5,#2
;;;306      if (size == 0) {
00000a  b91c              CBNZ     r4,|L4.20|
;;;307        size = (U16)os_stackinfo >> 2;
00000c  4d0f              LDR      r5,|L4.76|
00000e  882d              LDRH     r5,[r5,#0]  ; os_stackinfo
000010  f3c5048d          UBFX     r4,r5,#2,#14
                  |L4.20|
;;;308      }
;;;309    
;;;310      /* Write to the top of stack. */
;;;311      stk = &p_TCB->stack[size];
000014  6b15              LDR      r5,[r2,#0x30]
000016  eb050084          ADD      r0,r5,r4,LSL #2
;;;312    
;;;313      /* Auto correct to 8-byte stack alignment. */
;;;314      if ((U32)stk & 0x04) {
00001a  f0000504          AND      r5,r0,#4
00001e  b105              CBZ      r5,|L4.34|
;;;315        stk--;
000020  1f00              SUBS     r0,r0,#4
                  |L4.34|
;;;316      }
;;;317    
;;;318      stk -= 16;
000022  3840              SUBS     r0,r0,#0x40
;;;319    
;;;320      /* Default xPSR and initial PC */
;;;321      stk[15] = INITIAL_xPSR;
000024  f04f7580          MOV      r5,#0x1000000
000028  63c5              STR      r5,[r0,#0x3c]
;;;322      stk[14] = (U32)task_body;
00002a  6383              STR      r3,[r0,#0x38]
;;;323    
;;;324      /* Clear R1-R12,LR registers. */
;;;325      for (i = 0; i < 14; i++) {
00002c  2100              MOVS     r1,#0
00002e  e003              B        |L4.56|
                  |L4.48|
;;;326        stk[i] = 0;
000030  2500              MOVS     r5,#0
000032  f8405021          STR      r5,[r0,r1,LSL #2]
000036  1c49              ADDS     r1,r1,#1              ;325
                  |L4.56|
000038  290e              CMP      r1,#0xe               ;325
00003a  d3f9              BCC      |L4.48|
;;;327      }
;;;328    
;;;329      /* Assign a void pointer to R0. */
;;;330      stk[8] = (U32)p_TCB->msg;
00003c  69d5              LDR      r5,[r2,#0x1c]
00003e  6205              STR      r5,[r0,#0x20]
;;;331    
;;;332      /* Initial Task stack pointer. */
;;;333      p_TCB->tsk_stack = (U32)stk;
000040  62d0              STR      r0,[r2,#0x2c]
;;;334    
;;;335      /* Task entry point. */
;;;336      p_TCB->ptask = task_body;
000042  6353              STR      r3,[r2,#0x34]
;;;337    
;;;338      /* Set a magic word for checking of stack overflow. */
;;;339      p_TCB->stack[0] = MAGIC_WORD;
000044  4d02              LDR      r5,|L4.80|
000046  6b16              LDR      r6,[r2,#0x30]
000048  6035              STR      r5,[r6,#0]
;;;340    }
00004a  bd70              POP      {r4-r6,pc}
;;;341    
                          ENDP

                  |L4.76|
                          DCD      os_stackinfo
                  |L4.80|
                          DCD      0xe25a2ea5

                          AREA ||.data||, DATA, ALIGN=0

                  dbg_msg
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\RTX\\portable\\HAL_CM4.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |rt_set_PSP|
#line 34
|rt_set_PSP| PROC
#line 34

 MSR PSP,R0
 BX LR
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |rt_get_PSP|
#line 42
|rt_get_PSP| PROC
#line 42

 MRS R0,PSP
 BX LR
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |os_set_env|
	IMPORT |os_flags|
#line 50
|os_set_env| PROC
#line 50

 
 MOV R0,SP 
 MSR PSP,R0
 LDR R0,= |os_flags|
 LDRB R0,[R0]
 LSLS R0,#31
 MOVNE R0,#0x02 
 MOVEQ R0,#0x03 
 MSR CONTROL,R0
 BX LR

 ALIGN
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |_alloc_box|
	IMPORT |rt_alloc_box|
#line 68
|_alloc_box| PROC
#line 68

 
 LDR R12,= |rt_alloc_box|
 MRS R3,IPSR
 LSLS R3,#24
 BXNE R12
 MRS R3,CONTROL
 LSLS R3,#31
 BXEQ R12
 SVC 0
 BX LR

 ALIGN
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |_free_box|
	IMPORT |rt_free_box|
#line 86
|_free_box| PROC
#line 86

 
 LDR R12,= |rt_free_box|
 MRS R3,IPSR
 LSLS R3,#24
 BXNE R12
 MRS R3,CONTROL
 LSLS R3,#31
 BXEQ R12
 SVC 0
 BX LR

 ALIGN
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |SVC_Handler|
	IMPORT |os_tsk|
#line 104
|SVC_Handler| PROC
#line 104

 PRESERVE8

#line 110


 IMPORT SVC_Count
 IMPORT SVC_Table
 IMPORT rt_stk_check

 MRS R0,PSP 
 LDR R1,[R0,#24] 
 LDRB R1,[R1,#-2] 
 CBNZ R1,SVC_User

 PUSH {R4,LR} 
 LDM R0,{R0-R3,R12} 
 BLX R12 
 POP {R4,LR} 

 MRS R12,PSP 
 LDR R3,= |os_tsk|
 LDM R3,{R1,R2} 
 CMP R1,R2
 BEQ SVC_Exit 

 CBZ R1,SVC_Restore 

 PUSH {R2,R3}
 TST LR,#0x10 
 VSTMDBEQ R12!,{S16-S31} 
 MOVEQ R3,#0x03 
 MOVNE R3,#0x01

 STRB R3,[R1,#38] 
 STMDB R12!,{R4-R11} 
 STR R12,[R1,#44] 
 BL rt_stk_check 
 POP {R2,R3}

SVC_Restore
 STR R2,[R3] 

 LDR R12,[R2,#44] 
 LDMIA R12!,{R4-R11} 
 LDRB R3,[R2,#38] 

 TST R3,#0x02 
 VLDMIANE R12!,{S16-S31} 
 MVNNE LR,#:NOT:0xFFFFFFED 
 MVNEQ LR,#:NOT:0xFFFFFFFD
 MSR PSP,R12 

 TST R3,#0x01
#line 163

 BXEQ LR 


 LDRB R0,[R2,#37] 
SVC_Exit
 STR R0,[R12] 
#line 173

 BX LR


 

SVC_User
 PUSH {R4,LR} 
 LDR R2,=SVC_Count
 LDR R2,[R2]
 CMP R1,R2
 BHI SVC_Done 

 LDR R4,=SVC_Table-4
 LDR R4,[R4,R1,LSL #2] 

 LDM R0,{R0-R3,R12} 
 BLX R4 

 MRS R12,PSP
 STM R12,{R0-R3} 
SVC_Done
 POP {R4,PC} 

 ALIGN
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |PendSV_Handler|
	IMPORT |rt_pop_req|
#line 203
|PendSV_Handler| PROC
#line 203

 PRESERVE8

#line 209


 PUSH {R4,LR} 
 BL  |rt_pop_req|

Sys_Switch
 POP {R4,LR} 

 LDR R3,= |os_tsk|
 LDM R3,{R1,R2} 
 CMP R1,R2
#line 223

 BXEQ LR 


 PUSH {R2,R3}
 MRS R12,PSP 
 TST LR,#0x10 
 VSTMDBEQ R12!,{S16-S31} 
 MOVEQ R3,#0x02 
 MOVNE R3,#0x00

 STRB R3,[R1,#38] 
 STMDB R12!,{R4-R11} 
 STR R12,[R1,#44] 
 BL rt_stk_check 

 POP {R2,R3}
 STR R2,[R3] 

 LDR R12,[R2,#44] 
 LDMIA R12!,{R4-R11} 
 LDRB R3,[R2,#38] 

 TST R3,#0x02 
 VLDMIANE R12!,{S16-S31} 
 MVNNE LR,#:NOT:0xFFFFFFED 
 MVNEQ LR,#:NOT:0xFFFFFFFD
 MSR PSP,R12 

 TST R3,#0x01
 LDRBNE R3,[R2,#37] 
 STRNE R3,[R12]
#line 258

 BX LR 


 ALIGN
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |SysTick_Handler|
	IMPORT |rt_systick|
#line 268
|SysTick_Handler| PROC
#line 268

 PRESERVE8

#line 274


 PUSH {R4,LR} 
 BL  |rt_systick|
 B Sys_Switch

 ALIGN
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |OS_Tick_Handler|
	IMPORT |os_tick_irqack|
#line 286
|OS_Tick_Handler| PROC
#line 286

 PRESERVE8

 PUSH {R4,LR} 
 BL  |os_tick_irqack|
 BL  |rt_systick|
 B Sys_Switch

 ALIGN
	ENDP

;*** End   embedded assembler ***
