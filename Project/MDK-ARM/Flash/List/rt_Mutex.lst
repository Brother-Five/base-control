L 1 "..\..\RTX\src\rt_Mutex.c"
N/*----------------------------------------------------------------------------
N *      RL-ARM - RTX
N *----------------------------------------------------------------------------
N *      Name:    RT_MUTEX.C
N *      Purpose: Implements mutex synchronization objects
N *      Rev.:    V4.73
N *----------------------------------------------------------------------------
N *      This code is part of the RealView Run-Time Library.
N *      Copyright (c) 2004-2013 KEIL - An ARM Company. All rights reserved.
N *---------------------------------------------------------------------------*/
N
N#include "rt_TypeDef.h"
L 1 "..\..\RTX\inc\rt_TypeDef.h" 1
N/*----------------------------------------------------------------------------
N *      RL-ARM - RTX
N *----------------------------------------------------------------------------
N *      Name:    RT_TYPEDEF.H
N *      Purpose: Type Definitions
N *      Rev.:    V4.73
N *----------------------------------------------------------------------------
N *      This code is part of the RealView Run-Time Library.
N *      Copyright (c) 2004-2013 KEIL - An ARM Company. All rights reserved.
N *---------------------------------------------------------------------------*/
N
N/* Types */
Ntypedef signed char        S8;
Ntypedef unsigned char      U8;
Ntypedef short              S16;
Ntypedef unsigned short     U16;
Ntypedef int                S32;
Ntypedef unsigned int       U32;
Ntypedef long long          S64;
Ntypedef unsigned long long U64;
Ntypedef unsigned char      BIT;
Ntypedef unsigned int       BOOL;
Ntypedef void               (*FUNCP)(void);
N
Ntypedef U32     OS_TID;
Ntypedef void    *OS_ID;
Ntypedef U32     OS_RESULT;
N
Ntypedef struct OS_TCB {
N  /* General part: identical for all implementations.                        */
N  U8     cb_type;                 /* Control Block Type                      */
N  U8     state;                   /* Task state                              */
N  U8     prio;                    /* Execution priority                      */
N  U8     task_id;                 /* Task ID value for optimized TCB access  */
N  struct OS_TCB *p_lnk;           /* Link pointer for ready/sem. wait list   */
N  struct OS_TCB *p_rlnk;          /* Link pointer for sem./mbx lst backwards */
N  struct OS_TCB *p_dlnk;          /* Link pointer for delay list             */
N  struct OS_TCB *p_blnk;          /* Link pointer for delay list backwards   */
N  U16    delta_time;              /* Time until time out                     */
N  U16    interval_time;           /* Time interval for periodic waits        */
N  U16    events;                  /* Event flags                             */
N  U16    waits;                   /* Wait flags                              */
N  void   **msg;                   /* Direct message passing when task waits  */
N  struct OS_MUCB *p_mlnk;         /* Link pointer for mutex owner list       */
N  U8     prio_base;               /* Base priority                           */
N  U8     ret_val;                 /* Return value upon completion of a wait  */
N
N  /* Hardware dependant part: specific for CM processor                      */
N  U8     ret_upd;                 /* Updated return value                    */
N  U16    priv_stack;              /* Private stack size, 0= system assigned  */
N  U32    tsk_stack;               /* Current task Stack pointer (R13)        */
N  U32    *stack;                  /* Pointer to Task Stack memory block      */
N
N  /* Task entry point used for uVision debugger                              */
N  FUNCP  ptask;                   /* Task entry address                      */
N} *P_TCB;
N#define TCB_RETVAL      37        /* 'ret_val' offset                        */
N#define TCB_RETUPD      38        /* 'ret_upd' offset                        */
N#define TCB_TSTACK      44        /* 'tsk_stack' offset                      */
N
Ntypedef struct OS_PSFE {          /* Post Service Fifo Entry                 */
N  void  *id;                      /* Object Identification                   */
N  U32    arg;                     /* Object Argument                         */
N} *P_PSFE;
N
Ntypedef struct OS_PSQ {           /* Post Service Queue                      */
N  U8     first;                   /* FIFO Head Index                         */
N  U8     last;                    /* FIFO Tail Index                         */
N  U8     count;                   /* Number of stored items in FIFO          */
N  U8     size;                    /* FIFO Size                               */
N  struct OS_PSFE q[1];            /* FIFO Content                            */
N} *P_PSQ;
N
Ntypedef struct OS_TSK {
N  P_TCB  run;                     /* Current running task                    */
N  P_TCB  new;                     /* Scheduled task to run                   */
N} *P_TSK;
N
Ntypedef struct OS_ROBIN {         /* Round Robin Control                     */
N  P_TCB  task;                    /* Round Robin task                        */
N  U16    time;                    /* Round Robin switch time                 */
N  U16    tout;                    /* Round Robin timeout                     */
N} *P_ROBIN;
N
Ntypedef struct OS_XCB {
N  U8     cb_type;                 /* Control Block Type                      */
N  struct OS_TCB *p_lnk;           /* Link pointer for ready/sem. wait list   */
N  struct OS_TCB *p_rlnk;          /* Link pointer for sem./mbx lst backwards */
N  struct OS_TCB *p_dlnk;          /* Link pointer for delay list             */
N  struct OS_TCB *p_blnk;          /* Link pointer for delay list backwards   */
N  U16    delta_time;              /* Time until time out                     */
N} *P_XCB;
N
Ntypedef struct OS_MCB {
N  U8     cb_type;                 /* Control Block Type                      */
N  U8     isr_st;                  /* State flag variable for isr functions   */
N  struct OS_TCB *p_lnk;           /* Chain of tasks waiting for message      */
N  U16    first;                   /* Index of the message list begin         */
N  U16    last;                    /* Index of the message list end           */
N  U16    count;                   /* Actual number of stored messages        */
N  U16    size;                    /* Maximum number of stored messages       */
N  void   *msg[1];                 /* FIFO for Message pointers 1st element   */
N} *P_MCB;
N
Ntypedef struct OS_SCB {
N  U8     cb_type;                 /* Control Block Type                      */
N  U16    tokens;                  /* Semaphore tokens                        */
N  struct OS_TCB *p_lnk;           /* Chain of tasks waiting for tokens       */
N} *P_SCB;
N
Ntypedef struct OS_MUCB {
N  U8     cb_type;                 /* Control Block Type                      */
N  U16    level;                   /* Call nesting level                      */
N  struct OS_TCB *p_lnk;           /* Chain of tasks waiting for mutex        */
N  struct OS_TCB *owner;           /* Mutex owner task                        */
N  struct OS_MUCB *p_mlnk;         /* Chain of mutexes by owner task          */
N} *P_MUCB;
N
Ntypedef struct OS_XTMR {
N  struct OS_TMR  *next;
N  U16    tcnt;
N} *P_XTMR;
N
Ntypedef struct OS_TMR {
N  struct OS_TMR  *next;           /* Link pointer to Next timer              */
N  U16    tcnt;                    /* Timer delay count                       */
N  U16    info;                    /* User defined call info                  */
N} *P_TMR;
N
Ntypedef struct OS_BM {
N  void *free;                     /* Pointer to first free memory block      */
N  void *end;                      /* Pointer to memory block end             */
N  U32  blk_size;                  /* Memory block size                       */
N} *P_BM;
N
N/* Definitions */
N#define __TRUE          1
N#define __FALSE         0
N#define NULL            ((void *) 0)
N
N/*----------------------------------------------------------------------------
N * end of file
N *---------------------------------------------------------------------------*/
N
L 13 "..\..\RTX\src\rt_Mutex.c" 2
N#include "RTX_Config.h"
L 1 "..\..\RTX\inc\RTX_Config.h" 1
N/*----------------------------------------------------------------------------
N *      RL-ARM - RTX
N *----------------------------------------------------------------------------
N *      Name:    RTX_CONFIG.H
N *      Purpose: Exported functions of RTX_Config.c
N *      Rev.:    V4.70
N *----------------------------------------------------------------------------
N *      This code is part of the RealView Run-Time Library.
N *      Copyright (c) 2004-2013 KEIL - An ARM Company. All rights reserved.
N *---------------------------------------------------------------------------*/
N
N
N/* Error Codes */
N#define OS_ERR_STK_OVF          1
N#define OS_ERR_FIFO_OVF         2
N#define OS_ERR_MBX_OVF          3
N
N/* Definitions */
N#define BOX_ALIGN_8                   0x80000000
N#define _declare_box(pool,size,cnt)   U32 pool[(((size)+3)/4)*(cnt) + 3]
N#define _declare_box8(pool,size,cnt)  U64 pool[(((size)+7)/8)*(cnt) + 2]
N#define _init_box8(pool,size,bsize)   _init_box (pool,size,(bsize) | BOX_ALIGN_8)
N
N/* Variables */
Nextern U32 mp_tcb[];
Nextern U64 mp_stk[];
Nextern U32 os_fifo[];
Nextern void *os_active_TCB[];
N
N/* Constants */
Nextern U16 const os_maxtaskrun;
Nextern U32 const os_trv;
Nextern U8  const os_flags;
Nextern U32 const os_stackinfo;
Nextern U32 const os_rrobin;
Nextern U32 const os_clockrate;
Nextern U32 const os_timernum;
Nextern U16 const mp_tcb_size;
Nextern U32 const mp_stk_size;
Nextern U32 const *m_tmr;
Nextern U16 const mp_tmr_size;
Nextern U8  const os_fifo_size;
N
N/* Functions */
Nextern void os_idle_demon   (void);
Nextern int  os_tick_init    (void);
Nextern void os_tick_irqack  (void);
Nextern void os_tmr_call     (U16  info);
Nextern void os_error        (U32 err_code);
N
N/*----------------------------------------------------------------------------
N * end of file
N *---------------------------------------------------------------------------*/
L 14 "..\..\RTX\src\rt_Mutex.c" 2
N#include "rt_List.h"
L 1 "..\..\RTX\inc\rt_List.h" 1
N/*----------------------------------------------------------------------------
N *      RL-ARM - RTX
N *----------------------------------------------------------------------------
N *      Name:    RT_LIST.H
N *      Purpose: Functions for the management of different lists
N *      Rev.:    V4.70
N *----------------------------------------------------------------------------
N *      This code is part of the RealView Run-Time Library.
N *      Copyright (c) 2004-2013 KEIL - An ARM Company. All rights reserved.
N *---------------------------------------------------------------------------*/
N
N/* Definitions */
N
N/* Values for 'cb_type' */
N#define TCB             0
N#define MCB             1
N#define SCB             2
N#define MUCB            3
N#define HCB             4
N
N/* Variables */
Nextern struct OS_XCB os_rdy;
Nextern struct OS_XCB os_dly;
N
N/* Functions */
Nextern void  rt_put_prio      (P_XCB p_CB, P_TCB p_task);
Nextern P_TCB rt_get_first     (P_XCB p_CB);
Nextern void  rt_put_rdy_first (P_TCB p_task);
Nextern P_TCB rt_get_same_rdy_prio (void);
Nextern void  rt_resort_prio   (P_TCB p_task);
Nextern void  rt_put_dly       (P_TCB p_task, U16 delay);
Nextern void  rt_dec_dly       (void);
Nextern void  rt_rmv_list      (P_TCB p_task);
Nextern void  rt_rmv_dly       (P_TCB p_task);
Nextern void  rt_psq_enq       (OS_ID entry, U32 arg);
N
N/* This is a fast macro generating in-line code */
N#define rt_rdy_prio(void) (os_rdy.p_lnk->prio)
N
N
N/*----------------------------------------------------------------------------
N * end of file
N *---------------------------------------------------------------------------*/
N
L 15 "..\..\RTX\src\rt_Mutex.c" 2
N#include "rt_Task.h"
L 1 "..\..\RTX\inc\rt_Task.h" 1
N/*----------------------------------------------------------------------------
N *      RL-ARM - RTX
N *----------------------------------------------------------------------------
N *      Name:    RT_TASK.H
N *      Purpose: Task functions and system start up.
N *      Rev.:    V4.70
N *----------------------------------------------------------------------------
N *      This code is part of the RealView Run-Time Library.
N *      Copyright (c) 2004-2013 KEIL - An ARM Company. All rights reserved.
N *---------------------------------------------------------------------------*/
N
N/* Definitions */
N
N/* Values for 'state'   */
N#define INACTIVE        0
N#define READY           1
N#define RUNNING         2
N#define WAIT_DLY        3
N#define WAIT_ITV        4
N#define WAIT_OR         5
N#define WAIT_AND        6
N#define WAIT_SEM        7
N#define WAIT_MBX        8
N#define WAIT_MUT        9
N
N/* Return codes */
N#define OS_R_TMO        0x01
N#define OS_R_EVT        0x02
N#define OS_R_SEM        0x03
N#define OS_R_MBX        0x04
N#define OS_R_MUT        0x05
N
N#define OS_R_OK         0x00
N#define OS_R_NOK        0xff
N
N/* Variables */
Nextern struct OS_TSK os_tsk;
Nextern struct OS_TCB os_idle_TCB;
N
N/* Functions */
Nextern void      rt_switch_req (P_TCB p_new);
Nextern void      rt_dispatch   (P_TCB next_TCB);
Nextern void      rt_block      (U16 timeout, U8 block_state);
Nextern void      rt_tsk_pass   (void);
Nextern OS_TID    rt_tsk_self   (void);
Nextern OS_RESULT rt_tsk_prio   (OS_TID task_id, U8 new_prio);
Nextern OS_TID    rt_tsk_create (FUNCP task, U32 prio_stksz, void *stk, void *argv);
Nextern OS_RESULT rt_tsk_delete (OS_TID task_id);
Nextern void      rt_sys_init   (FUNCP first_task, U32 prio_stksz, void *stk);
N
N/*----------------------------------------------------------------------------
N * end of file
N *---------------------------------------------------------------------------*/
N
N
N
N
N
N
L 16 "..\..\RTX\src\rt_Mutex.c" 2
N#include "rt_Mutex.h"
L 1 "..\..\RTX\inc\rt_Mutex.h" 1
N/*----------------------------------------------------------------------------
N *      RL-ARM - RTX
N *----------------------------------------------------------------------------
N *      Name:    RT_MUTEX.H
N *      Purpose: Implements mutex synchronization objects
N *      Rev.:    V4.70
N *----------------------------------------------------------------------------
N *      This code is part of the RealView Run-Time Library.
N *      Copyright (c) 2004-2013 KEIL - An ARM Company. All rights reserved.
N *---------------------------------------------------------------------------*/
N
N/* Functions */
Nextern void      rt_mut_init    (OS_ID mutex);
Nextern OS_RESULT rt_mut_release (OS_ID mutex);
Nextern OS_RESULT rt_mut_wait    (OS_ID mutex, U16 timeout);
N
N/*----------------------------------------------------------------------------
N * end of file
N *---------------------------------------------------------------------------*/
N
L 17 "..\..\RTX\src\rt_Mutex.c" 2
N
N
N/*----------------------------------------------------------------------------
N *      Functions
N *---------------------------------------------------------------------------*/
N
N
N/*--------------------------- rt_mut_init -----------------------------------*/
N
Nvoid rt_mut_init (OS_ID mutex) {
N  /* Initialize a mutex object */
N  P_MUCB p_MCB = mutex;
N
N  p_MCB->cb_type = MUCB;
X  p_MCB->cb_type = 3;
N  p_MCB->level   = 0;
N  p_MCB->p_lnk   = NULL;
X  p_MCB->p_lnk   = ((void *) 0);
N  p_MCB->owner   = NULL;
X  p_MCB->owner   = ((void *) 0);
N  p_MCB->p_mlnk  = NULL;
X  p_MCB->p_mlnk  = ((void *) 0);
N}
N
N
N/*--------------------------- rt_mut_release --------------------------------*/
N
NOS_RESULT rt_mut_release (OS_ID mutex) {
N  /* Release a mutex object */
N  P_MUCB p_MCB = mutex;
N  P_TCB  p_TCB;
N  P_MUCB p_mlnk;
N  U8     prio;
N
N  if (p_MCB->level == 0 || p_MCB->owner != os_tsk.run) {
N    /* Unbalanced mutex release or task is not the owner */
N    return (OS_R_NOK);
X    return (0xff);
N  }
N  if (--p_MCB->level != 0) {
N    return (OS_R_OK);
X    return (0x00);
N  }
N
N  /* Remove mutex from task mutex owner list. */
N  p_mlnk = os_tsk.run->p_mlnk;
N  if (p_mlnk == p_MCB) {
N    os_tsk.run->p_mlnk = p_MCB->p_mlnk;
N  }
N  else {
N    while (p_mlnk) {
N      if (p_mlnk->p_mlnk == p_MCB) {
N        p_mlnk->p_mlnk = p_MCB->p_mlnk;
N        break;
N      }
N      p_mlnk = p_mlnk->p_mlnk;
N    }
N  }
N
N  /* Restore owner task's priority. */
N  prio = os_tsk.run->prio_base;
N  p_mlnk = os_tsk.run->p_mlnk;
N  while (p_mlnk) {
N    if (p_mlnk->p_lnk && (p_mlnk->p_lnk->prio > prio)) {
N      /* A task with higher priority is waiting for mutex. */
N      prio = p_mlnk->p_lnk->prio;
N    }
N    p_mlnk = p_mlnk->p_mlnk;
N  }
N  os_tsk.run->prio = prio;
N
N  if (p_MCB->p_lnk != NULL) {
X  if (p_MCB->p_lnk != ((void *) 0)) {
N    /* A task is waiting for mutex. */
N    p_TCB = rt_get_first ((P_XCB)p_MCB);
N    p_TCB->ret_val = OS_R_MUT;
X    p_TCB->ret_val = 0x05;
N    rt_rmv_dly (p_TCB);
N    /* A waiting task becomes the owner of this mutex. */
N    p_MCB->level  = 1;
N    p_MCB->owner  = p_TCB;
N    p_MCB->p_mlnk = p_TCB->p_mlnk;
N    p_TCB->p_mlnk = p_MCB; 
N    /* Priority inversion, check which task continues. */
N    if (os_tsk.run->prio >= rt_rdy_prio()) {
X    if (os_tsk.run->prio >= (os_rdy . p_lnk->prio)) {
N      rt_dispatch (p_TCB);
N    }
N    else {
N      /* Ready task has higher priority than running task. */
N      rt_put_prio (&os_rdy, os_tsk.run);
N      rt_put_prio (&os_rdy, p_TCB);
N      os_tsk.run->state = READY;
X      os_tsk.run->state = 1;
N      p_TCB->state      = READY;
X      p_TCB->state      = 1;
N      rt_dispatch (NULL);
X      rt_dispatch (((void *) 0));
N    }
N    os_tsk.run->ret_val = OS_R_OK;
X    os_tsk.run->ret_val = 0x00;
N  }
N  else {
N    /* Check if own priority lowered by priority inversion. */
N    if (rt_rdy_prio() > os_tsk.run->prio) {
X    if ((os_rdy . p_lnk->prio) > os_tsk.run->prio) {
N      rt_put_prio (&os_rdy, os_tsk.run);
N      os_tsk.run->state = READY;
X      os_tsk.run->state = 1;
N      rt_dispatch (NULL);
X      rt_dispatch (((void *) 0));
N      os_tsk.run->ret_val = OS_R_OK;
X      os_tsk.run->ret_val = 0x00;
N    }
N  }
N  return (OS_R_OK);
X  return (0x00);
N}
N
N
N/*--------------------------- rt_mut_wait -----------------------------------*/
N
NOS_RESULT rt_mut_wait (OS_ID mutex, U16 timeout) {
N  /* Wait for a mutex, continue when mutex is free. */
N  P_MUCB p_MCB = mutex;
N
N  if (p_MCB->level == 0) {
N    p_MCB->owner  = os_tsk.run;
N    p_MCB->p_mlnk = os_tsk.run->p_mlnk;
N    os_tsk.run->p_mlnk = p_MCB; 
N    goto inc;
N  }
N  if (p_MCB->owner == os_tsk.run) {
N    /* OK, running task is the owner of this mutex. */
Ninc:p_MCB->level++;
N    return (OS_R_OK);
X    return (0x00);
N  }
N  /* Mutex owned by another task, wait until released. */
N  if (timeout == 0) {
N    return (OS_R_TMO);
X    return (0x01);
N  }
N  /* Raise the owner task priority if lower than current priority. */
N  /* This priority inversion is called priority inheritance.       */
N  if (p_MCB->owner->prio < os_tsk.run->prio) {
N    p_MCB->owner->prio = os_tsk.run->prio;
N    rt_resort_prio (p_MCB->owner);
N  }
N  if (p_MCB->p_lnk != NULL) {
X  if (p_MCB->p_lnk != ((void *) 0)) {
N    rt_put_prio ((P_XCB)p_MCB, os_tsk.run);
N  }
N  else {
N    p_MCB->p_lnk = os_tsk.run;
N    os_tsk.run->p_lnk  = NULL;
X    os_tsk.run->p_lnk  = ((void *) 0);
N    os_tsk.run->p_rlnk = (P_TCB)p_MCB;
N  }
N  rt_block(timeout, WAIT_MUT);
X  rt_block(timeout, 9);
N  return (OS_R_TMO);
X  return (0x01);
N}
N
N
N/*----------------------------------------------------------------------------
N * end of file
N *---------------------------------------------------------------------------*/
N
