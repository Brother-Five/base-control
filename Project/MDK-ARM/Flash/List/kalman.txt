; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\kalman.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\kalman.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -I..\..\RTX\inc -I..\..\RTX\portable -I..\..\MySrc -I..\..\Libraries -I..\..\MySrc\ostask -I..\..\MySrc\MPU6050 -D__MICROLIB -D__UVISION_VERSION=514 -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DARM_MATH_CM4 -DSTM32F40_41xxx --omf_browse=.\flash\obj\kalman.crf ..\..\MySrc\Kalman.cpp]
                          THUMB

                          AREA ||i.kalman_filter||, CODE, READONLY, ALIGN=1

                  kalman_filter PROC
;;;25      */
;;;26     float kalman_filter(kalman_struct *kalman_lcw, float measure)
000000  eef00a40          VMOV.F32 s1,s0
;;;27     {
;;;28         /* Predict */
;;;29         kalman_lcw->x = kalman_lcw->A * kalman_lcw->x;//%x的先验估计由上一个时间点的后验估计值和输入信息给出
000004  ed900a01          VLDR     s0,[r0,#4]
000008  ed901a00          VLDR     s2,[r0,#0]
00000c  ee200a01          VMUL.F32 s0,s0,s2
000010  ed800a00          VSTR     s0,[r0,#0]
;;;30         kalman_lcw->p = kalman_lcw->A * kalman_lcw->A * kalman_lcw->p + kalman_lcw->q;  /*计算先验均方差 p(n|n-1)=A^2*p(n-1|n-1)+q */
000014  ed900a01          VLDR     s0,[r0,#4]
000018  ee201a00          VMUL.F32 s2,s0,s0
00001c  edd01a05          VLDR     s3,[r0,#0x14]
000020  ed900a03          VLDR     s0,[r0,#0xc]
000024  ee010a21          VMLA.F32 s0,s2,s3
000028  ed800a05          VSTR     s0,[r0,#0x14]
;;;31     
;;;32         /* Measurement */
;;;33         kalman_lcw->gain = kalman_lcw->p * kalman_lcw->H / (kalman_lcw->p * kalman_lcw->H * kalman_lcw->H + kalman_lcw->r);
00002c  ed900a05          VLDR     s0,[r0,#0x14]
000030  ed901a02          VLDR     s2,[r0,#8]
000034  ee201a01          VMUL.F32 s2,s0,s2
000038  ed900a05          VLDR     s0,[r0,#0x14]
00003c  edd01a02          VLDR     s3,[r0,#8]
000040  ee601a21          VMUL.F32 s3,s0,s3
000044  ed902a02          VLDR     s4,[r0,#8]
000048  ed900a04          VLDR     s0,[r0,#0x10]
00004c  ee010a82          VMLA.F32 s0,s3,s4
000050  eec11a00          VDIV.F32 s3,s2,s0
000054  edc01a06          VSTR     s3,[r0,#0x18]
;;;34         kalman_lcw->x = kalman_lcw->x + kalman_lcw->gain * (measure - kalman_lcw->H * kalman_lcw->x);//利用残余的信息改善对x(t)的估计，给出后验估计，这个值也就是输出
000058  ed901a02          VLDR     s2,[r0,#8]
00005c  edd01a00          VLDR     s3,[r0,#0]
000060  eeb00a60          VMOV.F32 s0,s1
000064  ee010a61          VMLS.F32 s0,s2,s3
000068  ed901a00          VLDR     s2,[r0,#0]
00006c  edd01a06          VLDR     s3,[r0,#0x18]
000070  ee011a80          VMLA.F32 s2,s3,s0
000074  ed801a00          VSTR     s2,[r0,#0]
;;;35         kalman_lcw->p = (1 - kalman_lcw->gain * kalman_lcw->H) * kalman_lcw->p;//%计算后验均方差
000078  ed901a06          VLDR     s2,[r0,#0x18]
00007c  edd01a02          VLDR     s3,[r0,#8]
000080  eeb70a00          VMOV.F32 s0,#1.00000000
000084  ee010a61          VMLS.F32 s0,s2,s3
000088  ed901a05          VLDR     s2,[r0,#0x14]
00008c  ee200a01          VMUL.F32 s0,s0,s2
000090  ed800a05          VSTR     s0,[r0,#0x14]
;;;36     
;;;37         return kalman_lcw->x;
000094  ed900a00          VLDR     s0,[r0,#0]
;;;38     }
000098  4770              BX       lr
                          ENDP


                          AREA ||i.kalman_init||, CODE, READONLY, ALIGN=1

                  kalman_init PROC
;;;8       */
;;;9      void kalman_init(kalman_struct *kalman_lcw, float init_x, float init_p,float predict_q,float measure_q)
000000  ed800a00          VSTR     s0,[r0,#0]
;;;10     {
;;;11         kalman_lcw->x = init_x;//待测量的初始值，如有中值一般设成中值
;;;12         kalman_lcw->p = init_p;//后验状态估计值误差的方差的初始值
000004  edc00a05          VSTR     s1,[r0,#0x14]
;;;13         kalman_lcw->A = 1;
000008  eeb72a00          VMOV.F32 s4,#1.00000000
00000c  ed802a01          VSTR     s4,[r0,#4]
;;;14         kalman_lcw->H = 1;
000010  eeb72a00          VMOV.F32 s4,#1.00000000
000014  ed802a02          VSTR     s4,[r0,#8]
;;;15         kalman_lcw->q = predict_q;//预测（过程）噪声方差 实验发现修改这个值会影响收敛速率
000018  ed801a03          VSTR     s2,[r0,#0xc]
;;;16         kalman_lcw->r = measure_q;//测量（观测）噪声方差
00001c  edc01a04          VSTR     s3,[r0,#0x10]
;;;17         //这里两个参数是最关键的
;;;18     }
000020  4770              BX       lr
;;;19     
                          ENDP


                          AREA ||.ARM.exidx||, LINKORDER=||i.kalman_init||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i.kalman_init||
                          DCD      0x00000001

                          AREA ||area_number.4||, LINKORDER=||i.kalman_filter||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.4||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.kalman_filter||
                          DCD      0x00000001
