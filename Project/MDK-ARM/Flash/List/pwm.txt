; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--cpp --list --split_sections --debug -c --asm --interleave -o.\flash\obj\pwm.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\pwm.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -I..\..\RTX\inc -I..\..\RTX\portable -I..\..\MySrc -I..\..\Libraries -I..\..\MySrc\ostask -I..\..\MySrc\MPU6050 -D__MICROLIB -D__UVISION_VERSION=514 -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DARM_MATH_CM4 -DSTM32F40_41xxx --omf_browse=.\flash\obj\pwm.crf ..\..\MySrc\pwm.cpp]
                          THUMB

                          AREA ||i.Duoji_Close||, CODE, READONLY, ALIGN=2

                  Duoji_Close PROC
;;;176    
;;;177    void Duoji_Close(void)
000000  4802              LDR      r0,|L1.12|
;;;178    {
;;;179    	PWM3=DUOJI_CLOSE;
000002  8800              LDRH     r0,[r0,#0]  ; DUOJI_CLOSE
000004  f04f4180          MOV      r1,#0x40000000
000008  63c8              STR      r0,[r1,#0x3c]
;;;180    }
00000a  4770              BX       lr
;;;181    
                          ENDP

                  |L1.12|
                          DCD      DUOJI_CLOSE

                          AREA ||i.Duoji_Open||, CODE, READONLY, ALIGN=2

                  Duoji_Open PROC
;;;170    extern const u16 DUOJI_OPEN,DUOJI_CLOSE;
;;;171    void Duoji_Open(void)
000000  4802              LDR      r0,|L2.12|
;;;172    {
;;;173    
;;;174    	PWM3=DUOJI_OPEN;
000002  8800              LDRH     r0,[r0,#0]  ; DUOJI_OPEN
000004  f04f4180          MOV      r1,#0x40000000
000008  63c8              STR      r0,[r1,#0x3c]
;;;175    }
00000a  4770              BX       lr
;;;176    
                          ENDP

                  |L2.12|
                          DCD      DUOJI_OPEN

                          AREA ||i.Duoji_Toggle||, CODE, READONLY, ALIGN=2

                  Duoji_Toggle PROC
;;;181    
;;;182    void Duoji_Toggle(void)
000000  b500              PUSH     {lr}
;;;183    {
;;;184        static u8 flag=1;
;;;185        if(flag == 0)
000002  480c              LDR      r0,|L3.52|
000004  7800              LDRB     r0,[r0,#0]  ; flag
000006  b950              CBNZ     r0,|L3.30|
;;;186        {
;;;187            Duoji_Open();
000008  f7fffffe          BL       Duoji_Open
;;;188            flag = !flag;
00000c  4809              LDR      r0,|L3.52|
00000e  7800              LDRB     r0,[r0,#0]  ; flag
000010  b908              CBNZ     r0,|L3.22|
000012  2001              MOVS     r0,#1
000014  e000              B        |L3.24|
                  |L3.22|
000016  2000              MOVS     r0,#0
                  |L3.24|
000018  4906              LDR      r1,|L3.52|
00001a  7008              STRB     r0,[r1,#0]
00001c  e009              B        |L3.50|
                  |L3.30|
;;;189        }
;;;190        else
;;;191        {
;;;192            Duoji_Close();
00001e  f7fffffe          BL       Duoji_Close
;;;193            flag = !flag;
000022  4804              LDR      r0,|L3.52|
000024  7800              LDRB     r0,[r0,#0]  ; flag
000026  b908              CBNZ     r0,|L3.44|
000028  2001              MOVS     r0,#1
00002a  e000              B        |L3.46|
                  |L3.44|
00002c  2000              MOVS     r0,#0
                  |L3.46|
00002e  4901              LDR      r1,|L3.52|
000030  7008              STRB     r0,[r1,#0]
                  |L3.50|
;;;194        }
;;;195    }
000032  bd00              POP      {pc}
;;;196    
                          ENDP

                  |L3.52|
                          DCD      flag

                          AREA ||i.ESC_Init||, CODE, READONLY, ALIGN=2

                  ESC_Init PROC
;;;112    
;;;113    void ESC_Init(void)
000000  f44f60fa          MOV      r0,#0x7d0
;;;114    {
;;;115    	PWM1=2000;//先给最高油门以让电调知道量程
000004  0681              LSLS     r1,r0,#26
000006  6348              STR      r0,[r1,#0x34]
;;;116    	PWM2=2000;
000008  6388              STR      r0,[r1,#0x38]
;;;117    	delay_ms(6000);
00000a  f2417070          MOV      r0,#0x1770
00000e  f8dfc01c          LDR      r12,|L4.44|
000012  df00              SVC      #0x0
;;;118    	PWM1=1000;//最低油门
000014  f44f707a          MOV      r0,#0x3e8
000018  06c1              LSLS     r1,r0,#27
00001a  6348              STR      r0,[r1,#0x34]
;;;119    	PWM2=1000;
00001c  6388              STR      r0,[r1,#0x38]
;;;120    	delay_ms(6000);
00001e  f2417070          MOV      r0,#0x1770
000022  f8dfc008          LDR      r12,|L4.44|
000026  df00              SVC      #0x0
;;;121    // 	PWM3=650;//
;;;122    }
000028  4770              BX       lr
;;;123    
                          ENDP

00002a  0000              DCW      0x0000
                  |L4.44|
                          DCD      rt_dly_wait

                          AREA ||i.ESC_RUN||, CODE, READONLY, ALIGN=1

                  ESC_RUN PROC
;;;123    
;;;124    void ESC_RUN(u8 pwm1,u8 pwm2)
000000  eb000280          ADD      r2,r0,r0,LSL #2
;;;125    {
;;;126    	PWM1=1000+10*pwm1;
000004  0052              LSLS     r2,r2,#1
000006  f502727a          ADD      r2,r2,#0x3e8
00000a  f04f4380          MOV      r3,#0x40000000
00000e  635a              STR      r2,[r3,#0x34]
;;;127    	PWM2=1000+10*pwm2;
000010  eb010281          ADD      r2,r1,r1,LSL #2
000014  0052              LSLS     r2,r2,#1
000016  f502727a          ADD      r2,r2,#0x3e8
00001a  639a              STR      r2,[r3,#0x38]
;;;128    // 	PWM3=1000+10*pwm3;
;;;129    // 	PWM4=1000+10*pwm4;
;;;130    }
00001c  4770              BX       lr
;;;131    
                          ENDP


                          AREA ||i.ESC_STOP||, CODE, READONLY, ALIGN=1

                  ESC_STOP PROC
;;;131    
;;;132    void ESC_STOP(void)
000000  b510              PUSH     {r4,lr}
;;;133    {
;;;134    	PWM1=1000;//最低油门
000002  f44f707a          MOV      r0,#0x3e8
000006  06c1              LSLS     r1,r0,#27
000008  6348              STR      r0,[r1,#0x34]
;;;135    	PWM2=1000;
00000a  6388              STR      r0,[r1,#0x38]
;;;136    // 	PWM3=1000;
;;;137    // 	PWM4=1000;
;;;138    	Set_ESC_Flag(0);
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       Set_ESC_Flag
;;;139    	Laser_Off();
000012  2003              MOVS     r0,#3
000014  f7fffffe          BL       bsp_LedOn
;;;140    }
000018  bd10              POP      {r4,pc}
;;;141    
                          ENDP


                          AREA ||i.ESC_Toggle||, CODE, READONLY, ALIGN=2

                  ESC_Toggle PROC
;;;143    extern u8 ESC_PWM1,ESC_PWM2;
;;;144    void ESC_Toggle(void)
000000  b510              PUSH     {r4,lr}
;;;145    {
;;;146      
;;;147    	ESC_Flag = !ESC_Flag;
000002  480e              LDR      r0,|L7.60|
000004  7800              LDRB     r0,[r0,#0]  ; ESC_Flag
000006  b908              CBNZ     r0,|L7.12|
000008  2001              MOVS     r0,#1
00000a  e000              B        |L7.14|
                  |L7.12|
00000c  2000              MOVS     r0,#0
                  |L7.14|
00000e  490b              LDR      r1,|L7.60|
000010  7008              STRB     r0,[r1,#0]
;;;148        if(ESC_Flag == 1)
000012  4608              MOV      r0,r1
000014  7800              LDRB     r0,[r0,#0]  ; ESC_Flag
000016  2801              CMP      r0,#1
000018  d109              BNE      |L7.46|
;;;149        {
;;;150            ESC_RUN(ESC_PWM1,ESC_PWM2);
00001a  4809              LDR      r0,|L7.64|
00001c  7801              LDRB     r1,[r0,#0]  ; ESC_PWM2
00001e  4809              LDR      r0,|L7.68|
000020  7800              LDRB     r0,[r0,#0]  ; ESC_PWM1
000022  f7fffffe          BL       ESC_RUN
;;;151            Laser_On();
000026  2003              MOVS     r0,#3
000028  f7fffffe          BL       bsp_LedOff
00002c  e004              B        |L7.56|
                  |L7.46|
;;;152            
;;;153        }
;;;154        else
;;;155        {
;;;156            ESC_STOP();
00002e  f7fffffe          BL       ESC_STOP
;;;157            Laser_Off();
000032  2003              MOVS     r0,#3
000034  f7fffffe          BL       bsp_LedOn
                  |L7.56|
;;;158    	}
;;;159    }
000038  bd10              POP      {r4,pc}
;;;160    u8 Get_ESC_Flag(void)
                          ENDP

00003a  0000              DCW      0x0000
                  |L7.60|
                          DCD      ESC_Flag
                  |L7.64|
                          DCD      ESC_PWM2
                  |L7.68|
                          DCD      ESC_PWM1

                          AREA ||i.Get_ESC_Flag||, CODE, READONLY, ALIGN=2

                  Get_ESC_Flag PROC
;;;159    }
;;;160    u8 Get_ESC_Flag(void)
000000  4801              LDR      r0,|L8.8|
;;;161    {
;;;162        return ESC_Flag;
000002  7800              LDRB     r0,[r0,#0]  ; ESC_Flag
;;;163    }
000004  4770              BX       lr
;;;164    u8 Set_ESC_Flag(u8 flag)
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      ESC_Flag

                          AREA ||i.Model_Select_Initial||, CODE, READONLY, ALIGN=2

                  Model_Select_Initial PROC
;;;196    
;;;197    void Model_Select_Initial(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;198    {
;;;199     	GPIO_InitTypeDef GPIO_InitStructure;
;;;200    
;;;201    	/* 打开GPIO时钟 */
;;;202    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC | RCC_AHB1Periph_GPIOB, ENABLE);
000002  2101              MOVS     r1,#1
000004  2006              MOVS     r0,#6
000006  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;203    
;;;204      GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_10;
00000a  f2404003          MOV      r0,#0x403
00000e  9000              STR      r0,[sp,#0]
;;;205    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;		/* 设为输出口 */
000010  2000              MOVS     r0,#0
000012  f88d0004          STRB     r0,[sp,#4]
;;;206    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;		/* 设为推挽模式 */
000016  f88d0006          STRB     r0,[sp,#6]
;;;207    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;	/* 上下拉电阻不使能 */
00001a  f88d0007          STRB     r0,[sp,#7]
;;;208    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;	/* IO口最大速度 */
00001e  2003              MOVS     r0,#3
000020  f88d0005          STRB     r0,[sp,#5]
;;;209    	GPIO_Init(GPIOB, &GPIO_InitStructure);
000024  4669              MOV      r1,sp
000026  480a              LDR      r0,|L9.80|
000028  f7fffffe          BL       GPIO_Init
;;;210    	
;;;211      GPIO_InitStructure.GPIO_Pin=GPIO_Pin_11;
00002c  f44f6000          MOV      r0,#0x800
000030  9000              STR      r0,[sp,#0]
;;;212    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;		/* 设为输出口 */
000032  2000              MOVS     r0,#0
000034  f88d0004          STRB     r0,[sp,#4]
;;;213    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;		/* 设为推挽模式 */
000038  f88d0006          STRB     r0,[sp,#6]
;;;214    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;	/* 上下拉电阻不使能 */
00003c  f88d0007          STRB     r0,[sp,#7]
;;;215    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;	/* IO口最大速度 */
000040  2003              MOVS     r0,#3
000042  f88d0005          STRB     r0,[sp,#5]
;;;216    	GPIO_Init(GPIOC, &GPIO_InitStructure);	
000046  4669              MOV      r1,sp
000048  4802              LDR      r0,|L9.84|
00004a  f7fffffe          BL       GPIO_Init
;;;217    	
;;;218    }
00004e  bd1c              POP      {r2-r4,pc}
                          ENDP

                  |L9.80|
                          DCD      0x40020400
                  |L9.84|
                          DCD      0x40020800

                          AREA ||i.Set_ESC_Flag||, CODE, READONLY, ALIGN=2

                  Set_ESC_Flag PROC
;;;163    }
;;;164    u8 Set_ESC_Flag(u8 flag)
000000  4601              MOV      r1,r0
;;;165    {
;;;166        ESC_Flag = flag;
000002  4802              LDR      r0,|L10.12|
000004  7001              STRB     r1,[r0,#0]
;;;167    	return 0;
000006  2000              MOVS     r0,#0
;;;168    }
000008  4770              BX       lr
;;;169    
                          ENDP

00000a  0000              DCW      0x0000
                  |L10.12|
                          DCD      ESC_Flag

                          AREA ||i.TIM2_PWM_Configuration||, CODE, READONLY, ALIGN=2

                  TIM2_PWM_Configuration PROC
;;;8      u8 Run_Model,STILL_BUTTON,OVERPOWER_BUTTON,ADDBULLET_BUTTON,STARTBYHURT_BUTTON;
;;;9      void TIM2_PWM_Configuration(void)
000000  b500              PUSH     {lr}
;;;10     {
000002  b08b              SUB      sp,sp,#0x2c
;;;11         GPIO_InitTypeDef          gpio;
;;;12         TIM_TimeBaseInitTypeDef   tim;
;;;13         TIM_OCInitTypeDef         oc;
;;;14     
;;;15         RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA | RCC_AHB1Periph_GPIOB,ENABLE);//打开时钟
000004  2101              MOVS     r1,#1
000006  2003              MOVS     r0,#3
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;16         RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  4608              MOV      r0,r1
000010  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;17     	//GPIO 初始化
;;;18         gpio.GPIO_Pin = GPIO_Pin_3;//PB3 PB11
000014  2008              MOVS     r0,#8
000016  9009              STR      r0,[sp,#0x24]
;;;19         gpio.GPIO_Mode = GPIO_Mode_AF;
000018  2002              MOVS     r0,#2
00001a  f88d0028          STRB     r0,[sp,#0x28]
;;;20         gpio.GPIO_Speed = GPIO_Speed_100MHz;
00001e  2003              MOVS     r0,#3
000020  f88d0029          STRB     r0,[sp,#0x29]
;;;21         GPIO_Init(GPIOB,&gpio);
000024  a909              ADD      r1,sp,#0x24
000026  4832              LDR      r0,|L11.240|
000028  f7fffffe          BL       GPIO_Init
;;;22     
;;;23         gpio.GPIO_Pin = GPIO_Pin_15|GPIO_Pin_2;//PA2 PA15
00002c  f2480004          MOV      r0,#0x8004
000030  9009              STR      r0,[sp,#0x24]
;;;24         gpio.GPIO_Mode = GPIO_Mode_AF;
000032  2002              MOVS     r0,#2
000034  f88d0028          STRB     r0,[sp,#0x28]
;;;25         gpio.GPIO_Speed = GPIO_Speed_100MHz;
000038  2003              MOVS     r0,#3
00003a  f88d0029          STRB     r0,[sp,#0x29]
;;;26         GPIO_Init(GPIOA,&gpio);
00003e  a909              ADD      r1,sp,#0x24
000040  482c              LDR      r0,|L11.244|
000042  f7fffffe          BL       GPIO_Init
;;;27     
;;;28         GPIO_PinAFConfig(GPIOB,GPIO_PinSource3, GPIO_AF_TIM2);//开启复用
000046  2201              MOVS     r2,#1
000048  2103              MOVS     r1,#3
00004a  4829              LDR      r0,|L11.240|
00004c  f7fffffe          BL       GPIO_PinAFConfig
;;;29         GPIO_PinAFConfig(GPIOA,GPIO_PinSource15,GPIO_AF_TIM2);
000050  2201              MOVS     r2,#1
000052  210f              MOVS     r1,#0xf
000054  4827              LDR      r0,|L11.244|
000056  f7fffffe          BL       GPIO_PinAFConfig
;;;30     //	GPIO_PinAFConfig(GPIOB,GPIO_PinSource11, GPIO_AF_TIM2);
;;;31         GPIO_PinAFConfig(GPIOA,GPIO_PinSource2,GPIO_AF_TIM2);
00005a  2201              MOVS     r2,#1
00005c  2102              MOVS     r1,#2
00005e  4825              LDR      r0,|L11.244|
000060  f7fffffe          BL       GPIO_PinAFConfig
;;;32         //定时器时钟配置
;;;33         tim.TIM_Prescaler = 84-1;//1MHZ
000064  2053              MOVS     r0,#0x53
000066  f8ad0018          STRH     r0,[sp,#0x18]
;;;34         tim.TIM_CounterMode = TIM_CounterMode_Up;
00006a  2000              MOVS     r0,#0
00006c  f8ad001a          STRH     r0,[sp,#0x1a]
;;;35         tim.TIM_Period = 20000; //20ms
000070  f6446020          MOV      r0,#0x4e20
000074  9007              STR      r0,[sp,#0x1c]
;;;36         tim.TIM_ClockDivision = TIM_CKD_DIV1;
000076  2000              MOVS     r0,#0
000078  f8ad0020          STRH     r0,[sp,#0x20]
;;;37         TIM_TimeBaseInit(TIM2,&tim);
00007c  a906              ADD      r1,sp,#0x18
00007e  f04f4080          MOV      r0,#0x40000000
000082  f7fffffe          BL       TIM_TimeBaseInit
;;;38     
;;;39         oc.TIM_OCMode = TIM_OCMode_PWM2;
000086  2070              MOVS     r0,#0x70
000088  f8ad0004          STRH     r0,[sp,#4]
;;;40         oc.TIM_OutputState = TIM_OutputState_Enable;//输出使能
00008c  2001              MOVS     r0,#1
00008e  f8ad0006          STRH     r0,[sp,#6]
;;;41         oc.TIM_Pulse = 0;
000092  2000              MOVS     r0,#0
000094  9003              STR      r0,[sp,#0xc]
;;;42         oc.TIM_OCPolarity = TIM_OCPolarity_Low;
000096  2002              MOVS     r0,#2
000098  f8ad0010          STRH     r0,[sp,#0x10]
;;;43     
;;;44         TIM_OC1Init(TIM2,&oc);
00009c  a901              ADD      r1,sp,#4
00009e  0740              LSLS     r0,r0,#29
0000a0  f7fffffe          BL       TIM_OC1Init
;;;45         TIM_OC2Init(TIM2,&oc);
0000a4  a901              ADD      r1,sp,#4
0000a6  f04f4080          MOV      r0,#0x40000000
0000aa  f7fffffe          BL       TIM_OC2Init
;;;46     	TIM_OC3Init(TIM2,&oc);
0000ae  a901              ADD      r1,sp,#4
0000b0  f04f4080          MOV      r0,#0x40000000
0000b4  f7fffffe          BL       TIM_OC3Init
;;;47     	
;;;48     
;;;49         TIM_OC1PreloadConfig(TIM2,TIM_OCPreload_Enable);
0000b8  2108              MOVS     r1,#8
0000ba  06c8              LSLS     r0,r1,#27
0000bc  f7fffffe          BL       TIM_OC1PreloadConfig
;;;50         TIM_OC2PreloadConfig(TIM2,TIM_OCPreload_Enable);
0000c0  2108              MOVS     r1,#8
0000c2  06c8              LSLS     r0,r1,#27
0000c4  f7fffffe          BL       TIM_OC2PreloadConfig
;;;51     	  TIM_OC3PreloadConfig(TIM2,TIM_OCPreload_Enable);
0000c8  2108              MOVS     r1,#8
0000ca  06c8              LSLS     r0,r1,#27
0000cc  f7fffffe          BL       TIM_OC3PreloadConfig
;;;52         
;;;53     
;;;54         TIM_ARRPreloadConfig(TIM2,ENABLE);
0000d0  2101              MOVS     r1,#1
0000d2  0788              LSLS     r0,r1,#30
0000d4  f7fffffe          BL       TIM_ARRPreloadConfig
;;;55     
;;;56         TIM_Cmd(TIM2,ENABLE);
0000d8  2101              MOVS     r1,#1
0000da  0788              LSLS     r0,r1,#30
0000dc  f7fffffe          BL       TIM_Cmd
;;;57         Laser_Off();
0000e0  2003              MOVS     r0,#3
0000e2  f7fffffe          BL       bsp_LedOn
;;;58     	Duoji_Open();
0000e6  f7fffffe          BL       Duoji_Open
;;;59     //	Duoji_Close();
;;;60     }
0000ea  b00b              ADD      sp,sp,#0x2c
0000ec  bd00              POP      {pc}
;;;61     
                          ENDP

0000ee  0000              DCW      0x0000
                  |L11.240|
                          DCD      0x40020400
                  |L11.244|
                          DCD      0x40020000

                          AREA ||i.TIM3_PWM_Configuration||, CODE, READONLY, ALIGN=2

                  TIM3_PWM_Configuration PROC
;;;61     
;;;62      void TIM3_PWM_Configuration(void)
000000  b500              PUSH     {lr}
;;;63      {
000002  b08b              SUB      sp,sp,#0x2c
;;;64      	GPIO_InitTypeDef          gpio;
;;;65          TIM_TimeBaseInitTypeDef   tim;
;;;66          TIM_OCInitTypeDef         oc;
;;;67     
;;;68          RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC|RCC_AHB1Periph_GPIOB,ENABLE);//打开时钟
000004  2101              MOVS     r1,#1
000006  2006              MOVS     r0,#6
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;69          RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  2002              MOVS     r0,#2
000010  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;70      	//GPIO 初始化
;;;71     //     gpio.GPIO_Pin = GPIO_Pin_4|GPIO_Pin_5;//PB4 PB5
;;;72     //     gpio.GPIO_Mode = GPIO_Mode_AF;
;;;73     //     gpio.GPIO_Speed = GPIO_Speed_100MHz;
;;;74     //     GPIO_Init(GPIOB,&gpio);
;;;75     
;;;76          gpio.GPIO_Pin = GPIO_Pin_9;//PC8 PC9
000014  f44f7000          MOV      r0,#0x200
000018  9009              STR      r0,[sp,#0x24]
;;;77          gpio.GPIO_Mode = GPIO_Mode_AF;
00001a  2002              MOVS     r0,#2
00001c  f88d0028          STRB     r0,[sp,#0x28]
;;;78          gpio.GPIO_Speed = GPIO_Speed_100MHz;
000020  2003              MOVS     r0,#3
000022  f88d0029          STRB     r0,[sp,#0x29]
;;;79          GPIO_Init(GPIOC,&gpio);
000026  a909              ADD      r1,sp,#0x24
000028  481a              LDR      r0,|L12.148|
00002a  f7fffffe          BL       GPIO_Init
;;;80     
;;;81     //     GPIO_PinAFConfig(GPIOB,GPIO_PinSource4, GPIO_AF_TIM3);//开启复用
;;;82     //     GPIO_PinAFConfig(GPIOB,GPIO_PinSource5, GPIO_AF_TIM3);
;;;83     // 	GPIO_PinAFConfig(GPIOC,GPIO_PinSource8, GPIO_AF_TIM3);
;;;84          GPIO_PinAFConfig(GPIOC,GPIO_PinSource9, GPIO_AF_TIM3);
00002e  2202              MOVS     r2,#2
000030  2109              MOVS     r1,#9
000032  4818              LDR      r0,|L12.148|
000034  f7fffffe          BL       GPIO_PinAFConfig
;;;85          //定时器时钟配置
;;;86          tim.TIM_Prescaler = 84-1;//1MHZ
000038  2053              MOVS     r0,#0x53
00003a  f8ad0018          STRH     r0,[sp,#0x18]
;;;87          tim.TIM_CounterMode = TIM_CounterMode_Up;
00003e  2000              MOVS     r0,#0
000040  f8ad001a          STRH     r0,[sp,#0x1a]
;;;88          tim.TIM_Period = 1000; //20ms
000044  f44f707a          MOV      r0,#0x3e8
000048  9007              STR      r0,[sp,#0x1c]
;;;89          tim.TIM_ClockDivision = TIM_CKD_DIV1;
00004a  2000              MOVS     r0,#0
00004c  f8ad0020          STRH     r0,[sp,#0x20]
;;;90          TIM_TimeBaseInit(TIM3,&tim);
000050  a906              ADD      r1,sp,#0x18
000052  4811              LDR      r0,|L12.152|
000054  f7fffffe          BL       TIM_TimeBaseInit
;;;91     
;;;92          oc.TIM_OCMode = TIM_OCMode_PWM2;
000058  2070              MOVS     r0,#0x70
00005a  f8ad0004          STRH     r0,[sp,#4]
;;;93          oc.TIM_OutputState = TIM_OutputState_Enable;//输出使能
00005e  2001              MOVS     r0,#1
000060  f8ad0006          STRH     r0,[sp,#6]
;;;94          oc.TIM_Pulse = 0;
000064  2000              MOVS     r0,#0
000066  9003              STR      r0,[sp,#0xc]
;;;95          oc.TIM_OCPolarity = TIM_OCPolarity_Low;
000068  2002              MOVS     r0,#2
00006a  f8ad0010          STRH     r0,[sp,#0x10]
;;;96     
;;;97     //     TIM_OC1Init(TIM3,&oc);
;;;98     //     TIM_OC2Init(TIM3,&oc);
;;;99     // 	TIM_OC3Init(TIM3,&oc);
;;;100     	TIM_OC4Init(TIM3,&oc);
00006e  a901              ADD      r1,sp,#4
000070  4809              LDR      r0,|L12.152|
000072  f7fffffe          BL       TIM_OC4Init
;;;101    
;;;102    //     TIM_OC1PreloadConfig(TIM3,TIM_OCPreload_Enable);
;;;103    //     TIM_OC2PreloadConfig(TIM3,TIM_OCPreload_Enable);
;;;104    // 	TIM_OC3PreloadConfig(TIM3,TIM_OCPreload_Enable);
;;;105         TIM_OC4PreloadConfig(TIM3,TIM_OCPreload_Enable);
000076  2108              MOVS     r1,#8
000078  4807              LDR      r0,|L12.152|
00007a  f7fffffe          BL       TIM_OC4PreloadConfig
;;;106    
;;;107         TIM_ARRPreloadConfig(TIM3,ENABLE);
00007e  2101              MOVS     r1,#1
000080  4805              LDR      r0,|L12.152|
000082  f7fffffe          BL       TIM_ARRPreloadConfig
;;;108    
;;;109         TIM_Cmd(TIM3,ENABLE);
000086  2101              MOVS     r1,#1
000088  4803              LDR      r0,|L12.152|
00008a  f7fffffe          BL       TIM_Cmd
;;;110     }
00008e  b00b              ADD      sp,sp,#0x2c
000090  bd00              POP      {pc}
;;;111    
                          ENDP

000092  0000              DCW      0x0000
                  |L12.148|
                          DCD      0x40020800
                  |L12.152|
                          DCD      0x40000400

                          AREA ||.ARM.exidx||, LINKORDER=||i.Duoji_Open||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i.Duoji_Open||
                          DCD      0x00000001

                          AREA ||area_number.14||, LINKORDER=||i.TIM2_PWM_Configuration||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.14||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.TIM2_PWM_Configuration||
                          DCD      0x00000001

                          AREA ||area_number.15||, LINKORDER=||i.TIM3_PWM_Configuration||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.15||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.TIM3_PWM_Configuration||
                          DCD      0x00000001

                          AREA ||area_number.16||, LINKORDER=||i.ESC_Init||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.16||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.ESC_Init||
                          DCD      0x00000001

                          AREA ||area_number.17||, LINKORDER=||i.ESC_RUN||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.17||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.ESC_RUN||
                          DCD      0x00000001

                          AREA ||area_number.18||, LINKORDER=||i.Set_ESC_Flag||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.18||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.Set_ESC_Flag||
                          DCD      0x00000001

                          AREA ||area_number.19||, LINKORDER=||i.ESC_STOP||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.19||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.ESC_STOP||
                          DCD      0x00000001

                          AREA ||area_number.20||, LINKORDER=||i.ESC_Toggle||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.20||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.ESC_Toggle||
                          DCD      0x00000001

                          AREA ||area_number.21||, LINKORDER=||i.Get_ESC_Flag||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.21||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.Get_ESC_Flag||
                          DCD      0x00000001

                          AREA ||area_number.22||, LINKORDER=||i.Duoji_Close||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.22||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.Duoji_Close||
                          DCD      0x00000001

                          AREA ||area_number.23||, LINKORDER=||i.Duoji_Toggle||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.23||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.Duoji_Toggle||
                          DCD      0x00000001

                          AREA ||area_number.24||, LINKORDER=||i.Model_Select_Initial||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.24||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.Model_Select_Initial||
                          DCD      0x00000001

                          AREA ||.data||, DATA, ALIGN=0

                  Run_Model
000000  00                DCB      0x00
                  STILL_BUTTON
000001  00                DCB      0x00
                  OVERPOWER_BUTTON
000002  00                DCB      0x00
                  ADDBULLET_BUTTON
000003  00                DCB      0x00
                  STARTBYHURT_BUTTON
000004  00                DCB      0x00
                  ESC_Flag
000005  00                DCB      0x00
                  flag
000006  01                DCB      0x01

;*** Start embedded assembler ***

#line 1 "..\\..\\MySrc\\pwm.cpp"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_pwm_cpp_5847fb19___Z7__REV16j|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___7_pwm_cpp_5847fb19___Z7__REV16j| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_pwm_cpp_5847fb19___Z7__REVSHi|
#line 144
|__asm___7_pwm_cpp_5847fb19___Z7__REVSHi| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___7_pwm_cpp_5847fb19___Z5__RRXj|
#line 300
|__asm___7_pwm_cpp_5847fb19___Z5__RRXj| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
